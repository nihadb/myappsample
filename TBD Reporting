--------------------------------------------------------
--  File created - Saturday-August-24-2024   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Type OBJECTS_LIST
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "ADMIN"."OBJECTS_LIST" IS TABLE OF VARCHAR2(32767)




/
--------------------------------------------------------
--  DDL for Type REPORT_TEMPLATE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "ADMIN"."REPORT_TEMPLATE" AS OBJECT (reportType                 		INTEGER, useDescriptionInfo         		INTEGER, useQuantitativeInfo         		INTEGER, useDiagrams                 		INTEGER, useTableColumns             		INTEGER, useTableColumnsComments     		INTEGER, useTableIndexes             		INTEGER, useTableConstraints         		INTEGER, useTableFKReferringTo       		INTEGER, useTableFKReferredFrom      		INTEGER, useEntityAttributes         		INTEGER, useEntityAttributesComments 		INTEGER, useEntityConstraints        		INTEGER, useEntityIdentifiers      			INTEGER, useEntityRelationships      		INTEGER, useEntityIncomingProcesses  		INTEGER, useEntityOutgoingProcesses  		INTEGER, useDomainConstraints        		INTEGER, useDomainUsedInTables       		INTEGER, useDomainUsedInEntities     		INTEGER, useSTAttributes             		INTEGER, useSTAttributesComments     		INTEGER, useSTMethods                		INTEGER, useSTUsedInTables           		INTEGER, useSTUsedInEntities         		INTEGER, useCTUsedInTables           		INTEGER, useCTUsedInEntities         		INTEGER, useCTUsedInStructuredTypes  		INTEGER, useDTUsedInTables           		INTEGER, useDTUsedInEntities         		INTEGER, useDTUsedInStructuredTypes  		INTEGER, useSTUsedInStructuredTypes  		INTEGER, useDomainUsedInStructuredTypes  	INTEGER, useCRImpactedObjects        		INTEGER, useMRImpactedObjects        		INTEGER)




/
--------------------------------------------------------
--  DDL for Sequence SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "ADMIN"."SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 41 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Table D_ACCOUNT
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_ACCOUNT" 
   (	"ACCOUNT_ID" VARCHAR2(100 BYTE), 
	"OWNER_NAME" VARCHAR2(100 BYTE), 
	"PHONE_NUMBER" VARCHAR2(100 BYTE), 
	"EMAIL_ADDRESS" VARCHAR2(100 BYTE), 
	"OPEN_DATE" VARCHAR2(100 BYTE), 
	"CLOSE_DATE" VARCHAR2(100 BYTE), 
	"REPORTING_NAME" VARCHAR2(100 BYTE), 
	"IS_ACTIVE" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_ACCOUNT_PNL
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_ACCOUNT_PNL" 
   (	"ACCOUNT_ID" VARCHAR2(100 BYTE), 
	"RUN_GROUP_NAME" VARCHAR2(100 BYTE), 
	"REPORT_DATE" VARCHAR2(100 BYTE), 
	"CATEGORY_NAME" VARCHAR2(100 BYTE), 
	"ITEM_NAME" VARCHAR2(100 BYTE), 
	"AMOUNT" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_ACCOUNT_SETTING
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_ACCOUNT_SETTING" 
   (	"ACCOUNT_ID" VARCHAR2(100 BYTE), 
	"RUN_GROUP_NAME" VARCHAR2(100 BYTE), 
	"SETTING_NAME" VARCHAR2(100 BYTE), 
	"SETTING_VALUE" VARCHAR2(100 BYTE), 
	"START_DATE" VARCHAR2(100 BYTE), 
	"END_DATE" VARCHAR2(100 BYTE), 
	"CREATION_DATE" DATE, 
	"SETTING_CATEGORY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_ACCOUNT_TRADE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_ACCOUNT_TRADE" 
   (	"ACCOUNT_ID" VARCHAR2(100 BYTE), 
	"RUN_GROUP_NAME" VARCHAR2(100 BYTE), 
	"SYMBOL" VARCHAR2(100 BYTE), 
	"RISK" NUMBER, 
	"TRADE_SHARE" NUMBER, 
	"POSITION_SIZE" NUMBER, 
	"QTY" NUMBER, 
	"TRADE_TYPE" VARCHAR2(100 BYTE), 
	"ENTER_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"ENTER_MODEL_PRICE" NUMBER, 
	"INITIAL_STOP_LOSS" NUMBER, 
	"TRAILING_STOP_LOSS" NUMBER, 
	"INITIAL_TAKE_PROFIT" NUMBER, 
	"TRAILING_TAKE_PROFIT" NUMBER, 
	"EXIT_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"EXIT_MODEL_PRICE" NUMBER, 
	"EXIT_TYPE" VARCHAR2(100 BYTE), 
	"ENTER_TRADE_TIMESTAMP" VARCHAR2(100 BYTE), 
	"CANCEL_TRADE_TIMESTAMP" VARCHAR2(100 BYTE), 
	"EXIT_TRADE_TIMESTAMP" VARCHAR2(100 BYTE), 
	"ENTER_TRADE_PRICE" NUMBER, 
	"EXIT_TRADE_PRICE" NUMBER, 
	"PROFIT" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"COMMISSION_ENTER" NUMBER, 
	"COMMISSION_EXIT" NUMBER, 
	"ENTER_PERMID" VARCHAR2(100 BYTE), 
	"EXIT_PERMID" VARCHAR2(100 BYTE), 
	"STOP_ORDER_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_IB_CLOSED_ORDER
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_IB_CLOSED_ORDER" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"PERMID" VARCHAR2(100 BYTE), 
	"COMPLETIONTIME" VARCHAR2(100 BYTE), 
	"STATUS" VARCHAR2(100 BYTE), 
	"ACTION" VARCHAR2(100 BYTE), 
	"ORDERTYPE" VARCHAR2(100 BYTE), 
	"TOTALQTY" NUMBER, 
	"FILLEDQTY" NUMBER, 
	"LMTPRICE" NUMBER, 
	"AUXPRICE" NUMBER, 
	"OCAGROUP" VARCHAR2(100 BYTE), 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"ORDERID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_IB_CLOSED_ORDER_DETAILS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_IB_CLOSED_ORDER_DETAILS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"PERMID" VARCHAR2(100 BYTE), 
	"EXECID" VARCHAR2(100 BYTE), 
	"EXECUTIONTIME" VARCHAR2(100 BYTE), 
	"PRICE" NUMBER, 
	"SHARES" NUMBER, 
	"COMMISSION" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_IB_OPEN_ORDER
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_IB_OPEN_ORDER" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"PERMID" VARCHAR2(100 BYTE), 
	"ORDERID" NUMBER, 
	"ACTION" VARCHAR2(100 BYTE), 
	"ORDERTYPE" VARCHAR2(100 BYTE), 
	"OCAGROUP" VARCHAR2(100 BYTE), 
	"LMTPRICE" NUMBER, 
	"AUXPRICE" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_DATA_STATS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_DATA_STATS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"TICK_HIGH" NUMBER, 
	"TICK_LOW" NUMBER, 
	"TICK_OPEN" NUMBER, 
	"TICK_CLOSE" NUMBER, 
	"ATR" NUMBER, 
	"PREV_ATR" NUMBER, 
	"PREV_CLOSE" NUMBER, 
	"INTERVAL_HIGH" NUMBER, 
	"INTERVAL_LOW" NUMBER, 
	"INTERVAL_CLOSE" NUMBER, 
	"INTERVAL_OPEN" NUMBER, 
	"INTERVAL_TR" NUMBER, 
	"INTERVAL_TICK_TR" NUMBER, 
	"PREV_CLOSE_GAP" NUMBER, 
	"PREV_CLOSE_GAP_ATR" NUMBER, 
	"INTERVAL_OPEN_GAP" NUMBER, 
	"INTERVAL_OPEN_GAP_ATR" NUMBER, 
	"INTERVAL_TR_RATIO" NUMBER, 
	"INTERVAL_TICK_TR_RATIO" NUMBER, 
	"MONTH_INTERVAL_TR_RATIO" NUMBER, 
	"MONTH_TICK_TR_RATIO" NUMBER, 
	"WEEK_INTERVAL_TR_RATIO" NUMBER, 
	"WEEK_TICK_TR_RATIO" NUMBER, 
	"MONTH_PREV_CLOSE_GAP" NUMBER, 
	"MONTH_INTERVAL_OPEN_GAP" NUMBER, 
	"WEEK_PREV_CLOSE_GAP" NUMBER, 
	"WEEK_INTERVAL_OPEN_GAP" NUMBER, 
	"MONTH_PREV_CLOSE_GAP_ATR" NUMBER, 
	"MONTH_INTERVAL_OPEN_GAP_ATR" NUMBER, 
	"WEEK_PREV_CLOSE_GAP_ATR" NUMBER, 
	"WEEK_INTERVAL_OPEN_GAP_ATR" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_PIVOTS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_PIVOTS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"PIVOT_TIMESTAMP" VARCHAR2(100 BYTE), 
	"PIVOT_TYPE" VARCHAR2(4 BYTE), 
	"HIGH" NUMBER, 
	"LOW" NUMBER, 
	"CLOSE" NUMBER, 
	"OPEN" NUMBER, 
	"PIVOT_VALUE" NUMBER, 
	"PIVOT_STATUS" CHAR(1 BYTE), 
	"PIVOT_STATUS_TS" VARCHAR2(100 BYTE), 
	"PIVOT_SUB_TYPE" CHAR(2 BYTE), 
	"SIG_PIVOT_STATUS_TS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_TICK_EMA
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_TICK_EMA" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"CLOSE" NUMBER, 
	"EMA_12_30_POSITION" NUMBER, 
	"EMA_30_50_POSITION" NUMBER, 
	"EMA_50_200_POSITION" NUMBER, 
	"EMA_TREND_POSITION" NUMBER, 
	"SLOPE_EMA12" NUMBER, 
	"SLOPE_EMA30" NUMBER, 
	"SLOPE_EMA50" NUMBER, 
	"SLOPE_EMA200" NUMBER, 
	"PROJ_INTER_CLOSE12_CLOSE30" NUMBER, 
	"PROJ_INTER_CLOSE30_CLOSE50" NUMBER, 
	"PROJ_INTER_CLOSE50_CLOSE200" NUMBER, 
	"CLOSE12_CLOSE30_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE12_CLOSE30_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE12_CLOSE30_T1_STATE" NUMBER, 
	"CLOSE12_CLOSE30_T1_STATE_TICKS" NUMBER, 
	"CLOSE12_CLOSE30_T1_STATE_HIGH" NUMBER, 
	"CLOSE12_CLOSE30_T1_STATE_LOW" NUMBER, 
	"CLOSE12_CLOSE30_T2_STATE" NUMBER, 
	"CLOSE12_CLOSE30_T2_STATE_TICKS" NUMBER, 
	"CLOSE12_CLOSE30_T2_STATE_HIGH" NUMBER, 
	"CLOSE12_CLOSE30_T2_STATE_LOW" NUMBER, 
	"CLOSE12_CLOSE30_STATE_HIGH" NUMBER, 
	"CLOSE12_CLOSE30_STATE_LOW" NUMBER, 
	"CLOSE12_CLOSE30_STATE_PEAK_GAP" NUMBER, 
	"CLOSE12_CLOSE30_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"CLOSE12_CLOSE30_STATE_CLOSE_LOW_GAP" NUMBER, 
	"CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR" NUMBER, 
	"CLOSE12_CLOSE30_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"CLOSE12_CLOSE30_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"CLOSE30_CLOSE50_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE30_CLOSE50_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE30_CLOSE50_T1_STATE" NUMBER, 
	"CLOSE30_CLOSE50_T1_STATE_TICKS" NUMBER, 
	"CLOSE30_CLOSE50_T1_STATE_HIGH" NUMBER, 
	"CLOSE30_CLOSE50_T1_STATE_LOW" NUMBER, 
	"CLOSE30_CLOSE50_T2_STATE" NUMBER, 
	"CLOSE30_CLOSE50_T2_STATE_TICKS" NUMBER, 
	"CLOSE30_CLOSE50_T2_STATE_HIGH" NUMBER, 
	"CLOSE30_CLOSE50_T2_STATE_LOW" NUMBER, 
	"CLOSE30_CLOSE50_STATE_HIGH" NUMBER, 
	"CLOSE30_CLOSE50_STATE_LOW" NUMBER, 
	"CLOSE30_CLOSE50_STATE_PEAK_GAP" NUMBER, 
	"CLOSE30_CLOSE50_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"CLOSE30_CLOSE50_STATE_CLOSE_LOW_GAP" NUMBER, 
	"CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR" NUMBER, 
	"CLOSE30_CLOSE50_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"CLOSE30_CLOSE50_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"CLOSE50_CLOSE200_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE50_CLOSE200_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"CLOSE50_CLOSE200_T1_STATE" NUMBER, 
	"CLOSE50_CLOSE200_T1_STATE_TICKS" NUMBER, 
	"CLOSE50_CLOSE200_T1_STATE_HIGH" NUMBER, 
	"CLOSE50_CLOSE200_T1_STATE_LOW" NUMBER, 
	"CLOSE50_CLOSE200_T2_STATE" NUMBER, 
	"CLOSE50_CLOSE200_T2_STATE_TICKS" NUMBER, 
	"CLOSE50_CLOSE200_T2_STATE_HIGH" NUMBER, 
	"CLOSE50_CLOSE200_T2_STATE_LOW" NUMBER, 
	"CLOSE50_CLOSE200_STATE_HIGH" NUMBER, 
	"CLOSE50_CLOSE200_STATE_LOW" NUMBER, 
	"CLOSE50_CLOSE200_STATE_PEAK_GAP" NUMBER, 
	"CLOSE50_CLOSE200_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"CLOSE50_CLOSE200_STATE_CLOSE_LOW_GAP" NUMBER, 
	"CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR" NUMBER, 
	"CLOSE50_CLOSE200_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"CLOSE50_CLOSE200_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"EMA12_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA12_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA12_T1_STATE" NUMBER, 
	"EMA12_T1_STATE_TICKS" NUMBER, 
	"EMA12_T1_STATE_HIGH" NUMBER, 
	"EMA12_T1_STATE_LOW" NUMBER, 
	"EMA12_T2_STATE" NUMBER, 
	"EMA12_T2_STATE_TICKS" NUMBER, 
	"EMA12_T2_STATE_HIGH" NUMBER, 
	"EMA12_T2_STATE_LOW" NUMBER, 
	"EMA12_STATE_HIGH" NUMBER, 
	"EMA12_STATE_LOW" NUMBER, 
	"EMA12_STATE_PEAK_GAP" NUMBER, 
	"EMA12_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"EMA12_STATE_CLOSE_LOW_GAP" NUMBER, 
	"EMA12_STATE_PEAK_GAP_ATR" NUMBER, 
	"EMA12_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"EMA12_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"EMA30_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA30_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA30_T1_STATE" NUMBER, 
	"EMA30_T1_STATE_TICKS" NUMBER, 
	"EMA30_T1_STATE_HIGH" NUMBER, 
	"EMA30_T1_STATE_LOW" NUMBER, 
	"EMA30_T2_STATE" NUMBER, 
	"EMA30_T2_STATE_TICKS" NUMBER, 
	"EMA30_T2_STATE_HIGH" NUMBER, 
	"EMA30_T2_STATE_LOW" NUMBER, 
	"EMA30_STATE_HIGH" NUMBER, 
	"EMA30_STATE_LOW" NUMBER, 
	"EMA30_STATE_PEAK_GAP" NUMBER, 
	"EMA30_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"EMA30_STATE_CLOSE_LOW_GAP" NUMBER, 
	"EMA30_STATE_PEAK_GAP_ATR" NUMBER, 
	"EMA30_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"EMA30_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"EMA50_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA50_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA50_T1_STATE" NUMBER, 
	"EMA50_T1_STATE_TICKS" NUMBER, 
	"EMA50_T1_STATE_HIGH" NUMBER, 
	"EMA50_T1_STATE_LOW" NUMBER, 
	"EMA50_T2_STATE" NUMBER, 
	"EMA50_T2_STATE_TICKS" NUMBER, 
	"EMA50_T2_STATE_HIGH" NUMBER, 
	"EMA50_T2_STATE_LOW" NUMBER, 
	"EMA50_STATE_HIGH" NUMBER, 
	"EMA50_STATE_LOW" NUMBER, 
	"EMA50_STATE_PEAK_GAP" NUMBER, 
	"EMA50_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"EMA50_STATE_CLOSE_LOW_GAP" NUMBER, 
	"EMA50_STATE_PEAK_GAP_ATR" NUMBER, 
	"EMA50_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"EMA50_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"EMA200_T1_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA200_T2_STATE_TS" VARCHAR2(100 BYTE), 
	"EMA200_T1_STATE" NUMBER, 
	"EMA200_T1_STATE_TICKS" NUMBER, 
	"EMA200_T1_STATE_HIGH" NUMBER, 
	"EMA200_T1_STATE_LOW" NUMBER, 
	"EMA200_T2_STATE" NUMBER, 
	"EMA200_T2_STATE_TICKS" NUMBER, 
	"EMA200_T2_STATE_HIGH" NUMBER, 
	"EMA200_T2_STATE_LOW" NUMBER, 
	"EMA200_STATE_HIGH" NUMBER, 
	"EMA200_STATE_LOW" NUMBER, 
	"EMA200_STATE_PEAK_GAP" NUMBER, 
	"EMA200_STATE_CLOSE_HIGH_GAP" NUMBER, 
	"EMA200_STATE_CLOSE_LOW_GAP" NUMBER, 
	"EMA200_STATE_PEAK_GAP_ATR" NUMBER, 
	"EMA200_STATE_CLOSE_HIGH_GAP_ATR" NUMBER, 
	"EMA200_STATE_CLOSE_LOW_GAP_ATR" NUMBER, 
	"EMA12_REJECT" NUMBER, 
	"EMA30_REJECT" NUMBER, 
	"EMA50_REJECT" NUMBER, 
	"EMA200_REJECT" NUMBER, 
	"EMA12_GAP_ATR" NUMBER, 
	"EMA30_GAP_ATR" NUMBER, 
	"EMA50_GAP_ATR" NUMBER, 
	"EMA200_GAP_ATR" NUMBER, 
	"CLOSE12_CLOSE30_GAP_ATR" NUMBER, 
	"CLOSE30_CLOSE50_GAP_ATR" NUMBER, 
	"CLOSE50_CLOSE200_GAP_ATR" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_TICK_SR
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_TICK_SR" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"ATR" NUMBER, 
	"SR_INTERVAL" VARCHAR2(100 BYTE), 
	"SR_TYPE" CHAR(5 BYTE), 
	"SR_LEVEL" VARCHAR2(4 BYTE), 
	"SR_TIMESTAMP" VARCHAR2(100 BYTE), 
	"SR_VALUE" NUMBER, 
	"PIVOT_TYPE" VARCHAR2(4 BYTE), 
	"SR_REJECT" NUMBER, 
	"SR_GAP" NUMBER, 
	"SR_GAP_ATR" NUMBER, 
	"SR_TIMESTAMP_SIG" VARCHAR2(100 BYTE), 
	"SR_VALUE_SIG" NUMBER, 
	"PIVOT_TYPE_SIG" VARCHAR2(4 BYTE), 
	"SR_REJECT_SIG" NUMBER, 
	"SR_GAP_SIG" NUMBER, 
	"SR_GAP_ATR_SIG" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_TICK_TRENDS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_TICK_TRENDS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"TREND_TYPE" VARCHAR2(4 BYTE), 
	"START_TS" VARCHAR2(100 BYTE), 
	"END_TS" VARCHAR2(100 BYTE), 
	"START_PIVOT_VALUE" NUMBER, 
	"END_PIVOT_VALUE" NUMBER, 
	"CLOSE" NUMBER, 
	"ATR" NUMBER, 
	"START_TREND_GAP_ATR" NUMBER, 
	"END_TREND_GAP_ATR" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_MKT_TRENDS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_MKT_TRENDS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TREND_TYPE" VARCHAR2(4 BYTE), 
	"TREND_START_TS" VARCHAR2(100 BYTE), 
	"TREND_START_NEXT_TS" VARCHAR2(100 BYTE), 
	"TREND_END_TS" VARCHAR2(100 BYTE), 
	"TREND_START_STATUS_TS" VARCHAR2(100 BYTE), 
	"TREND_END_STATUS_TS" VARCHAR2(100 BYTE), 
	"TREND_START_VALUE" NUMBER, 
	"TREND_END_VALUE" NUMBER, 
	"TREND_DURATION" NUMBER, 
	"TREND_SIZE" NUMBER, 
	"TREND_RESISTANCE_LOW_VALUE" NUMBER, 
	"TREND_RESISTANCE_HIGH_VALUE" NUMBER, 
	"TREND_SUPPORT_LOW_VALUE" NUMBER, 
	"TREND_SUPPORT_HIGH_VALUE" NUMBER, 
	"PREV_TREND_START_TS" VARCHAR2(100 BYTE), 
	"TREND_START_STATUS_TS_FILTER" VARCHAR2(100 BYTE), 
	"TREND_END_STATUS_TS_FILTER" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_RISK_PROFILES
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_RISK_PROFILES" 
   (	"RISK_LEVEL" VARCHAR2(100 BYTE), 
	"RISK_LEVE_NAME" VARCHAR2(100 BYTE), 
	"R" NUMBER, 
	"TRADE_SIZE" NUMBER, 
	"START_DATE" VARCHAR2(100 BYTE), 
	"END_DATE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_SYMBOL
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_SYMBOL" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"IS_ACTIVE" CHAR(1 BYTE), 
	"CREATION_DATE" CHAR(19 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_SYMBOL_EXCLUDE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_SYMBOL_EXCLUDE" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"CREATION_DATE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_SYMBOL_INCLUDE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_SYMBOL_INCLUDE" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"CREATION_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_SYMBOL_NOTIFICATION
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_SYMBOL_NOTIFICATION" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"NOTIFICATION_TYPE" VARCHAR2(100 BYTE), 
	"NOTIFICATION_VALUE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_TRADE_PERFORMANCE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_TRADE_PERFORMANCE" 
   (	"ACCOUNT_ID" VARCHAR2(100 BYTE), 
	"RUN_GROUP_NAME" VARCHAR2(100 BYTE), 
	"PERIOD_GROUP" VARCHAR2(5 BYTE), 
	"PERIOD_ID" VARCHAR2(201 BYTE), 
	"PERIOD_NAME" VARCHAR2(201 BYTE), 
	"FIRST_REPORTING_DAY" VARCHAR2(100 BYTE), 
	"LAST_REPORTING_DAY" VARCHAR2(100 BYTE), 
	"CASH_PERIOD" NUMBER, 
	"CASH_OVERALL" NUMBER, 
	"UTILIZED_AMOUNT" NUMBER, 
	"UTILIZED_RATIO" NUMBER, 
	"UTILIZED_AMOUNT_LONG" NUMBER, 
	"UTILIZED_AMOUNT_SHORT" NUMBER, 
	"PROFIT_PERIOD" NUMBER, 
	"PROFIT_OVERALL" NUMBER, 
	"COMMISSION_PERIOD" NUMBER, 
	"COMMISSION_OVERALL" NUMBER, 
	"CAPITAL" NUMBER, 
	"CAPITAL_INCREMENT" NUMBER, 
	"RETURN_RATE" NUMBER, 
	"SPY_RETURN_RATE" NUMBER, 
	"QQQ_RETURN_RATE" NUMBER, 
	"BRK_RETURN_RATE" NUMBER, 
	"AVG_DAY_RETURN_RATE" NUMBER, 
	"AVG_WEEK_RETURN_RATE" NUMBER, 
	"AVG_MONTH_RETURN_RATE" NUMBER, 
	"AVG_YEAR_RETURN_RATE" NUMBER, 
	"ULCER_5_INDEX" NUMBER, 
	"SPY_ULCER_5_INDEX" NUMBER, 
	"QQQ_ULCER_5_INDEX" NUMBER, 
	"BRK_ULCER_5_INDEX" NUMBER, 
	"ULCER_10_INDEX" NUMBER, 
	"SPY_ULCER_10_INDEX" NUMBER, 
	"QQQ_ULCER_10_INDEX" NUMBER, 
	"BRK_ULCER_10_INDEX" NUMBER, 
	"ULCER_20_INDEX" NUMBER, 
	"SPY_ULCER_20_INDEX" NUMBER, 
	"QQQ_ULCER_20_INDEX" NUMBER, 
	"BRK_ULCER_20_INDEX" NUMBER, 
	"MAX_DRAWDOWN" NUMBER, 
	"MAX_DRAWDOWN_FIRST_DAY" VARCHAR2(210 BYTE), 
	"MAX_DRAWDOWN_LAST_DAY" VARCHAR2(210 BYTE), 
	"MAX_MARKUP" NUMBER, 
	"MAX_MARKUP_FIRST_DAY" VARCHAR2(210 BYTE), 
	"MAX_MARKUP_LAST_DAY" VARCHAR2(210 BYTE), 
	"SPY_MAX_DRAWDOWN" NUMBER, 
	"SPY_MAX_DRAWDOWN_FIRST_DAY" VARCHAR2(210 BYTE), 
	"SPY_MAX_DRAWDOWN_LAST_DAY" VARCHAR2(210 BYTE), 
	"SPY_MAX_MARKUP" NUMBER, 
	"SPY_MAX_MARKUP_FIRST_DAY" VARCHAR2(210 BYTE), 
	"SPY_MAX_MARKUP_LAST_DAY" VARCHAR2(210 BYTE), 
	"QQQ_MAX_DRAWDOWN" NUMBER, 
	"QQQ_MAX_DRAWDOWN_FIRST_DAY" VARCHAR2(210 BYTE), 
	"QQQ_MAX_DRAWDOWN_LAST_DAY" VARCHAR2(210 BYTE), 
	"QQQ_MAX_MARKUP" NUMBER, 
	"QQQ_MAX_MARKUP_FIRST_DAY" VARCHAR2(210 BYTE), 
	"QQQ_MAX_MARKUP_LAST_DAY" VARCHAR2(210 BYTE), 
	"BRK_MAX_DRAWDOWN" NUMBER, 
	"BRK_MAX_DRAWDOWN_FIRST_DAY" VARCHAR2(210 BYTE), 
	"BRK_MAX_DRAWDOWN_LAST_DAY" VARCHAR2(210 BYTE), 
	"BRK_MAX_MARKUP" NUMBER, 
	"BRK_MAX_MARKUP_FIRST_DAY" VARCHAR2(210 BYTE), 
	"BRK_MAX_MARKUP_LAST_DAY" VARCHAR2(210 BYTE), 
	"POSSIBLE_TRADES" NUMBER, 
	"EXCLUDE_TRADES" NUMBER, 
	"TRADES_EXCLUDE_RATE" NUMBER, 
	"PENDING_TRADES" NUMBER, 
	"CANCELED_TRADES" NUMBER, 
	"NEW_TRADES" NUMBER, 
	"TRADES_FILL_RATE" NUMBER, 
	"OPEN_TRADES" NUMBER, 
	"OPEN_PROFIT" NUMBER, 
	"OPEN_TRADES_HOLDING_TIME" NUMBER, 
	"OPEN_WIN_TRADES" NUMBER, 
	"OPEN_LOSS_TRADES" NUMBER, 
	"OPEN_WIN_RATIO" NUMBER, 
	"OPEN_R_PERCENT" NUMBER, 
	"OPEN_R_MULTIPLE" NUMBER, 
	"OPEN_WIN_R_MULTIPLE" NUMBER, 
	"OPEN_LOSS_R_MULTIPLE" NUMBER, 
	"NEW_TRADES_LONG" NUMBER, 
	"OPEN_TRADES_LONG" NUMBER, 
	"OPEN_PROFIT_LONG" NUMBER, 
	"OPEN_TRADES_HOLDING_TIME_LONG" NUMBER, 
	"OPEN_WIN_TRADES_LONG" NUMBER, 
	"OPEN_LOSS_TRADES_LONG" NUMBER, 
	"OPEN_WIN_RATIO_LONG" NUMBER, 
	"OPEN_R_PERCENT_LONG" NUMBER, 
	"OPEN_R_MULTIPLE_LONG" NUMBER, 
	"OPEN_WIN_R_MULTIPLE_LONG" NUMBER, 
	"OPEN_LOSS_R_MULTIPLE_LONG" NUMBER, 
	"NEW_TRADES_SHORT" NUMBER, 
	"OPEN_TRADES_SHORT" NUMBER, 
	"OPEN_PROFIT_SHORT" NUMBER, 
	"OPEN_TRADES_HOLDING_TIME_SHORT" NUMBER, 
	"OPEN_WIN_TRADES_SHORT" NUMBER, 
	"OPEN_LOSS_TRADES_SHORT" NUMBER, 
	"OPEN_WIN_RATIO_SHORT" NUMBER, 
	"OPEN_R_PERCENT_SHORT" NUMBER, 
	"OPEN_R_MULTIPLE_SHORT" NUMBER, 
	"OPEN_WIN_R_MULTIPLE_SHORT" NUMBER, 
	"OPEN_LOSS_R_MULTIPLE_SHORT" NUMBER, 
	"CLOSED_TRADES" NUMBER, 
	"CLOSED_PROFIT" NUMBER, 
	"CLOSED_WIN_PROFIT" NUMBER, 
	"CLOSED_LOSS_PROFIT" NUMBER, 
	"CLOSED_TRADES_HOLDING_TIME" NUMBER, 
	"CLOSED_WIN_TRADES" NUMBER, 
	"CLOSED_LOSS_TRADES" NUMBER, 
	"CLOSED_WIN_RATIO" NUMBER, 
	"CLOSED_R_PERCENT" NUMBER, 
	"CLOSED_R_MULTIPLE" NUMBER, 
	"CLOSED_WIN_R_MULTIPLE" NUMBER, 
	"CLOSED_LOSS_R_MULTIPLE" NUMBER, 
	"CLOSED_WIN_MAX" NUMBER, 
	"CLOSED_LOSS_MAX" NUMBER, 
	"CLOSED_WIN_AVG" NUMBER, 
	"CLOSED_LOSS_AVG" NUMBER, 
	"CLOSED_TRADES_LONG" NUMBER, 
	"CLOSED_PROFIT_LONG" NUMBER, 
	"CLOSED_WIN_PROFIT_LONG" NUMBER, 
	"CLOSED_LOSS_PROFIT_LONG" NUMBER, 
	"CLOSED_TRADES_HOLDING_TIME_LONG" NUMBER, 
	"CLOSED_WIN_TRADES_LONG" NUMBER, 
	"CLOSED_LOSS_TRADES_LONG" NUMBER, 
	"CLOSED_WIN_RATIO_LONG" NUMBER, 
	"CLOSED_R_PERCENT_LONG" NUMBER, 
	"CLOSED_R_MULTIPLE_LONG" NUMBER, 
	"CLOSED_WIN_R_MULTIPLE_LONG" NUMBER, 
	"CLOSED_LOSS_R_MULTIPLE_LONG" NUMBER, 
	"CLOSED_WIN_MAX_LONG" NUMBER, 
	"CLOSED_LOSS_MAX_LONG" NUMBER, 
	"CLOSED_WIN_AVG_LONG" NUMBER, 
	"CLOSED_LOSS_AVG_LONG" NUMBER, 
	"CLOSED_TRADES_SHORT" NUMBER, 
	"CLOSED_PROFIT_SHORT" NUMBER, 
	"CLOSED_WIN_PROFIT_SHORT" NUMBER, 
	"CLOSED_LOSS_PROFIT_SHORT" NUMBER, 
	"CLOSED_TRADES_HOLDING_TIME_SHORT" NUMBER, 
	"CLOSED_WIN_TRADES_SHORT" NUMBER, 
	"CLOSED_LOSS_TRADES_SHORT" NUMBER, 
	"CLOSED_WIN_RATIO_SHORT" NUMBER, 
	"CLOSED_R_PERCENT_SHORT" NUMBER, 
	"CLOSED_R_MULTIPLE_SHORT" NUMBER, 
	"CLOSED_WIN_R_MULTIPLE_SHORT" NUMBER, 
	"CLOSED_LOSS_R_MULTIPLE_SHORT" NUMBER, 
	"CLOSED_WIN_MAX_SHORT" NUMBER, 
	"CLOSED_LOSS_MAX_SHORT" NUMBER, 
	"CLOSED_WIN_AVG_SHORT" NUMBER, 
	"CLOSED_LOSS_AVG_SHORT" NUMBER, 
	"CLOSED_EV" NUMBER, 
	"CLOSED_EV_LONG" NUMBER, 
	"CLOSED_EV_SHORT" NUMBER, 
	"CLOSED_EXPECTATION" NUMBER, 
	"CLOSED_EXPECTATION_LONG" NUMBER, 
	"CLOSED_EXPECTATION_SHORT" NUMBER, 
	"CLOSED_PROFIT_FACTOR" NUMBER, 
	"CLOSED_PROFIT_FACTOR_LONG" NUMBER, 
	"CLOSED_PROFIT_FACTOR_SHORT" NUMBER, 
	"WIN_STREAK_TRADES" NUMBER, 
	"LOSS_STREAK_TRADES" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table D_TRADING_CALENDAR
--------------------------------------------------------

  CREATE TABLE "ADMIN"."D_TRADING_CALENDAR" 
   (	"CALENDAR_DAY" VARCHAR2(100 BYTE), 
	"CALENDAR_MONTH_NAME" VARCHAR2(100 BYTE), 
	"CALENDAR_YEAR_ID" NUMBER, 
	"CALENDAR_MONTH_ID" VARCHAR2(100 BYTE), 
	"CALENDAR_DAY_NAME" VARCHAR2(100 BYTE), 
	"CALENDAR_WEEK_ID" VARCHAR2(100 BYTE), 
	"CALENDAR_WEEK_STATUS" VARCHAR2(100 BYTE), 
	"CALENDAR_MONTH_STATUS" VARCHAR2(10 BYTE), 
	"PREV_CALENDAR_DAY" VARCHAR2(100 BYTE), 
	"NEXT_CALENDAR_DAY" VARCHAR2(100 BYTE), 
	"PREV_CALENDAR_WEEK" VARCHAR2(100 BYTE), 
	"NEXT_CALENDAR_WEEK" VARCHAR2(100 BYTE), 
	"PREV_CALENDAR_MONTH" VARCHAR2(100 BYTE), 
	"NEXT_CALENDAR_MONTH" VARCHAR2(100 BYTE), 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"REPORTING_YEAR_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MKT_DATA
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MKT_DATA" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"OPEN" NUMBER, 
	"CLOSE" NUMBER, 
	"HIGH" NUMBER, 
	"LOW" NUMBER, 
	"VOLUME" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"CALENDAR_STATUS" VARCHAR2(100 BYTE), 
	"RSI" NUMBER, 
	"MFI" NUMBER, 
	"ATR" NUMBER, 
	"SAR" NUMBER, 
	"BBHIGH" NUMBER, 
	"BBLOW" NUMBER, 
	"CLOSE12" NUMBER, 
	"CLOSE30" NUMBER, 
	"CLOSE50" NUMBER, 
	"CLOSE200" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_DATA
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_DATA" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"DAY_WEEK_ID" NUMBER, 
	"DAY_MONTH_ID" VARCHAR2(8 BYTE), 
	"WEEK_ID" VARCHAR2(100 BYTE), 
	"MONTH_ID" VARCHAR2(100 BYTE), 
	"DAY_PREV_GAP_ATR" NUMBER, 
	"WEEK_PREV_GAP_ATR" NUMBER, 
	"MONTH_PREV_GAP_ATR" NUMBER, 
	"WEEK_INTERVAL_TR_RATIO" NUMBER, 
	"WEEK_INTERVAL_TICK_TR_RATIO" NUMBER, 
	"MONTH_INTERVAL_TR_RATIO" NUMBER, 
	"MONTH_INTERVAL_TICK_TR_RATIO" NUMBER, 
	"DAY_SIDE_START_TREND_GAP_ATR" NUMBER, 
	"DAY_SIDE_END_TREND_GAP_ATR" NUMBER, 
	"DAY_TREND_TYPE" NUMBER, 
	"DAY_TREND_START_TREND_GAP_ATR" NUMBER, 
	"DAY_TREND_END_TREND_GAP_ATR" NUMBER, 
	"WEEK_SIDE_START_TREND_GAP_ATR" NUMBER, 
	"WEEK_SIDE_END_TREND_GAP_ATR" NUMBER, 
	"WEEK_TREND_TYPE" NUMBER, 
	"WEEK_TREND_START_TREND_GAP_ATR" NUMBER, 
	"WEEK_TREND_END_TREND_GAP_ATR" NUMBER, 
	"DAY_LOW_SR_VALUE" NUMBER, 
	"DAY_LOW_SR_GAP" NUMBER, 
	"DAY_LOW_SR_REJECT" NUMBER, 
	"DAY_WEEK_LOW_SR_VALUE" NUMBER, 
	"DAY_WEEK_LOW_SR_GAP" NUMBER, 
	"DAY_WEEK_LOW_SR_REJECT" NUMBER, 
	"DAY_MONTH_LOW_SR_VALUE" NUMBER, 
	"DAY_MONTH_LOW_SR_GAP" NUMBER, 
	"DAY_MONTH_LOW_SR_REJECT" NUMBER, 
	"WEEK_LOW_SR_VALUE" NUMBER, 
	"WEEK_LOW_SR_GAP" NUMBER, 
	"WEEK_LOW_SR_REJECT" NUMBER, 
	"WEEK_MONTH_LOW_SR_VALUE" NUMBER, 
	"WEEK_MONTH_LOW_SR_GAP" NUMBER, 
	"WEEK_MONTH_LOW_SR_REJECT" NUMBER, 
	"MONTH_LOW_SR_VALUE" NUMBER, 
	"MONTH_LOW_SR_GAP" NUMBER, 
	"MONTH_LOW_SR_REJECT" NUMBER, 
	"DAY_HIGH_SR_VALUE" NUMBER, 
	"DAY_HIGH_SR_GAP" NUMBER, 
	"DAY_HIGH_SR_REJECT" NUMBER, 
	"DAY_WEEK_HIGH_SR_VALUE" NUMBER, 
	"DAY_WEEK_HIGH_SR_GAP" NUMBER, 
	"DAY_WEEK_HIGH_SR_REJECT" NUMBER, 
	"DAY_MONTH_HIGH_SR_VALUE" NUMBER, 
	"DAY_MONTH_HIGH_SR_GAP" NUMBER, 
	"DAY_MONTH_HIGH_SR_REJECT" NUMBER, 
	"WEEK_HIGH_SR_VALUE" NUMBER, 
	"WEEK_HIGH_SR_GAP" NUMBER, 
	"WEEK_HIGH_SR_REJECT" NUMBER, 
	"WEEK_MONTH_HIGH_SR_VALUE" NUMBER, 
	"WEEK_MONTH_HIGH_SR_GAP" NUMBER, 
	"WEEK_MONTH_HIGH_SR_REJECT" NUMBER, 
	"MONTH_HIGH_SR_VALUE" NUMBER, 
	"MONTH_HIGH_SR_GAP" NUMBER, 
	"MONTH_HIGH_SR_REJECT" NUMBER, 
	"NO_SR_LEVELS" NUMBER, 
	"DAY_EMA_TREND_POSITION" NUMBER, 
	"DAY_SLOPE_EMA12" NUMBER, 
	"DAY_SLOPE_EMA30" NUMBER, 
	"DAY_SLOPE_EMA50" NUMBER, 
	"DAY_SLOPE_EMA200" NUMBER, 
	"DAY_PROJ_INTER_CLOSE12_CLOSE30" NUMBER, 
	"DAY_PROJ_INTER_CLOSE30_CLOSE50" NUMBER, 
	"DAY_PROJ_INTER_CLOSE50_CLOSE200" NUMBER, 
	"DAY_CLOSE12_CLOSE30_T1_STATE" NUMBER, 
	"DAY_CLOSE12_CLOSE30_T1_STATE_TICKS" NUMBER, 
	"DAY_CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_CLOSE12_CLOSE30_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_CLOSE12_CLOSE30_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_CLOSE30_CLOSE50_T1_STATE" NUMBER, 
	"DAY_CLOSE30_CLOSE50_T1_STATE_TICKS" NUMBER, 
	"DAY_CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_CLOSE30_CLOSE50_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_CLOSE30_CLOSE50_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_CLOSE50_CLOSE200_T1_STATE" NUMBER, 
	"DAY_CLOSE50_CLOSE200_T1_STATE_TICKS" NUMBER, 
	"DAY_CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_CLOSE50_CLOSE200_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_CLOSE50_CLOSE200_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_EMA12_T1_STATE" NUMBER, 
	"DAY_EMA12_T1_STATE_TICKS" NUMBER, 
	"DAY_EMA12_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_EMA12_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_EMA12_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_EMA30_T1_STATE" NUMBER, 
	"DAY_EMA30_T1_STATE_TICKS" NUMBER, 
	"DAY_EMA30_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_EMA30_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_EMA30_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_EMA50_T1_STATE" NUMBER, 
	"DAY_EMA50_T1_STATE_TICKS" NUMBER, 
	"DAY_EMA50_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_EMA50_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_EMA50_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_EMA200_T1_STATE" NUMBER, 
	"DAY_EMA200_T1_STATE_TICKS" NUMBER, 
	"DAY_EMA200_STATE_PEAK_GAP_ATR" NUMBER, 
	"DAY_EMA200_STATE_HIGH_GAP_ATR" NUMBER, 
	"DAY_EMA200_STATE_LOW_GAP_ATR" NUMBER, 
	"DAY_EMA12_GAP_ATR" NUMBER, 
	"DAY_EMA30_GAP_ATR" NUMBER, 
	"DAY_EMA50_GAP_ATR" NUMBER, 
	"DAY_EMA200_GAP_ATR" NUMBER, 
	"DAY_EMA_12_30_GAP_ATR" NUMBER, 
	"DAY_EMA_30_50_GAP_ATR" NUMBER, 
	"DAY_EMA_50_200_GAP_ATR" NUMBER, 
	"DAY_EMA12_REJECT" NUMBER, 
	"DAY_EMA30_REJECT" NUMBER, 
	"DAY_EMA50_REJECT" NUMBER, 
	"DAY_EMA200_REJECT" NUMBER, 
	"WEEK_EMA12_REJECT" NUMBER, 
	"WEEK_EMA30_REJECT" NUMBER, 
	"WEEK_EMA50_REJECT" NUMBER, 
	"WEEK_EMA200_REJECT" NUMBER, 
	"MONTH_EMA12_REJECT" NUMBER, 
	"MONTH_EMA30_REJECT" NUMBER, 
	"MONTH_EMA50_REJECT" NUMBER, 
	"MONTH_EMA200_REJECT" NUMBER, 
	"DAY_RSI" NUMBER, 
	"DAY_MFI" NUMBER, 
	"DAY_SAR" NUMBER, 
	"PREV_DAY_SAR" NUMBER, 
	"PREV_2_DAY_SAR" NUMBER, 
	"BUY_TP_1_SL_1" NUMBER, 
	"BUY_TP_2_SL_1" NUMBER, 
	"BUY_TP_3_SL_1" NUMBER, 
	"BUY_TP_4_SL_1" NUMBER, 
	"BUY_TP_5_SL_1" NUMBER, 
	"BUY_TP_6_SL_1" NUMBER, 
	"BUY_TP_7_SL_1" NUMBER, 
	"BUY_TP_8_SL_1" NUMBER, 
	"BUY_TP_9_SL_1" NUMBER, 
	"BUY_TP_10_SL_1" NUMBER, 
	"BUY_TP_11_SL_1" NUMBER, 
	"BUY_TP_12_SL_1" NUMBER, 
	"BUY_TP_1_SL_2" NUMBER, 
	"BUY_TP_2_SL_2" NUMBER, 
	"BUY_TP_3_SL_2" NUMBER, 
	"BUY_TP_4_SL_2" NUMBER, 
	"BUY_TP_5_SL_2" NUMBER, 
	"BUY_TP_6_SL_2" NUMBER, 
	"BUY_TP_7_SL_2" NUMBER, 
	"BUY_TP_8_SL_2" NUMBER, 
	"BUY_TP_9_SL_2" NUMBER, 
	"BUY_TP_10_SL_2" NUMBER, 
	"BUY_TP_11_SL_2" NUMBER, 
	"BUY_TP_12_SL_2" NUMBER, 
	"BUY_TP_1_SL_3" NUMBER, 
	"BUY_TP_2_SL_3" NUMBER, 
	"BUY_TP_3_SL_3" NUMBER, 
	"BUY_TP_4_SL_3" NUMBER, 
	"BUY_TP_5_SL_3" NUMBER, 
	"BUY_TP_6_SL_3" NUMBER, 
	"BUY_TP_7_SL_3" NUMBER, 
	"BUY_TP_8_SL_3" NUMBER, 
	"BUY_TP_9_SL_3" NUMBER, 
	"BUY_TP_10_SL_3" NUMBER, 
	"BUY_TP_11_SL_3" NUMBER, 
	"BUY_TP_12_SL_3" NUMBER, 
	"BUY_TP_1_SL_4" NUMBER, 
	"BUY_TP_2_SL_4" NUMBER, 
	"BUY_TP_3_SL_4" NUMBER, 
	"BUY_TP_4_SL_4" NUMBER, 
	"BUY_TP_5_SL_4" NUMBER, 
	"BUY_TP_6_SL_4" NUMBER, 
	"BUY_TP_7_SL_4" NUMBER, 
	"BUY_TP_8_SL_4" NUMBER, 
	"BUY_TP_9_SL_4" NUMBER, 
	"BUY_TP_10_SL_4" NUMBER, 
	"BUY_TP_11_SL_4" NUMBER, 
	"BUY_TP_12_SL_4" NUMBER, 
	"BUY_TP_1_SL_5" NUMBER, 
	"BUY_TP_2_SL_5" NUMBER, 
	"BUY_TP_3_SL_5" NUMBER, 
	"BUY_TP_4_SL_5" NUMBER, 
	"BUY_TP_5_SL_5" NUMBER, 
	"BUY_TP_6_SL_5" NUMBER, 
	"BUY_TP_7_SL_5" NUMBER, 
	"BUY_TP_8_SL_5" NUMBER, 
	"BUY_TP_9_SL_5" NUMBER, 
	"BUY_TP_10_SL_5" NUMBER, 
	"BUY_TP_11_SL_5" NUMBER, 
	"BUY_TP_12_SL_5" NUMBER, 
	"BUY_TP_1_SL_6" NUMBER, 
	"BUY_TP_2_SL_6" NUMBER, 
	"BUY_TP_3_SL_6" NUMBER, 
	"BUY_TP_4_SL_6" NUMBER, 
	"BUY_TP_5_SL_6" NUMBER, 
	"BUY_TP_6_SL_6" NUMBER, 
	"BUY_TP_7_SL_6" NUMBER, 
	"BUY_TP_8_SL_6" NUMBER, 
	"BUY_TP_9_SL_6" NUMBER, 
	"BUY_TP_10_SL_6" NUMBER, 
	"BUY_TP_11_SL_6" NUMBER, 
	"BUY_TP_12_SL_6" NUMBER, 
	"BUY_TP_1_SL_7" NUMBER, 
	"BUY_TP_2_SL_7" NUMBER, 
	"BUY_TP_3_SL_7" NUMBER, 
	"BUY_TP_4_SL_7" NUMBER, 
	"BUY_TP_5_SL_7" NUMBER, 
	"BUY_TP_6_SL_7" NUMBER, 
	"BUY_TP_7_SL_7" NUMBER, 
	"BUY_TP_8_SL_7" NUMBER, 
	"BUY_TP_9_SL_7" NUMBER, 
	"BUY_TP_10_SL_7" NUMBER, 
	"BUY_TP_11_SL_7" NUMBER, 
	"BUY_TP_12_SL_7" NUMBER, 
	"BUY_TP_1_SL_8" NUMBER, 
	"BUY_TP_2_SL_8" NUMBER, 
	"BUY_TP_3_SL_8" NUMBER, 
	"BUY_TP_4_SL_8" NUMBER, 
	"BUY_TP_5_SL_8" NUMBER, 
	"BUY_TP_6_SL_8" NUMBER, 
	"BUY_TP_7_SL_8" NUMBER, 
	"BUY_TP_8_SL_8" NUMBER, 
	"BUY_TP_9_SL_8" NUMBER, 
	"BUY_TP_10_SL_8" NUMBER, 
	"BUY_TP_11_SL_8" NUMBER, 
	"BUY_TP_12_SL_8" NUMBER, 
	"BUY_TP_1_SL_9" NUMBER, 
	"BUY_TP_2_SL_9" NUMBER, 
	"BUY_TP_3_SL_9" NUMBER, 
	"BUY_TP_4_SL_9" NUMBER, 
	"BUY_TP_5_SL_9" NUMBER, 
	"BUY_TP_6_SL_9" NUMBER, 
	"BUY_TP_7_SL_9" NUMBER, 
	"BUY_TP_8_SL_9" NUMBER, 
	"BUY_TP_9_SL_9" NUMBER, 
	"BUY_TP_10_SL_9" NUMBER, 
	"BUY_TP_11_SL_9" NUMBER, 
	"BUY_TP_12_SL_9" NUMBER, 
	"BUY_TP_1_SL_10" NUMBER, 
	"BUY_TP_2_SL_10" NUMBER, 
	"BUY_TP_3_SL_10" NUMBER, 
	"BUY_TP_4_SL_10" NUMBER, 
	"BUY_TP_5_SL_10" NUMBER, 
	"BUY_TP_6_SL_10" NUMBER, 
	"BUY_TP_7_SL_10" NUMBER, 
	"BUY_TP_8_SL_10" NUMBER, 
	"BUY_TP_9_SL_10" NUMBER, 
	"BUY_TP_10_SL_10" NUMBER, 
	"BUY_TP_11_SL_10" NUMBER, 
	"BUY_TP_12_SL_10" NUMBER, 
	"BUY_TP_1_SL_11" NUMBER, 
	"BUY_TP_2_SL_11" NUMBER, 
	"BUY_TP_3_SL_11" NUMBER, 
	"BUY_TP_4_SL_11" NUMBER, 
	"BUY_TP_5_SL_11" NUMBER, 
	"BUY_TP_6_SL_11" NUMBER, 
	"BUY_TP_7_SL_11" NUMBER, 
	"BUY_TP_8_SL_11" NUMBER, 
	"BUY_TP_9_SL_11" NUMBER, 
	"BUY_TP_10_SL_11" NUMBER, 
	"BUY_TP_11_SL_11" NUMBER, 
	"BUY_TP_12_SL_11" NUMBER, 
	"BUY_TP_1_SL_12" NUMBER, 
	"BUY_TP_2_SL_12" NUMBER, 
	"BUY_TP_3_SL_12" NUMBER, 
	"BUY_TP_4_SL_12" NUMBER, 
	"BUY_TP_5_SL_12" NUMBER, 
	"BUY_TP_6_SL_12" NUMBER, 
	"BUY_TP_7_SL_12" NUMBER, 
	"BUY_TP_8_SL_12" NUMBER, 
	"BUY_TP_9_SL_12" NUMBER, 
	"BUY_TP_10_SL_12" NUMBER, 
	"BUY_TP_11_SL_12" NUMBER, 
	"BUY_TP_12_SL_12" NUMBER, 
	"SELL_TP_1_SL_1" NUMBER, 
	"SELL_TP_2_SL_1" NUMBER, 
	"SELL_TP_3_SL_1" NUMBER, 
	"SELL_TP_4_SL_1" NUMBER, 
	"SELL_TP_5_SL_1" NUMBER, 
	"SELL_TP_6_SL_1" NUMBER, 
	"SELL_TP_7_SL_1" NUMBER, 
	"SELL_TP_8_SL_1" NUMBER, 
	"SELL_TP_9_SL_1" NUMBER, 
	"SELL_TP_10_SL_1" NUMBER, 
	"SELL_TP_11_SL_1" NUMBER, 
	"SELL_TP_12_SL_1" NUMBER, 
	"SELL_TP_1_SL_2" NUMBER, 
	"SELL_TP_2_SL_2" NUMBER, 
	"SELL_TP_3_SL_2" NUMBER, 
	"SELL_TP_4_SL_2" NUMBER, 
	"SELL_TP_5_SL_2" NUMBER, 
	"SELL_TP_6_SL_2" NUMBER, 
	"SELL_TP_7_SL_2" NUMBER, 
	"SELL_TP_8_SL_2" NUMBER, 
	"SELL_TP_9_SL_2" NUMBER, 
	"SELL_TP_10_SL_2" NUMBER, 
	"SELL_TP_11_SL_2" NUMBER, 
	"SELL_TP_12_SL_2" NUMBER, 
	"SELL_TP_1_SL_3" NUMBER, 
	"SELL_TP_2_SL_3" NUMBER, 
	"SELL_TP_3_SL_3" NUMBER, 
	"SELL_TP_4_SL_3" NUMBER, 
	"SELL_TP_5_SL_3" NUMBER, 
	"SELL_TP_6_SL_3" NUMBER, 
	"SELL_TP_7_SL_3" NUMBER, 
	"SELL_TP_8_SL_3" NUMBER, 
	"SELL_TP_9_SL_3" NUMBER, 
	"SELL_TP_10_SL_3" NUMBER, 
	"SELL_TP_11_SL_3" NUMBER, 
	"SELL_TP_12_SL_3" NUMBER, 
	"SELL_TP_1_SL_4" NUMBER, 
	"SELL_TP_2_SL_4" NUMBER, 
	"SELL_TP_3_SL_4" NUMBER, 
	"SELL_TP_4_SL_4" NUMBER, 
	"SELL_TP_5_SL_4" NUMBER, 
	"SELL_TP_6_SL_4" NUMBER, 
	"SELL_TP_7_SL_4" NUMBER, 
	"SELL_TP_8_SL_4" NUMBER, 
	"SELL_TP_9_SL_4" NUMBER, 
	"SELL_TP_10_SL_4" NUMBER, 
	"SELL_TP_11_SL_4" NUMBER, 
	"SELL_TP_12_SL_4" NUMBER, 
	"SELL_TP_1_SL_5" NUMBER, 
	"SELL_TP_2_SL_5" NUMBER, 
	"SELL_TP_3_SL_5" NUMBER, 
	"SELL_TP_4_SL_5" NUMBER, 
	"SELL_TP_5_SL_5" NUMBER, 
	"SELL_TP_6_SL_5" NUMBER, 
	"SELL_TP_7_SL_5" NUMBER, 
	"SELL_TP_8_SL_5" NUMBER, 
	"SELL_TP_9_SL_5" NUMBER, 
	"SELL_TP_10_SL_5" NUMBER, 
	"SELL_TP_11_SL_5" NUMBER, 
	"SELL_TP_12_SL_5" NUMBER, 
	"SELL_TP_1_SL_6" NUMBER, 
	"SELL_TP_2_SL_6" NUMBER, 
	"SELL_TP_3_SL_6" NUMBER, 
	"SELL_TP_4_SL_6" NUMBER, 
	"SELL_TP_5_SL_6" NUMBER, 
	"SELL_TP_6_SL_6" NUMBER, 
	"SELL_TP_7_SL_6" NUMBER, 
	"SELL_TP_8_SL_6" NUMBER, 
	"SELL_TP_9_SL_6" NUMBER, 
	"SELL_TP_10_SL_6" NUMBER, 
	"SELL_TP_11_SL_6" NUMBER, 
	"SELL_TP_12_SL_6" NUMBER, 
	"SELL_TP_1_SL_7" NUMBER, 
	"SELL_TP_2_SL_7" NUMBER, 
	"SELL_TP_3_SL_7" NUMBER, 
	"SELL_TP_4_SL_7" NUMBER, 
	"SELL_TP_5_SL_7" NUMBER, 
	"SELL_TP_6_SL_7" NUMBER, 
	"SELL_TP_7_SL_7" NUMBER, 
	"SELL_TP_8_SL_7" NUMBER, 
	"SELL_TP_9_SL_7" NUMBER, 
	"SELL_TP_10_SL_7" NUMBER, 
	"SELL_TP_11_SL_7" NUMBER, 
	"SELL_TP_12_SL_7" NUMBER, 
	"SELL_TP_1_SL_8" NUMBER, 
	"SELL_TP_2_SL_8" NUMBER, 
	"SELL_TP_3_SL_8" NUMBER, 
	"SELL_TP_4_SL_8" NUMBER, 
	"SELL_TP_5_SL_8" NUMBER, 
	"SELL_TP_6_SL_8" NUMBER, 
	"SELL_TP_7_SL_8" NUMBER, 
	"SELL_TP_8_SL_8" NUMBER, 
	"SELL_TP_9_SL_8" NUMBER, 
	"SELL_TP_10_SL_8" NUMBER, 
	"SELL_TP_11_SL_8" NUMBER, 
	"SELL_TP_12_SL_8" NUMBER, 
	"SELL_TP_1_SL_9" NUMBER, 
	"SELL_TP_2_SL_9" NUMBER, 
	"SELL_TP_3_SL_9" NUMBER, 
	"SELL_TP_4_SL_9" NUMBER, 
	"SELL_TP_5_SL_9" NUMBER, 
	"SELL_TP_6_SL_9" NUMBER, 
	"SELL_TP_7_SL_9" NUMBER, 
	"SELL_TP_8_SL_9" NUMBER, 
	"SELL_TP_9_SL_9" NUMBER, 
	"SELL_TP_10_SL_9" NUMBER, 
	"SELL_TP_11_SL_9" NUMBER, 
	"SELL_TP_12_SL_9" NUMBER, 
	"SELL_TP_1_SL_10" NUMBER, 
	"SELL_TP_2_SL_10" NUMBER, 
	"SELL_TP_3_SL_10" NUMBER, 
	"SELL_TP_4_SL_10" NUMBER, 
	"SELL_TP_5_SL_10" NUMBER, 
	"SELL_TP_6_SL_10" NUMBER, 
	"SELL_TP_7_SL_10" NUMBER, 
	"SELL_TP_8_SL_10" NUMBER, 
	"SELL_TP_9_SL_10" NUMBER, 
	"SELL_TP_10_SL_10" NUMBER, 
	"SELL_TP_11_SL_10" NUMBER, 
	"SELL_TP_12_SL_10" NUMBER, 
	"SELL_TP_1_SL_11" NUMBER, 
	"SELL_TP_2_SL_11" NUMBER, 
	"SELL_TP_3_SL_11" NUMBER, 
	"SELL_TP_4_SL_11" NUMBER, 
	"SELL_TP_5_SL_11" NUMBER, 
	"SELL_TP_6_SL_11" NUMBER, 
	"SELL_TP_7_SL_11" NUMBER, 
	"SELL_TP_8_SL_11" NUMBER, 
	"SELL_TP_9_SL_11" NUMBER, 
	"SELL_TP_10_SL_11" NUMBER, 
	"SELL_TP_11_SL_11" NUMBER, 
	"SELL_TP_12_SL_11" NUMBER, 
	"SELL_TP_1_SL_12" NUMBER, 
	"SELL_TP_2_SL_12" NUMBER, 
	"SELL_TP_3_SL_12" NUMBER, 
	"SELL_TP_4_SL_12" NUMBER, 
	"SELL_TP_5_SL_12" NUMBER, 
	"SELL_TP_6_SL_12" NUMBER, 
	"SELL_TP_7_SL_12" NUMBER, 
	"SELL_TP_8_SL_12" NUMBER, 
	"SELL_TP_9_SL_12" NUMBER, 
	"SELL_TP_10_SL_12" NUMBER, 
	"SELL_TP_11_SL_12" NUMBER, 
	"SELL_TP_12_SL_12" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_PREDICT
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_PREDICT" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"MODELING_LEVEL" VARCHAR2(100 BYTE), 
	"TRADE_SIGNAL" VARCHAR2(100 BYTE), 
	"TP" NUMBER, 
	"SL" NUMBER, 
	"PRED_VALUE" NUMBER, 
	"ACTUAL_VALUE" NUMBER, 
	"PROB_1" NUMBER, 
	"PROB_0" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"MODEL_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_SIGNALS
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_SIGNALS" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"TRADE_SIGNAL" VARCHAR2(100 BYTE), 
	"TP" NUMBER, 
	"SL" NUMBER, 
	"ENTRY_PRICE" NUMBER, 
	"CLOSE" NUMBER, 
	"ATR" NUMBER, 
	"TP_PRICE" NUMBER, 
	"SL_PRICE" NUMBER, 
	"MODEL_NAME" CHAR(7 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_SL_TP
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_SL_TP" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"CLOSE" NUMBER, 
	"ATR" NUMBER, 
	"BUY_TP_1_SL_1" NUMBER, 
	"BUY_TP_2_SL_1" NUMBER, 
	"BUY_TP_3_SL_1" NUMBER, 
	"BUY_TP_4_SL_1" NUMBER, 
	"BUY_TP_5_SL_1" NUMBER, 
	"BUY_TP_6_SL_1" NUMBER, 
	"BUY_TP_7_SL_1" NUMBER, 
	"BUY_TP_8_SL_1" NUMBER, 
	"BUY_TP_9_SL_1" NUMBER, 
	"BUY_TP_10_SL_1" NUMBER, 
	"BUY_TP_11_SL_1" NUMBER, 
	"BUY_TP_12_SL_1" NUMBER, 
	"BUY_TP_1_SL_2" NUMBER, 
	"BUY_TP_2_SL_2" NUMBER, 
	"BUY_TP_3_SL_2" NUMBER, 
	"BUY_TP_4_SL_2" NUMBER, 
	"BUY_TP_5_SL_2" NUMBER, 
	"BUY_TP_6_SL_2" NUMBER, 
	"BUY_TP_7_SL_2" NUMBER, 
	"BUY_TP_8_SL_2" NUMBER, 
	"BUY_TP_9_SL_2" NUMBER, 
	"BUY_TP_10_SL_2" NUMBER, 
	"BUY_TP_11_SL_2" NUMBER, 
	"BUY_TP_12_SL_2" NUMBER, 
	"BUY_TP_1_SL_3" NUMBER, 
	"BUY_TP_2_SL_3" NUMBER, 
	"BUY_TP_3_SL_3" NUMBER, 
	"BUY_TP_4_SL_3" NUMBER, 
	"BUY_TP_5_SL_3" NUMBER, 
	"BUY_TP_6_SL_3" NUMBER, 
	"BUY_TP_7_SL_3" NUMBER, 
	"BUY_TP_8_SL_3" NUMBER, 
	"BUY_TP_9_SL_3" NUMBER, 
	"BUY_TP_10_SL_3" NUMBER, 
	"BUY_TP_11_SL_3" NUMBER, 
	"BUY_TP_12_SL_3" NUMBER, 
	"BUY_TP_1_SL_4" NUMBER, 
	"BUY_TP_2_SL_4" NUMBER, 
	"BUY_TP_3_SL_4" NUMBER, 
	"BUY_TP_4_SL_4" NUMBER, 
	"BUY_TP_5_SL_4" NUMBER, 
	"BUY_TP_6_SL_4" NUMBER, 
	"BUY_TP_7_SL_4" NUMBER, 
	"BUY_TP_8_SL_4" NUMBER, 
	"BUY_TP_9_SL_4" NUMBER, 
	"BUY_TP_10_SL_4" NUMBER, 
	"BUY_TP_11_SL_4" NUMBER, 
	"BUY_TP_12_SL_4" NUMBER, 
	"BUY_TP_1_SL_5" NUMBER, 
	"BUY_TP_2_SL_5" NUMBER, 
	"BUY_TP_3_SL_5" NUMBER, 
	"BUY_TP_4_SL_5" NUMBER, 
	"BUY_TP_5_SL_5" NUMBER, 
	"BUY_TP_6_SL_5" NUMBER, 
	"BUY_TP_7_SL_5" NUMBER, 
	"BUY_TP_8_SL_5" NUMBER, 
	"BUY_TP_9_SL_5" NUMBER, 
	"BUY_TP_10_SL_5" NUMBER, 
	"BUY_TP_11_SL_5" NUMBER, 
	"BUY_TP_12_SL_5" NUMBER, 
	"BUY_TP_1_SL_6" NUMBER, 
	"BUY_TP_2_SL_6" NUMBER, 
	"BUY_TP_3_SL_6" NUMBER, 
	"BUY_TP_4_SL_6" NUMBER, 
	"BUY_TP_5_SL_6" NUMBER, 
	"BUY_TP_6_SL_6" NUMBER, 
	"BUY_TP_7_SL_6" NUMBER, 
	"BUY_TP_8_SL_6" NUMBER, 
	"BUY_TP_9_SL_6" NUMBER, 
	"BUY_TP_10_SL_6" NUMBER, 
	"BUY_TP_11_SL_6" NUMBER, 
	"BUY_TP_12_SL_6" NUMBER, 
	"BUY_TP_1_SL_7" NUMBER, 
	"BUY_TP_2_SL_7" NUMBER, 
	"BUY_TP_3_SL_7" NUMBER, 
	"BUY_TP_4_SL_7" NUMBER, 
	"BUY_TP_5_SL_7" NUMBER, 
	"BUY_TP_6_SL_7" NUMBER, 
	"BUY_TP_7_SL_7" NUMBER, 
	"BUY_TP_8_SL_7" NUMBER, 
	"BUY_TP_9_SL_7" NUMBER, 
	"BUY_TP_10_SL_7" NUMBER, 
	"BUY_TP_11_SL_7" NUMBER, 
	"BUY_TP_12_SL_7" NUMBER, 
	"BUY_TP_1_SL_8" NUMBER, 
	"BUY_TP_2_SL_8" NUMBER, 
	"BUY_TP_3_SL_8" NUMBER, 
	"BUY_TP_4_SL_8" NUMBER, 
	"BUY_TP_5_SL_8" NUMBER, 
	"BUY_TP_6_SL_8" NUMBER, 
	"BUY_TP_7_SL_8" NUMBER, 
	"BUY_TP_8_SL_8" NUMBER, 
	"BUY_TP_9_SL_8" NUMBER, 
	"BUY_TP_10_SL_8" NUMBER, 
	"BUY_TP_11_SL_8" NUMBER, 
	"BUY_TP_12_SL_8" NUMBER, 
	"BUY_TP_1_SL_9" NUMBER, 
	"BUY_TP_2_SL_9" NUMBER, 
	"BUY_TP_3_SL_9" NUMBER, 
	"BUY_TP_4_SL_9" NUMBER, 
	"BUY_TP_5_SL_9" NUMBER, 
	"BUY_TP_6_SL_9" NUMBER, 
	"BUY_TP_7_SL_9" NUMBER, 
	"BUY_TP_8_SL_9" NUMBER, 
	"BUY_TP_9_SL_9" NUMBER, 
	"BUY_TP_10_SL_9" NUMBER, 
	"BUY_TP_11_SL_9" NUMBER, 
	"BUY_TP_12_SL_9" NUMBER, 
	"BUY_TP_1_SL_10" NUMBER, 
	"BUY_TP_2_SL_10" NUMBER, 
	"BUY_TP_3_SL_10" NUMBER, 
	"BUY_TP_4_SL_10" NUMBER, 
	"BUY_TP_5_SL_10" NUMBER, 
	"BUY_TP_6_SL_10" NUMBER, 
	"BUY_TP_7_SL_10" NUMBER, 
	"BUY_TP_8_SL_10" NUMBER, 
	"BUY_TP_9_SL_10" NUMBER, 
	"BUY_TP_10_SL_10" NUMBER, 
	"BUY_TP_11_SL_10" NUMBER, 
	"BUY_TP_12_SL_10" NUMBER, 
	"BUY_TP_1_SL_11" NUMBER, 
	"BUY_TP_2_SL_11" NUMBER, 
	"BUY_TP_3_SL_11" NUMBER, 
	"BUY_TP_4_SL_11" NUMBER, 
	"BUY_TP_5_SL_11" NUMBER, 
	"BUY_TP_6_SL_11" NUMBER, 
	"BUY_TP_7_SL_11" NUMBER, 
	"BUY_TP_8_SL_11" NUMBER, 
	"BUY_TP_9_SL_11" NUMBER, 
	"BUY_TP_10_SL_11" NUMBER, 
	"BUY_TP_11_SL_11" NUMBER, 
	"BUY_TP_12_SL_11" NUMBER, 
	"BUY_TP_1_SL_12" NUMBER, 
	"BUY_TP_2_SL_12" NUMBER, 
	"BUY_TP_3_SL_12" NUMBER, 
	"BUY_TP_4_SL_12" NUMBER, 
	"BUY_TP_5_SL_12" NUMBER, 
	"BUY_TP_6_SL_12" NUMBER, 
	"BUY_TP_7_SL_12" NUMBER, 
	"BUY_TP_8_SL_12" NUMBER, 
	"BUY_TP_9_SL_12" NUMBER, 
	"BUY_TP_10_SL_12" NUMBER, 
	"BUY_TP_11_SL_12" NUMBER, 
	"BUY_TP_12_SL_12" NUMBER, 
	"SELL_TP_1_SL_1" NUMBER, 
	"SELL_TP_2_SL_1" NUMBER, 
	"SELL_TP_3_SL_1" NUMBER, 
	"SELL_TP_4_SL_1" NUMBER, 
	"SELL_TP_5_SL_1" NUMBER, 
	"SELL_TP_6_SL_1" NUMBER, 
	"SELL_TP_7_SL_1" NUMBER, 
	"SELL_TP_8_SL_1" NUMBER, 
	"SELL_TP_9_SL_1" NUMBER, 
	"SELL_TP_10_SL_1" NUMBER, 
	"SELL_TP_11_SL_1" NUMBER, 
	"SELL_TP_12_SL_1" NUMBER, 
	"SELL_TP_1_SL_2" NUMBER, 
	"SELL_TP_2_SL_2" NUMBER, 
	"SELL_TP_3_SL_2" NUMBER, 
	"SELL_TP_4_SL_2" NUMBER, 
	"SELL_TP_5_SL_2" NUMBER, 
	"SELL_TP_6_SL_2" NUMBER, 
	"SELL_TP_7_SL_2" NUMBER, 
	"SELL_TP_8_SL_2" NUMBER, 
	"SELL_TP_9_SL_2" NUMBER, 
	"SELL_TP_10_SL_2" NUMBER, 
	"SELL_TP_11_SL_2" NUMBER, 
	"SELL_TP_12_SL_2" NUMBER, 
	"SELL_TP_1_SL_3" NUMBER, 
	"SELL_TP_2_SL_3" NUMBER, 
	"SELL_TP_3_SL_3" NUMBER, 
	"SELL_TP_4_SL_3" NUMBER, 
	"SELL_TP_5_SL_3" NUMBER, 
	"SELL_TP_6_SL_3" NUMBER, 
	"SELL_TP_7_SL_3" NUMBER, 
	"SELL_TP_8_SL_3" NUMBER, 
	"SELL_TP_9_SL_3" NUMBER, 
	"SELL_TP_10_SL_3" NUMBER, 
	"SELL_TP_11_SL_3" NUMBER, 
	"SELL_TP_12_SL_3" NUMBER, 
	"SELL_TP_1_SL_4" NUMBER, 
	"SELL_TP_2_SL_4" NUMBER, 
	"SELL_TP_3_SL_4" NUMBER, 
	"SELL_TP_4_SL_4" NUMBER, 
	"SELL_TP_5_SL_4" NUMBER, 
	"SELL_TP_6_SL_4" NUMBER, 
	"SELL_TP_7_SL_4" NUMBER, 
	"SELL_TP_8_SL_4" NUMBER, 
	"SELL_TP_9_SL_4" NUMBER, 
	"SELL_TP_10_SL_4" NUMBER, 
	"SELL_TP_11_SL_4" NUMBER, 
	"SELL_TP_12_SL_4" NUMBER, 
	"SELL_TP_1_SL_5" NUMBER, 
	"SELL_TP_2_SL_5" NUMBER, 
	"SELL_TP_3_SL_5" NUMBER, 
	"SELL_TP_4_SL_5" NUMBER, 
	"SELL_TP_5_SL_5" NUMBER, 
	"SELL_TP_6_SL_5" NUMBER, 
	"SELL_TP_7_SL_5" NUMBER, 
	"SELL_TP_8_SL_5" NUMBER, 
	"SELL_TP_9_SL_5" NUMBER, 
	"SELL_TP_10_SL_5" NUMBER, 
	"SELL_TP_11_SL_5" NUMBER, 
	"SELL_TP_12_SL_5" NUMBER, 
	"SELL_TP_1_SL_6" NUMBER, 
	"SELL_TP_2_SL_6" NUMBER, 
	"SELL_TP_3_SL_6" NUMBER, 
	"SELL_TP_4_SL_6" NUMBER, 
	"SELL_TP_5_SL_6" NUMBER, 
	"SELL_TP_6_SL_6" NUMBER, 
	"SELL_TP_7_SL_6" NUMBER, 
	"SELL_TP_8_SL_6" NUMBER, 
	"SELL_TP_9_SL_6" NUMBER, 
	"SELL_TP_10_SL_6" NUMBER, 
	"SELL_TP_11_SL_6" NUMBER, 
	"SELL_TP_12_SL_6" NUMBER, 
	"SELL_TP_1_SL_7" NUMBER, 
	"SELL_TP_2_SL_7" NUMBER, 
	"SELL_TP_3_SL_7" NUMBER, 
	"SELL_TP_4_SL_7" NUMBER, 
	"SELL_TP_5_SL_7" NUMBER, 
	"SELL_TP_6_SL_7" NUMBER, 
	"SELL_TP_7_SL_7" NUMBER, 
	"SELL_TP_8_SL_7" NUMBER, 
	"SELL_TP_9_SL_7" NUMBER, 
	"SELL_TP_10_SL_7" NUMBER, 
	"SELL_TP_11_SL_7" NUMBER, 
	"SELL_TP_12_SL_7" NUMBER, 
	"SELL_TP_1_SL_8" NUMBER, 
	"SELL_TP_2_SL_8" NUMBER, 
	"SELL_TP_3_SL_8" NUMBER, 
	"SELL_TP_4_SL_8" NUMBER, 
	"SELL_TP_5_SL_8" NUMBER, 
	"SELL_TP_6_SL_8" NUMBER, 
	"SELL_TP_7_SL_8" NUMBER, 
	"SELL_TP_8_SL_8" NUMBER, 
	"SELL_TP_9_SL_8" NUMBER, 
	"SELL_TP_10_SL_8" NUMBER, 
	"SELL_TP_11_SL_8" NUMBER, 
	"SELL_TP_12_SL_8" NUMBER, 
	"SELL_TP_1_SL_9" NUMBER, 
	"SELL_TP_2_SL_9" NUMBER, 
	"SELL_TP_3_SL_9" NUMBER, 
	"SELL_TP_4_SL_9" NUMBER, 
	"SELL_TP_5_SL_9" NUMBER, 
	"SELL_TP_6_SL_9" NUMBER, 
	"SELL_TP_7_SL_9" NUMBER, 
	"SELL_TP_8_SL_9" NUMBER, 
	"SELL_TP_9_SL_9" NUMBER, 
	"SELL_TP_10_SL_9" NUMBER, 
	"SELL_TP_11_SL_9" NUMBER, 
	"SELL_TP_12_SL_9" NUMBER, 
	"SELL_TP_1_SL_10" NUMBER, 
	"SELL_TP_2_SL_10" NUMBER, 
	"SELL_TP_3_SL_10" NUMBER, 
	"SELL_TP_4_SL_10" NUMBER, 
	"SELL_TP_5_SL_10" NUMBER, 
	"SELL_TP_6_SL_10" NUMBER, 
	"SELL_TP_7_SL_10" NUMBER, 
	"SELL_TP_8_SL_10" NUMBER, 
	"SELL_TP_9_SL_10" NUMBER, 
	"SELL_TP_10_SL_10" NUMBER, 
	"SELL_TP_11_SL_10" NUMBER, 
	"SELL_TP_12_SL_10" NUMBER, 
	"SELL_TP_1_SL_11" NUMBER, 
	"SELL_TP_2_SL_11" NUMBER, 
	"SELL_TP_3_SL_11" NUMBER, 
	"SELL_TP_4_SL_11" NUMBER, 
	"SELL_TP_5_SL_11" NUMBER, 
	"SELL_TP_6_SL_11" NUMBER, 
	"SELL_TP_7_SL_11" NUMBER, 
	"SELL_TP_8_SL_11" NUMBER, 
	"SELL_TP_9_SL_11" NUMBER, 
	"SELL_TP_10_SL_11" NUMBER, 
	"SELL_TP_11_SL_11" NUMBER, 
	"SELL_TP_12_SL_11" NUMBER, 
	"SELL_TP_1_SL_12" NUMBER, 
	"SELL_TP_2_SL_12" NUMBER, 
	"SELL_TP_3_SL_12" NUMBER, 
	"SELL_TP_4_SL_12" NUMBER, 
	"SELL_TP_5_SL_12" NUMBER, 
	"SELL_TP_6_SL_12" NUMBER, 
	"SELL_TP_7_SL_12" NUMBER, 
	"SELL_TP_8_SL_12" NUMBER, 
	"SELL_TP_9_SL_12" NUMBER, 
	"SELL_TP_10_SL_12" NUMBER, 
	"SELL_TP_11_SL_12" NUMBER, 
	"SELL_TP_12_SL_12" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_TRADE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_TRADE" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"TRADE_TYPE" VARCHAR2(100 BYTE), 
	"CREATE_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"ENTER_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"EXIT_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"ENTER_MODEL_PRICE_THRESHOLD" NUMBER, 
	"ENTER_MODEL_PRICE" NUMBER, 
	"EXIT_MODEL_PRICE" NUMBER, 
	"EXIT_TYPE" VARCHAR2(100 BYTE), 
	"INITIAL_SL" NUMBER, 
	"INITIAL_TP" NUMBER, 
	"TRAILING_SL" NUMBER, 
	"TRAILING_TP" NUMBER, 
	"MODEL_NAME" VARCHAR2(100 BYTE), 
	"KELLY" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table O_MODEL_TRADE_CHANGE
--------------------------------------------------------

  CREATE TABLE "ADMIN"."O_MODEL_TRADE_CHANGE" 
   (	"MODEL_NAME" VARCHAR2(100 BYTE), 
	"TRADE_CHANGE_TIMESTAMP" VARCHAR2(100 BYTE), 
	"SYMBOL" VARCHAR2(100 BYTE), 
	"TRADE_TYPE" VARCHAR2(100 BYTE), 
	"CREATE_MODEL_TIMESTAMP" VARCHAR2(100 BYTE), 
	"CHANGE_TYPE" VARCHAR2(100 BYTE), 
	"ORIGINAL_VALUE" NUMBER, 
	"CHANGE_VALUE" NUMBER, 
	"CHANGE_REF_MODEL_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table RUN_LOG
--------------------------------------------------------

  CREATE TABLE "ADMIN"."RUN_LOG" 
   (	"RUN_DATE" VARCHAR2(100 BYTE), 
	"RUN_GROUP_NAME" VARCHAR2(100 BYTE), 
	"STEP_NAME" VARCHAR2(100 BYTE), 
	"STEP_TIME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEST
--------------------------------------------------------

  CREATE TABLE "ADMIN"."TEST" 
   (	"SYMBOL" VARCHAR2(100 BYTE), 
	"INTERVAL" VARCHAR2(100 BYTE), 
	"TICK_TIMESTAMP" VARCHAR2(100 BYTE), 
	"OPEN" NUMBER, 
	"CLOSE" NUMBER, 
	"HIGH" NUMBER, 
	"LOW" NUMBER, 
	"VOLUME" NUMBER, 
	"CREATION_DATE" VARCHAR2(100 BYTE), 
	"CALENDAR_STATUS" VARCHAR2(100 BYTE), 
	"RSI" NUMBER, 
	"MFI" NUMBER, 
	"ATR" NUMBER, 
	"SAR" NUMBER, 
	"BBHIGH" NUMBER, 
	"BBLOW" NUMBER, 
	"CLOSE12" NUMBER, 
	"CLOSE30" NUMBER, 
	"CLOSE50" NUMBER, 
	"CLOSE200" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for View V_ACCOUNT_TRADES_DAILY_PNL
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "ADMIN"."V_ACCOUNT_TRADES_DAILY_PNL" ("ACCOUNT_ID", "RUN_GROUP_NAME", "SYMBOL", "CREATE_TRADE_TIMESTAMP", "ENTER_TRADE_TIMESTAMP", "EXIT_TRADE_TIMESTAMP", "REPORT_DATE", "ENTER_TRADE_PRICE", "EXIT_TRADE_PRICE", "DAILY_PROFIT", "CUM_DAILY_PROFIT", "R", "COMMISSION", "QTY", "POSITION_SIZE", "R_PERCENTAGE", "R_MULTIPLE", "TRADE_STATUS", "TRADE_TYPE") AS 
  WITH D0
AS
(
SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.SYMBOL, A.TRADE_TYPE, A.ENTER_MODEL_TIMESTAMP CREATE_TRADE_TIMESTAMP,
        CASE WHEN A.ENTER_TRADE_TIMESTAMP <= B.CALENDAR_DAY THEN ENTER_TRADE_TIMESTAMP END ENTER_TRADE_TIMESTAMP, 
        CASE WHEN A.EXIT_TRADE_TIMESTAMP = B.CALENDAR_DAY THEN A.EXIT_TRADE_TIMESTAMP END EXIT_TRADE_TIMESTAMP, 
        CASE WHEN A.CANCEL_TRADE_TIMESTAMP = B.CALENDAR_DAY THEN A.CANCEL_TRADE_TIMESTAMP END CANCEL_TRADE_TIMESTAMP, 
        CASE WHEN A.ENTER_TRADE_TIMESTAMP <= B.CALENDAR_DAY THEN A.ENTER_TRADE_PRICE END ENTER_TRADE_PRICE, 
        CASE WHEN A.EXIT_TRADE_TIMESTAMP = B.CALENDAR_DAY THEN A.EXIT_TRADE_PRICE END EXIT_TRADE_PRICE, 
        CASE WHEN A.ENTER_TRADE_TIMESTAMP = B.CALENDAR_DAY THEN COMMISSION_ENTER END COMMISSION_ENTER, 
        CASE WHEN A.EXIT_TRADE_TIMESTAMP = B.CALENDAR_DAY THEN COMMISSION_EXIT END COMMISSION_EXIT,
        B.CALENDAR_DAY, A.QTY, A.ENTER_PERMID,
        C.CLOSE, A.INITIAL_STOP_LOSS, 
        LAG(C.CLOSE) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.SYMBOL, A.TRADE_TYPE, A.ENTER_TRADE_TIMESTAMP ORDER BY B.CALENDAR_DAY) PREV_CLOSE,
        LAG(B.CALENDAR_DAY) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.SYMBOL, A.TRADE_TYPE, A.ENTER_MODEL_TIMESTAMP ORDER BY B.CALENDAR_DAY) PREV_TIMESTAMP
FROM D_ACCOUNT_TRADE A
JOIN D_TRADING_CALENDAR B
ON B.CALENDAR_DAY BETWEEN A.ENTER_MODEL_TIMESTAMP AND coalesce (A.EXIT_TRADE_TIMESTAMP, A.CANCEL_TRADE_TIMESTAMP, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'))
JOIN O_MKT_DATA C
ON B.CALENDAR_DAY = C.TICK_TIMESTAMP
AND C.INTERVAL = '1D'
AND A.SYMBOL = C.SYMBOL
),
D1
AS
(
SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.SYMBOL, A.CREATE_TRADE_TIMESTAMP, A.ENTER_TRADE_TIMESTAMP, A.ENTER_PERMID, A.EXIT_TRADE_TIMESTAMP, A.ENTER_TRADE_PRICE, A.CANCEL_TRADE_TIMESTAMP, A.QTY, A.CALENDAR_DAY REPORT_DATE, A.INITIAL_STOP_LOSS, A.EXIT_TRADE_PRICE, TRADE_TYPE, COMMISSION_ENTER, COMMISSION_EXIT,
        (NVL(CASE WHEN TRADE_TYPE = 'BUY' AND CALENDAR_DAY >= ENTER_TRADE_TIMESTAMP THEN 
                        CASE WHEN CALENDAR_DAY = EXIT_TRADE_TIMESTAMP THEN EXIT_TRADE_PRICE ELSE CLOSE END - CASE WHEN CALENDAR_DAY = ENTER_TRADE_TIMESTAMP THEN ENTER_TRADE_PRICE ELSE PREV_CLOSE END
                    WHEN TRADE_TYPE = 'SELL' AND CALENDAR_DAY >= ENTER_TRADE_TIMESTAMP THEN 
                        -1 * (CASE WHEN CALENDAR_DAY = EXIT_TRADE_TIMESTAMP THEN EXIT_TRADE_PRICE ELSE CLOSE END - CASE WHEN CALENDAR_DAY = ENTER_TRADE_TIMESTAMP THEN ENTER_TRADE_PRICE ELSE PREV_CLOSE END)
                END,0)*qty) DAILY_PROFIT, 
        SUM(NVL(CASE WHEN TRADE_TYPE = 'BUY' AND CALENDAR_DAY >= ENTER_TRADE_TIMESTAMP THEN 
                        CASE WHEN CALENDAR_DAY = EXIT_TRADE_TIMESTAMP THEN EXIT_TRADE_PRICE ELSE CLOSE END - CASE WHEN CALENDAR_DAY = ENTER_TRADE_TIMESTAMP THEN ENTER_TRADE_PRICE ELSE PREV_CLOSE END
                    WHEN TRADE_TYPE = 'SELL' AND CALENDAR_DAY >= ENTER_TRADE_TIMESTAMP THEN 
                        -1 * (CASE WHEN CALENDAR_DAY = EXIT_TRADE_TIMESTAMP THEN EXIT_TRADE_PRICE ELSE CLOSE END - CASE WHEN CALENDAR_DAY = ENTER_TRADE_TIMESTAMP THEN ENTER_TRADE_PRICE ELSE PREV_CLOSE END)
                END,0)*qty)
            OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.SYMBOL, A.ENTER_TRADE_TIMESTAMP ORDER BY A.CALENDAR_DAY) CUM_DAILY_PROFIT
FROM D0 A
)
SELECT "ACCOUNT_ID","RUN_GROUP_NAME","SYMBOL", CREATE_TRADE_TIMESTAMP, "ENTER_TRADE_TIMESTAMP", EXIT_TRADE_TIMESTAMP, "REPORT_DATE", enter_trade_price, exit_trade_price, "DAILY_PROFIT","CUM_DAILY_PROFIT", 
    ROUND(ABS(INITIAL_STOP_LOSS - ENTER_TRADE_PRICE) * QTY, 2) R,
    NVL(COMMISSION_ENTER,0) + NVL(COMMISSION_EXIT,0) COMMISSION,
    QTY,
    ROUND(ENTER_TRADE_PRICE * QTY, 2) POSITION_SIZE,
    ROUND(ABS(INITIAL_STOP_LOSS - ENTER_TRADE_PRICE)/ENTER_TRADE_PRICE, 3) R_PERCENTAGE,
    ROUND(
    CUM_DAILY_PROFIT / (ABS(INITIAL_STOP_LOSS - ENTER_TRADE_PRICE) * QTY), 2) R_MULTIPLE,
    CASE 
        WHEN CANCEL_TRADE_TIMESTAMP IS NOT NULL THEN 'CANCELED' 
        WHEN REPORT_DATE = EXIT_TRADE_TIMESTAMP THEN 'CLOSED' 
        WHEN ENTER_PERMID IS NOT NULL AND REPORT_DATE >= ENTER_TRADE_TIMESTAMP THEN 'OPEN' 
        ELSE 'PENDING'
    END TRADE_STATUS , TRADE_TYPE
FROM D1
;
--------------------------------------------------------
--  DDL for View V_IB_TRADES
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "ADMIN"."V_IB_TRADES" ("SYMBOL", "PERMID", "ACTION", "STOP_ORDER_ID", "EXIT_PERMID", "EXIT_TIME", "EXIT_PRICE", "FILLED_QUANTITY", "COMPLETED_TIMESTAMP", "FILLED_PRICE", "EXIT_QUANTITY", "COMMISSION_ENTER", "COMMISSION_EXIT") AS 
  WITH STOP_OPEN_ORDERS
AS
(
    SELECT SYMBOL, OCAGROUP PERMID, MAX(ORDERID) STOP_ORDER_ID
    FROM D_IB_OPEN_ORDER
    WHERE ORDERTYPE = 'STP'
    AND OCAGROUP IS NOT NULL
    GROUP BY SYMBOL, OCAGROUP
),STOP_CLOSED_ORDERS
AS
(
    SELECT A.SYMBOL, A.OCAGROUP PERMID, A.PERMID EXIT_PERMID, MAX(A.ORDERID) STOP_ORDER_ID, SUM(B.SHARES) EXIT_QUANTITY, MIN(A.COMPLETIONTIME) EXIT_TIME, SUM(B.PRICE*B.SHARES)/SUM(B.SHARES) EXIT_PRICE, SUM(B.COMMISSION  * -1) COMMISSION_EXIT
    FROM D_IB_CLOSED_ORDER A JOIN D_IB_CLOSED_ORDER_DETAILS B ON A.PERMID = B.PERMID
    WHERE A.STATUS = 'Filled'
    AND OCAGROUP IS NOT NULL
    GROUP BY A.SYMBOL, A.OCAGROUP, A.PERMID
),
FILLED_ORDERS
AS
(
    SELECT A.SYMBOL, A.PERMID, A.ACTION, SUM(B.SHARES) FILLED_QUANTITY, MAX(A.COMPLETIONTIME) COMPLETED_TIMESTAMP, SUM(B.PRICE*B.SHARES)/SUM(B.SHARES) FILLED_PRICE, SUM(B.COMMISSION * -1) COMMISSION_ENTER
    FROM D_IB_CLOSED_ORDER A JOIN D_IB_CLOSED_ORDER_DETAILS B ON A.PERMID = B.PERMID
    WHERE A.STATUS = 'Filled'
    AND OCAGROUP IS NULL
    GROUP BY A.SYMBOL, A.PERMID, A.ACTION
),
ALL_ORDERS
AS
(
SELECT SYMBOL, PERMID FROM STOP_OPEN_ORDERS
UNION
SELECT SYMBOL, PERMID FROM STOP_CLOSED_ORDERS
UNION 
SELECT SYMBOL, PERMID FROM FILLED_ORDERS
)


SELECT A.SYMBOL, A.PERMID, C.ACTION, NVL(B.STOP_ORDER_ID, D.STOP_ORDER_ID) STOP_ORDER_ID, 
        D.EXIT_PERMID, D.EXIT_TIME, D.EXIT_PRICE, C.FILLED_QUANTITY, C.COMPLETED_TIMESTAMP, C.FILLED_PRICE, D.EXIT_QUANTITY, C.COMMISSION_ENTER, D.COMMISSION_EXIT 
FROM ALL_ORDERS A
LEFT OUTER JOIN STOP_OPEN_ORDERS B
ON A.SYMBOL = B.SYMBOL
AND A.PERMID = B.PERMID
LEFT OUTER JOIN STOP_CLOSED_ORDERS D
ON A.SYMBOL = D.SYMBOL
AND A.PERMID = D.PERMID
LEFT OUTER JOIN FILLED_ORDERS C
ON A.SYMBOL = C.SYMBOL
AND A.PERMID = C.PERMID
;
--------------------------------------------------------
--  DDL for Index SYS_C007350
--------------------------------------------------------

  CREATE UNIQUE INDEX "ADMIN"."SYS_C007350" ON "ADMIN"."D_IB_OPEN_ORDER" ("PERMID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Package PKG_OSDM_UTILS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "ADMIN"."PKG_OSDM_UTILS" AS

single_table_prefix  CONSTANT VARCHAR2(30) := 'osdmSingleTable';
all_tables_prefix    CONSTANT VARCHAR2(30) := 'osdmAllTables';
single_entity_prefix CONSTANT VARCHAR2(30) := 'osdmSingleEntity';
all_entities_prefix  CONSTANT VARCHAR2(30) := 'osdmAllEntities';
single_st_prefix     CONSTANT VARCHAR2(30) := 'osdmSingleStructuredType';
all_st_prefix        CONSTANT VARCHAR2(30) := 'osdmAllStructuredTypes';
single_ct_prefix     CONSTANT VARCHAR2(30) := 'osdmSingleCollectionType';
all_ct_prefix        CONSTANT VARCHAR2(30) := 'osdmAllCollectionTypes';
single_dt_prefix     CONSTANT VARCHAR2(30) := 'osdmSingleDistinctType';
all_dt_prefix        CONSTANT VARCHAR2(30) := 'osdmAllDistinctTypes';
all_domains_prefix   CONSTANT VARCHAR2(30) := 'osdmAllDomains';
all_cr_prefix        CONSTANT VARCHAR2(30) := 'osdmAllChangeRequests';
all_mr_prefix        CONSTANT VARCHAR2(30) := 'osdmAllMeasurements';
glossary_prefix      CONSTANT VARCHAR2(30) := 'osdmGlossary';

PROCEDURE Generate_Report(v_rep_id           IN NUMBER,
                          v_obj_ovid         IN VARCHAR2,
                          v_mode             IN NUMBER,
                          v_reports_dir      IN VARCHAR2,
                          v_report_name      IN VARCHAR2,
                          reportTemplate     IN REPORT_TEMPLATE,
                          objects            IN OBJECTS_LIST,
                          v_raw_xml         OUT BFILE, 
                          v_status          OUT NUMBER, 
                          osddm_reports_dir OUT VARCHAR2,
                          v_diagrams        OUT SYS_REFCURSOR,
                          v_diagrams_svg    OUT SYS_REFCURSOR);

FUNCTION Gather_Constraint_Details_XML(col_attr_ovid IN VARCHAR2,namespace IN VARCHAR2) RETURN CLOB;

FUNCTION Gather_Domain_Constraints_XML(domain_ovid VARCHAR2) RETURN CLOB;

FUNCTION Gather_Constraint_Details_HTML(col_attr_ovid VARCHAR2) RETURN CLOB;

FUNCTION Gather_Domain_Constraints_HTML (domain_ovid VARCHAR2) RETURN CLOB;

END PKG_OSDM_UTILS;




/
--------------------------------------------------------
--  DDL for Package Body PKG_OSDM_UTILS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "ADMIN"."PKG_OSDM_UTILS" AS

log_file   UTL_FILE.File_Type;
temp_file  UTL_FILE.File_Type;

PROCEDURE Generate_OS_File(v_blob IN BLOB, filename IN VARCHAR2) IS

result_file     UTL_FILE.File_Type;
compressed_blob BLOB;
len             NUMBER;
l_pos           INTEGER := 1;
l_amount        BINARY_INTEGER := 32767;
l_buffer        RAW(32767);

BEGIN

 result_file := UTL_FILE.FOpen('OSDDM_REPORTS_DIR',filename,'wb', 32767); 

 len := DBMS_LOB.getlength(v_blob);

 WHILE l_pos < len LOOP
      DBMS_LOB.read(v_blob, l_amount, l_pos, l_buffer);
      UTL_FILE.put_raw(result_file, l_buffer, TRUE);
      l_pos := l_pos + l_amount;
 END LOOP;

 UTL_FILE.fclose(result_file);

EXCEPTION

 WHEN others THEN

  IF UTL_FILE.Is_Open(result_file) THEN
     UTL_FILE.FClose(result_file);
  END IF;

  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_OS_File Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_OS_File Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);

END Generate_OS_File;

FUNCTION Gather_Constraint_Details_XML(col_attr_ovid VARCHAR2, namespace VARCHAR2) RETURN CLOB IS

res        CLOB;
v_vl_value VARCHAR2(50) := namespace||':VLValue';
v_s_descr  VARCHAR2(50) := namespace||':VLShortDescription';

CURSOR cur_c_constraints(v_ovid IN VARCHAR2, v_ns IN VARCHAR2) IS
 SELECT DECODE(v_ns, single_table_prefix,  XMLElement(EVALNAME(single_table_prefix  || ':DatabaseType'), XMLCDATA(cc.text)).getClobVal(),
                     all_tables_prefix,    XMLElement(EVALNAME(all_tables_prefix    || ':DatabaseType'), XMLCDATA(cc.text)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':DatabaseType'), XMLCDATA(cc.text)).getClobVal(),
                     all_entities_prefix,  XMLElement(EVALNAME(all_entities_prefix  || ':DatabaseType'), XMLCDATA(cc.text)).getClobVal())           text,
        DECODE(v_ns, single_table_prefix,  XMLElement(EVALNAME(single_table_prefix  || ':DatabaseType'), XMLCDATA(cc.database_type)).getClobVal(),
                     all_tables_prefix,    XMLElement(EVALNAME(all_tables_prefix    || ':DatabaseType'), XMLCDATA(cc.database_type)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':DatabaseType'), XMLCDATA(cc.database_type)).getClobVal(),
                     all_entities_prefix,  XMLElement(EVALNAME(all_entities_prefix  || ':DatabaseType'), XMLCDATA(cc.database_type)).getClobVal())  db_type,
        COUNT(cc.text) over()                                                                                                                       total_row_count
 FROM   dmrs_check_constraints cc
 WHERE  cc.dataelement_ovid = v_ovid
 ORDER BY sequence;
rec_c_constraints cur_c_constraints%rowtype;

CURSOR cur_vr_constraints(v_ovid IN VARCHAR2, v_ns IN VARCHAR2) IS
 SELECT DECODE(v_ns, single_table_prefix, XMLElement(EVALNAME(single_table_prefix   || ':RangeBeginValue'), XMLCDATA(vr.begin_value)).getClobVal(),
                     all_tables_prefix,XMLElement(EVALNAME(all_tables_prefix        || ':RangeBeginValue'), XMLCDATA(vr.begin_value)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':RangeBeginValue'), XMLCDATA(vr.begin_value)).getClobVal(),
                     all_entities_prefix,XMLElement(EVALNAME(all_entities_prefix    || ':RangeBeginValue'), XMLCDATA(vr.begin_value)).getClobVal())              begin_value,
        DECODE(v_ns, single_table_prefix, XMLElement(EVALNAME(single_table_prefix   || ':RangeEndValue'), XMLCDATA(vr.end_value)).getClobVal(),
                     all_tables_prefix,XMLElement(EVALNAME(all_tables_prefix        || ':RangeEndValue'), XMLCDATA(vr.end_value)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':RangeEndValue'), XMLCDATA(vr.end_value)).getClobVal(),
                     all_entities_prefix,XMLElement(EVALNAME(all_entities_prefix    || ':RangeEndValue'), XMLCDATA(vr.end_value)).getClobVal())                  end_value,
        DECODE(v_ns, single_table_prefix, XMLElement(EVALNAME(single_table_prefix   || ':RangeShortDescription'), XMLCDATA(vr.short_description)).getClobVal(),  
                     all_tables_prefix,XMLElement(EVALNAME(all_tables_prefix        || ':RangeShortDescription'), XMLCDATA(vr.short_description)).getClobVal(),  
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':RangeShortDescription'), XMLCDATA(vr.short_description)).getClobVal(),
                     all_entities_prefix,XMLElement(EVALNAME(all_entities_prefix    || ':RangeShortDescription'), XMLCDATA(vr.short_description)).getClobVal())  short_description,
        COUNT(vr.begin_value) over()                                                                                                                             total_row_count
 FROM   dmrs_value_ranges vr
 WHERE  vr.dataelement_ovid = v_ovid
 ORDER BY sequence;
rec_vr_constraints cur_vr_constraints%rowtype;

CURSOR cur_vl_constraints(v_ovid IN VARCHAR2, v_ns IN VARCHAR2) IS
 SELECT DECODE(v_ns, single_table_prefix, XMLElement(EVALNAME(single_table_prefix || ':VLValue'), XMLCDATA(av.value)).getClobVal(),
                     all_tables_prefix,XMLElement(EVALNAME(all_tables_prefix || ':VLValue'), XMLCDATA(av.value)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':VLValue'), XMLCDATA(av.value)).getClobVal(),
                     all_entities_prefix,XMLElement(EVALNAME(all_entities_prefix || ':VLValue'), XMLCDATA(av.value)).getClobVal())                         av_value,
        DECODE(v_ns, single_table_prefix, XMLElement(EVALNAME(single_table_prefix || ':VLShortDescription'), XMLCDATA(av.short_description)).getClobVal(),
                     all_tables_prefix,XMLElement(EVALNAME(all_tables_prefix || ':VLShortDescription'), XMLCDATA(av.short_description)).getClobVal(),
                     single_entity_prefix, XMLElement(EVALNAME(single_entity_prefix || ':VLShortDescription'), XMLCDATA(av.short_description)).getClobVal(),
                     all_entities_prefix,XMLElement(EVALNAME(all_entities_prefix || ':VLShortDescription'), XMLCDATA(av.short_description)).getClobVal())  short_description,
        COUNT(av.value) over()                                                                                         total_row_count
 FROM   dmrs_avt av,
        dmrs_columns c
 WHERE  c.ovid = av.dataelement_ovid
 AND    av.dataelement_ovid = v_ovid;
rec_vl_constraints cur_vl_constraints%rowtype;

BEGIN

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  FOR rec_vr_constraints IN cur_vr_constraints(col_attr_ovid, namespace) LOOP
     IF (cur_vr_constraints%ROWCOUNT = 1) THEN
       DBMS_LOB.APPEND (res, '<'||namespace||':RangesCollection>');
     END IF;

       DBMS_LOB.APPEND (res, '<'||namespace||':RangeDetails>');
       DBMS_LOB.APPEND (res, rec_vr_constraints.begin_value);
       DBMS_LOB.APPEND (res, rec_vr_constraints.end_value);
       DBMS_LOB.APPEND (res, rec_vr_constraints.short_description);
       DBMS_LOB.APPEND (res, '</'||namespace||':RangeDetails>');

     IF (cur_vr_constraints%ROWCOUNT = rec_vr_constraints.total_row_count) THEN
       DBMS_LOB.APPEND (res, '</'||namespace||':RangesCollection>');
     END IF;
  END LOOP;

  FOR rec_vl_constraints IN cur_vl_constraints(col_attr_ovid, namespace) LOOP
     IF (cur_vl_constraints%ROWCOUNT = 1) THEN
       DBMS_LOB.APPEND (res, '<'||namespace||':ValueListsCollection>');
     END IF;

       DBMS_LOB.APPEND (res, '<'||namespace||':ValueListDetails>');
       DBMS_LOB.APPEND (res, rec_vl_constraints.av_value);
       DBMS_LOB.APPEND (res, rec_vl_constraints.short_description);
       DBMS_LOB.APPEND (res, '</'||namespace||':ValueListDetails>');

     IF (cur_vl_constraints%ROWCOUNT = rec_vl_constraints.total_row_count) THEN
       DBMS_LOB.APPEND (res, '</'||namespace||':ValueListsCollection>');
     END IF;
  END LOOP;

  FOR rec_c_constraints IN cur_c_constraints(col_attr_ovid, namespace) LOOP
     IF (cur_c_constraints%ROWCOUNT = 1) THEN
       DBMS_LOB.APPEND (res, '<'||namespace||':CheckConstraintsCollection>');
     END IF;

      DBMS_LOB.APPEND (res, '<'||namespace||':CheckConstraintDetails>');
      DBMS_LOB.APPEND (res, rec_c_constraints.text);
      DBMS_LOB.APPEND (res, rec_c_constraints.db_type);
      DBMS_LOB.APPEND (res, '</'||namespace||':CheckConstraintDetails>');

     IF (cur_c_constraints%ROWCOUNT = rec_c_constraints.total_row_count) THEN
       DBMS_LOB.APPEND (res, '</'||namespace||':CheckConstraintsCollection>');
     END IF;
  END LOOP;

  RETURN res;

EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Constraint_Details_XML Exception : : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Constraint_Details_XML Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_Constraint_Details_XML;

FUNCTION Gather_SingleTable_Data(v_table_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, v_report_name IN VARCHAR2) RETURN CLOB IS 

res             CLOB;
v_description   VARCHAR2(32767);
v_notes         VARCHAR2(32767);
v_cc_created    BOOLEAN := FALSE;
token_value     CLOB;

-- Common Data
CURSOR cur_common_data(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':DesignName'),d.design_name).getClobVal()                                      design_name,
        XMLElement(EVALNAME(single_table_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal() version_date,

        XMLElement(EVALNAME(single_table_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                   version_comment,
        XMLElement(EVALNAME(single_table_prefix || ':ModelName'),m.model_name).getClobVal()                                        model_name
 FROM   dmrs_designs d, 
        dmrs_models m,
        dmrs_tables t
 WHERE  d.design_ovid = m.design_ovid
 AND   t.model_ovid = m.model_ovid
 AND   t.ovid = v_t_ovid;
rec_common_data cur_common_data%ROWTYPE;

-- Table General Data
CURSOR cur_table(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':TableName'),DECODE(t.schema_name, NULL, '', t.schema_name ||'.') || t.table_name).getClobVal()  table_name,
        XMLElement(EVALNAME(single_table_prefix || ':Abbreviation'),t.abbreviation).getClobVal()                                                     abbreviation,
        XMLElement(EVALNAME(single_table_prefix || ':ClassificationTypeName'),t.classification_type_name).getClobVal()                               class_type_name,
        XMLElement(EVALNAME(single_table_prefix || ':ObjectTypeName'),t.structured_type_name).getClobVal()                                           obj_type_name,
        XMLElement(EVALNAME(single_table_prefix || ':NumberOfColumns'),t.number_data_elements).getClobVal()                                          number_cols,
        XMLElement(EVALNAME(single_table_prefix || ':NumberOfRowsMin'),t.min_volume).getClobVal()                                                    number_rows_min,
        XMLElement(EVALNAME(single_table_prefix || ':NumberOfRowsMax'),t.max_volume).getClobVal()                                                    number_rows_max,
        XMLElement(EVALNAME(single_table_prefix || ':ExpectedNumberOfRows'),t.expected_volume).getClobVal()                                          number_rows_expected,
        XMLElement(EVALNAME(single_table_prefix || ':ExpectedGrowth'),t.growth_rate_percents).getClobVal()                                           growth_expected,
        XMLElement(EVALNAME(single_table_prefix || ':GrowthInterval'),t.growth_rate_interval).getClobVal()                                           growth_interval,
        XMLElement(EVALNAME(single_table_prefix || ':FunctionalName'), (SELECT NVL(e.entity_name,'')                        
                                              FROM   dmrs_entities e,
                                                     dmrs_mappings m
                                              WHERE  m.relational_object_ovid = t.ovid
                                              AND    m.logical_object_ovid  = e.ovid
                                              AND    ROWNUM = 1)).getClobVal()                                                                       functional_name
 FROM	 dmrs_tables t
 WHERE  t.ovid = v_t_ovid;
rec_table cur_table%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':Diagram'), 
          XMLElement(EVALNAME(single_table_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
          XMLElement(EVALNAME(single_table_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                                total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

-- Columns Data
CURSOR cur_columns(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':Sequence'),c.sequence).getClobVal()                                                                                              seq,
        XMLElement(EVALNAME(single_table_prefix || ':ColumnName'),c.column_name).getClobVal()                                                                                         column_name,
        XMLElement(EVALNAME(single_table_prefix || ':PK'),c.pk_flag).getClobVal()                                                                                                     pk,
        XMLElement(EVALNAME(single_table_prefix || ':FK'),c.fk_flag).getClobVal()                                                                                                     fk,
        XMLElement(EVALNAME(single_table_prefix || ':M'),DECODE(c.mandatory,'N',' ',c.mandatory)).getClobVal()                                                                        m,
        XMLElement(EVALNAME(single_table_prefix || ':DataTypeKind'),DECODE(c.datatype_kind,                                                                                           
                                                 'Domain',         'DOM',
                                                 'Logical Type',   'LT',
                                                 'Distinct Type',  'DT',
                                                 'Ref Struct Type','RST',
                                                 'Structured Type','ST',
                                                 'Collection Type','CT')
                  ).getClobVal()                                                                                                                             dt_kind,
         XMLElement(EVALNAME(single_table_prefix || ':DataType'), 
            DECODE(c.datatype_kind, 
                  'Domain', c.logical_type_name ||' '||
                           DECODE (NVL(c.t_size,''),'',
                              DECODE(NVL(c.t_scale,0),0,
                                 DECODE(NVL(c.t_precision,0),0,null,'('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) ||')'),
                                   '('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) || ',' || DECODE(NVL(c.t_scale,0),0,null,c.t_scale)||')'),
                                   '('||TRIM(DECODE(c.t_size,'',null,c.t_size||' '||c.char_units ))||')'),
                   'Logical Type', c.logical_type_name  ||' '|| 
                           DECODE (NVL(c.t_size,''),'',
                              DECODE(NVL(c.t_scale,0),0,
                                 DECODE(NVL(c.t_precision,0),0,null,'('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) ||')'),
                                   '('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) || ',' || DECODE(NVL(c.t_scale,0),0,null,c.t_scale)||')'),
                                   '('||TRIM(DECODE(c.t_size,'',null,c.t_size||' '||c.char_units ))||')')
            ) ||
            DECODE (c.auto_increment_column,'Y', ' - AI','') ||
            DECODE (c.identity_column,'Y', ' - ID','')
          ).getClobVal()                                                                                                                                    data_type,
        XMLElement(EVALNAME(single_table_prefix || ':DomainName'),DECODE(c.domain_name,'Unknown',null,c.domain_name)).getClobVal()                                                     domain_name,
        XMLElement(EVALNAME(single_table_prefix || ':Formula'), TRIM(c.formula||' '||c.default_value)).getClobVal()                                                                    formula,
        XMLElement(EVALNAME(single_table_prefix || ':Security'),DECODE(c.personally_id_information ||'/'||c.sensitive_information||'/'||c.mask_for_none_production,'//',
                                      null,c.personally_id_information ||'/'||c.sensitive_information||'/'||c.mask_for_none_production)).getClobVal()       security,
        XMLElement(EVALNAME(single_table_prefix || ':PreferredAbbreviation'),c.abbreviation).getClobVal()                                                                              abbreviation,
        COUNT(c.column_name) over()                                                                                                                         total_row_count
 FROM 	dmrs_columns c
 WHERE  c.container_ovid = v_t_ovid
 ORDER BY c.sequence;
rec_columns cur_columns%ROWTYPE;

-- Columns Comments Data
CURSOR cur_columns_comments(v_t_ovid IN VARCHAR2) IS
 SELECT a.seq                       seq, 
        a.column_name               column_name, 
        a.column_description        column_description, 
        a.column_notes              column_notes,
        COUNT(a.column_name) over() total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(single_table_prefix || ':ColumnCommentsSequence'),c.sequence).getStringVal()  seq,
         XMLElement(EVALNAME(single_table_prefix || ':ColumnCommentsName'),c.column_name).getStringVal()   column_name,
         XMLElement(EVALNAME(single_table_prefix || ':ColumnDescription'),XMLCDATA(
         NVL(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = c.ovid
         AND    t.type='Comments'),
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = c.ovid
         AND    t.type='CommentsInRDBMS')))).getClobVal()                                                  column_description, 
         XMLElement(EVALNAME(single_table_prefix || ':ColumnNotes'),XMLCDATA(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = c.ovid
         AND    t.type='Note'))).getClobVal()                                                             column_notes
  FROM   dmrs_columns c
  WHERE  c.container_ovid = v_t_ovid
  ORDER BY c.sequence
 ) a
 WHERE DBMS_LOB.getlength(column_description) > 0 OR DBMS_LOB.getlength(column_notes) > 0;
rec_columns_comments cur_columns_comments%ROWTYPE;

--Indexes
CURSOR cur_indexes(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':IndexName'),i.index_name).getClobVal()                                                                                        idx_name,
        XMLElement(EVALNAME(single_table_prefix || ':IndexState'),DECODE(i.state,'Unique Plain Index','UN','Unique Constraint','UK','Primary Constraint','PK',null)).getClobVal()  state,
        XMLElement(EVALNAME(single_table_prefix || ':IndexFunctional'),DECODE(i.functional,'N',' ',i.functional)).getClobVal()                                                     functional,
        XMLElement(EVALNAME(single_table_prefix || ':IndexSpatial'),DECODE(i.spatial_index,'N',' ',i.spatial_index)).getClobVal()                                                  spatial,
        XMLElement(EVALNAME(single_table_prefix || ':IndexExpression'),i.expression).getClobVal()                                                                                  expression,
        XMLElement(EVALNAME(single_table_prefix || ':IndexColumnName'),c.column_name).getClobVal()                                                                                 col_name,
        XMLElement(EVALNAME(single_table_prefix || ':IndexSortOrder'),c.sort_order).getClobVal()                                                                                   sort_order,
        c.sequence                                                                                                                                      idx_sequence,
        COUNT(c.column_name) over()                                                                                                                     total_row_count
 FROM   dmrs_tables t,
        dmrs_indexes i,
        dmrs_constr_index_columns c
 WHERE  t.ovid = i.container_ovid
 AND    i.ovid = c.index_ovid
 AND    t.ovid = v_t_ovid
 ORDER BY i.index_name, c.sequence, c.sort_order;
rec_indexes cur_indexes%ROWTYPE;

-- Table Level Constraints
CURSOR cur_tl_constraints(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':TLConstraintType'), CASE WHEN rownum>1 THEN ''
                                               ELSE 'Table Level'
                                               END ).getClobVal()                                         c_type,
        XMLElement(EVALNAME(single_table_prefix || ':TLConstraintName'), tc.constraint_name).getClobVal() c_name,
        XMLElement(EVALNAME(single_table_prefix || ':TLConstraintRule'), XMLCDATA(tc.text)).getClobVal()  c_details,
        COUNT(tc.constraint_name) over()                                                                  total_row_count
 FROM   dmrs_table_constraints tc
 WHERE  tc.table_ovid = v_t_ovid;
rec_tl_constraints cur_tl_constraints%ROWTYPE;

-- Column Level Constraints
CURSOR cur_cl_constraints(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':ContstraintType'), CASE WHEN rownum>1 THEN ''
                                              ELSE 'Column Level'
                                              END).getClobVal()                                        c_type,
        XMLElement(EVALNAME(single_table_prefix || ':ALCConstraintName'), c.column_name || 
                                                DECODE((SELECT DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE c.ovid = dataelement_ovid),NULL,'',
                                               ' / '|| (SELECT  DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE c.ovid = dataelement_ovid))).getClobVal() c_name,
        Gather_Constraint_Details_XML(c.ovid, single_table_prefix)                                      c_details,
        COUNT(c.column_name) over()                                                                     total_row_count
 FROM   dmrs_columns c
 WHERE  c.container_ovid = v_t_ovid
 AND    (c.ovid IN (SELECT dataelement_ovid FROM dmrs_avt) OR 
         c.ovid IN (SELECT dataelement_ovid FROM dmrs_value_ranges) OR 
         c.ovid IN (SELECT dataelement_ovid FROM dmrs_check_constraints));
rec_cl_constraints cur_cl_constraints%ROWTYPE;

--Foreign keys referring to other tables
CURSOR cur_fk_referring_to(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':FKName'),CASE WHEN ic.sequence>1 THEN ' '
                                    ELSE fk.fk_name
                                    END
                   ).getClobVal()                                               fk_name,
        XMLElement(EVALNAME(single_table_prefix || ':FKReferringTo'),CASE WHEN ic.sequence>1 THEN ' '
                                          ELSE fk.referred_table_name
                                          END
                  ).getClobVal()                                                referring_to,
        XMLElement(EVALNAME(single_table_prefix || ':FKMandatory'),CASE WHEN ic.sequence>1 THEN ' '
                                         ELSE DECODE(fk.mandatory,'Y',fk.mandatory,' ')
                                         END
                  ).getClobVal()                                                mandatory,
        XMLElement(EVALNAME(single_table_prefix || ':FKTransferable'),CASE WHEN ic.sequence>1 THEN ' '
                                            ELSE DECODE(fk.transferable,'Y',fk.transferable,' ')
                                            END
                  ).getClobVal()                                                transferable,
        XMLElement(EVALNAME(single_table_prefix || ':FKInArc'),CASE WHEN ic.sequence>1 THEN ' '
                                     ELSE DECODE(fk.in_arc,'Y',fk.in_arc,' ')
                                     END
                  ).getClobVal()                                                in_arc,
        XMLElement(EVALNAME(single_table_prefix || ':FKColumnName'),ic.column_name).getClobVal()          col_name,
        ic.sequence                                                             seq,
        COUNT(ic.column_name) over()                                            total_row_count
 FROM   dmrs_foreignkeys fk,
        dmrs_constr_fk_columns ic
 WHERE  fk.child_table_ovid = v_t_ovid
 AND    fk.ovid = ic.fk_ovid
 ORDER BY fk.referred_table_name,fk.fk_name, ic.sequence;
rec_fk_referring_to cur_fk_referring_to%ROWTYPE;

--Foreign keys referred from other tables
CURSOR cur_fk_referred_from(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_table_prefix || ':FKName'),CASE WHEN ic.sequence>1 THEN ' '
                                    ELSE fk.fk_name
                                    END
                   ).getClobVal()                                              fk_name,
        XMLElement(EVALNAME(single_table_prefix || ':FKReferredFrom'),CASE WHEN ic.sequence>1 THEN ' '
                                           ELSE fk.child_table_name
                                           END
                  ).getClobVal()                                                referred_from,
        XMLElement(EVALNAME(single_table_prefix || ':FKMandatory'),CASE WHEN ic.sequence>1 THEN ' '
                                         ELSE DECODE(fk.mandatory,'Y',fk.mandatory,' ')
                                         END
                  ).getClobVal()                                                mandatory,
        XMLElement(EVALNAME(single_table_prefix || ':FKTransferable'),CASE WHEN ic.sequence>1 THEN ' '
                                            ELSE DECODE(fk.transferable,'Y',fk.transferable,' ')
                                            END
                  ).getClobVal()                                                transferable,
        XMLElement(EVALNAME(single_table_prefix || ':FKInArc'),CASE WHEN ic.sequence>1 THEN ' '
                                     ELSE DECODE(fk.in_arc,'Y',fk.in_arc,' ')
                                     END
                  ).getClobVal()                                                in_arc,
        XMLElement(EVALNAME(single_table_prefix || ':FKColumnName'),ic.column_name).getClobVal()           col_name,
        ic.sequence                                                             seq,
        COUNT(ic.column_name) over()                                            total_row_count
 FROM   dmrs_foreignkeys fk,
        dmrs_constr_fk_columns ic
 WHERE  fk.referred_table_ovid = v_t_ovid
 AND    fk.ovid = ic.fk_ovid
 ORDER BY fk.child_table_name,fk.fk_name, ic.sequence;
rec_fk_referred_from cur_fk_referred_from%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering single table data started ...');

   DBMS_LOB.CREATETEMPORARY(res, TRUE);
   DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':Table xmlns:' || single_table_prefix || '="http://oracle.com/datamodeler/reports/table">');

   -- Common Data
   FOR rec_common_data IN cur_common_data(v_table_ovid) LOOP

      DBMS_LOB.APPEND (res, rec_common_data.design_name);
      DBMS_LOB.APPEND (res, rec_common_data.version_date);  
      DBMS_LOB.APPEND (res, rec_common_data.version_comment);  
      DBMS_LOB.APPEND (res, rec_common_data.model_name);

   END LOOP;

   -- Description / Notes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

      DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':DescriptionNotes>');

      SELECT 
        XMLElement(EVALNAME(single_table_prefix || ':Description'), XMLCDATA(
            NVL((SELECT t.text comments_in_rdbms
                 FROM   dmrs_large_text t
                 WHERE  t.ovid = v_table_ovid
                 AND    t.type='Comments'),
                (SELECT t.text comments_in_rdbms
                 FROM   dmrs_large_text t
                 WHERE  t.ovid = v_table_ovid
                 AND    t.type='CommentsInRDBMS')))).getClobVal(), 
        XMLElement(EVALNAME(single_table_prefix || ':Notes'), XMLCDATA(
               (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = v_table_ovid
                AND    t.type='Note'))).getClobVal()
      INTO   v_description, 
             v_notes
      FROM  dual;

      DBMS_LOB.APPEND (res, v_description);
      DBMS_LOB.APPEND (res, v_notes);
      DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':DescriptionNotes>');

   END IF;

   --Table General Data
   FOR rec_table IN cur_table(v_table_ovid) LOOP
      DBMS_LOB.APPEND (res, rec_table.table_name);
      DBMS_LOB.APPEND (res, rec_table.functional_name);      
      DBMS_LOB.APPEND (res, rec_table.abbreviation);
      DBMS_LOB.APPEND (res, rec_table.class_type_name);
      DBMS_LOB.APPEND (res, rec_table.obj_type_name);

      IF (reportTemplate.reportType = 0 OR reportTemplate.useQuantitativeInfo = 1) THEN
        DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':QuantitativeInfoCollection>');
        DBMS_LOB.APPEND (res, rec_table.number_cols);
        DBMS_LOB.APPEND (res, rec_table.number_rows_min);
        DBMS_LOB.APPEND (res, rec_table.number_rows_max);
        DBMS_LOB.APPEND (res, rec_table.number_rows_expected);
        DBMS_LOB.APPEND (res, rec_table.growth_expected);
        DBMS_LOB.APPEND (res, rec_table.growth_interval);
        DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':QuantitativeInfoCollection>');
      END IF;
   END LOOP;

   -- Diagrams
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
     FOR rec_diagrams IN cur_diagrams(v_table_ovid, v_report_name) LOOP
        IF (cur_diagrams%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':DiagramsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

        IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':DiagramsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Columns
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableColumns = 1) THEN
     FOR rec_columns IN cur_columns(v_table_ovid) LOOP
        IF (cur_columns%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':ColumnsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':ColumnDetails>');
          DBMS_LOB.APPEND (res, rec_columns.seq);
          DBMS_LOB.APPEND (res, rec_columns.column_name);
          DBMS_LOB.APPEND (res, rec_columns.pk);
          DBMS_LOB.APPEND (res, rec_columns.fk);
          DBMS_LOB.APPEND (res, rec_columns.m);
          IF (INSTR(LOWER(rec_columns.data_type),'unknown') = 0) THEN
            DBMS_LOB.APPEND (res, rec_columns.data_type);
          ELSE
            SELECT XMLElement(EVALNAME(single_table_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
            DBMS_LOB.APPEND (res, token_value);
          END IF;
          DBMS_LOB.APPEND (res, rec_columns.dt_kind);
          DBMS_LOB.APPEND (res, rec_columns.domain_name);
          DBMS_LOB.APPEND (res, rec_columns.formula);
          DBMS_LOB.APPEND (res, rec_columns.security);
          DBMS_LOB.APPEND (res, rec_columns.abbreviation);
          DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':ColumnDetails>');

        IF (cur_columns%ROWCOUNT = rec_columns.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':ColumnsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Columns Comments
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableColumnsComments = 1) THEN
     FOR rec_columns_comments IN cur_columns_comments(v_table_ovid) LOOP
        IF (cur_columns_comments%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':ColumnsCommentsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':ColumnCommentsDetails>');
          DBMS_LOB.APPEND (res, rec_columns_comments.seq);
          DBMS_LOB.APPEND (res, rec_columns_comments.column_name);
          DBMS_LOB.APPEND (res, rec_columns_comments.column_description);
          DBMS_LOB.APPEND (res, rec_columns_comments.column_notes);
          DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':ColumnCommentsDetails>');

        IF (cur_columns_comments%ROWCOUNT = rec_columns_comments.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':ColumnsCommentsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Indexes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableIndexes = 1) THEN
     FOR rec_indexes IN cur_indexes(v_table_ovid) LOOP
        IF (cur_indexes%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':IndexesCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':IndexDetails>');
          DBMS_LOB.APPEND (res, rec_indexes.idx_name);
          DBMS_LOB.APPEND (res, rec_indexes.state);
          DBMS_LOB.APPEND (res, rec_indexes.functional);
          DBMS_LOB.APPEND (res, rec_indexes.spatial);
          DBMS_LOB.APPEND (res, rec_indexes.expression);
          DBMS_LOB.APPEND (res, rec_indexes.col_name);
          DBMS_LOB.APPEND (res, rec_indexes.sort_order);
          DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':IndexDetails>');

        IF (cur_indexes%ROWCOUNT = rec_indexes.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':IndexesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Constraints
   v_cc_created := FALSE;
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableConstraints = 1) THEN
     -- Table Level Constraints
     FOR rec_tl_constraints IN cur_tl_constraints(v_table_ovid) LOOP
        IF (cur_tl_constraints%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':ConstraintsCollection>');
          v_cc_created := TRUE;
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':TableLevelConstraintsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':TableLevelConstraintDetails>');
          DBMS_LOB.APPEND (res, rec_tl_constraints.c_type);
          DBMS_LOB.APPEND (res, rec_tl_constraints.c_name);
          DBMS_LOB.APPEND (res, rec_tl_constraints.c_details);
          DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':TableLevelConstraintDetails>');

        IF (cur_tl_constraints%ROWCOUNT = rec_tl_constraints.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':TableLevelConstraintsCollection>');
        END IF;

     END LOOP;

     -- Column Level Constraints
     FOR rec_cl_constraints IN cur_cl_constraints(v_table_ovid) LOOP
        IF (cur_cl_constraints%ROWCOUNT = 1) THEN
          IF NOT v_cc_created THEN
             DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':ConstraintsCollection>');
             v_cc_created := TRUE;
          END IF;

         DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':ColumnLevelConstraintsCollection>');
         v_cc_created := TRUE;
        END IF;

         DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':ConstraintDetails>');
         DBMS_LOB.APPEND (res, rec_cl_constraints.c_type);
         DBMS_LOB.APPEND (res, rec_cl_constraints.c_name);
         DBMS_LOB.APPEND (res, rec_cl_constraints.c_details);
         DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':ConstraintDetails>');

        IF (cur_cl_constraints%ROWCOUNT = rec_cl_constraints.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':ColumnLevelConstraintsCollection>');
        END IF;
     END LOOP;

     IF v_cc_created THEN
       DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':ConstraintsCollection>');
     END IF;
   END IF;

   -- Foreign Keys Referring To
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableFKReferringTo = 1) THEN
     FOR rec_fk_referring_to IN cur_fk_referring_to(v_table_ovid) LOOP
        IF (cur_fk_referring_to%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':FKRTCollection>');
        END IF;

         DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':FKRTDetails>');
         DBMS_LOB.APPEND (res, rec_fk_referring_to.fk_name);
         DBMS_LOB.APPEND (res, rec_fk_referring_to.referring_to);
         DBMS_LOB.APPEND (res, rec_fk_referring_to.mandatory);
         DBMS_LOB.APPEND (res, rec_fk_referring_to.transferable);
         DBMS_LOB.APPEND (res, rec_fk_referring_to.in_arc);
         DBMS_LOB.APPEND (res, rec_fk_referring_to.col_name);
         DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':FKRTDetails>');

        IF (cur_fk_referring_to%ROWCOUNT = rec_fk_referring_to.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':FKRTCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Foreign Keys Referred From
   IF (reportTemplate.reportType = 0 OR reportTemplate.useTableFKReferredFrom = 1) THEN
     FOR rec_fk_referred_from IN cur_fk_referred_from(v_table_ovid) LOOP
        IF (cur_fk_referred_from%ROWCOUNT = 1) THEN
            DBMS_LOB.APPEND (res,'<' || single_table_prefix || ':FKRFCollection>');
        END IF;

         DBMS_LOB.APPEND (res, '<' || single_table_prefix || ':FKRFDetails>');
         DBMS_LOB.APPEND (res, rec_fk_referred_from.fk_name);
         DBMS_LOB.APPEND (res, rec_fk_referred_from.referred_from);
         DBMS_LOB.APPEND (res, rec_fk_referred_from.mandatory);
         DBMS_LOB.APPEND (res, rec_fk_referred_from.transferable);
         DBMS_LOB.APPEND (res, rec_fk_referred_from.in_arc);
         DBMS_LOB.APPEND (res, rec_fk_referred_from.col_name);
         DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':FKRFDetails>');

        IF (cur_fk_referred_from%ROWCOUNT = rec_fk_referred_from.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_table_prefix || ':FKRFCollection>');
        END IF;
     END LOOP;
   END IF;

   DBMS_LOB.APPEND (res,'</' || single_table_prefix || ':Table>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering single table data ended');

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleTable_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleTable_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_SingleTable_Data;

FUNCTION Gather_AllTables_Data(v_model_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, objects IN OBJECTS_LIST, v_report_name IN VARCHAR2) RETURN CLOB IS 

res             CLOB;
v_description   VARCHAR2(32767);
v_notes         VARCHAR2(32767);
v_cc_created    BOOLEAN := FALSE;
token_value     CLOB;

-- Common Data
CURSOR cur_common_data(v_m_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':DesignName'),d.design_name).getClobVal()                                      design_name,
        XMLElement(EVALNAME(all_tables_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal() version_date,
        XMLElement(EVALNAME(all_tables_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                   version_comment,
        XMLElement(EVALNAME(all_tables_prefix || ':ModelName'),m.model_name).getClobVal()                                        model_name
 FROM   dmrs_designs d, 
        dmrs_models m
 WHERE  d.design_ovid = m.design_ovid
 AND    m.model_ovid = v_m_ovid;
rec_common_data cur_common_data%ROWTYPE;

-- All Tables General Data
CURSOR cur_all_tables(v_m_ovid IN VARCHAR2) IS
 SELECT /*+ index(t TABLES_FK_IDXV1) */
        XMLElement(EVALNAME(all_tables_prefix || ':TableName'), DECODE(t.schema_name, NULL, '', t.schema_name ||'.') || t.table_name).getClobVal()  table_name,
        XMLElement(EVALNAME(all_tables_prefix || ':EncodedTableName'),t.ovid).getClobVal()															xml_ovid,
        XMLElement(EVALNAME(all_tables_prefix || ':Abbreviation'),t.abbreviation).getClobVal()                                                      abbreviation,
        XMLElement(EVALNAME(all_tables_prefix || ':ClassificationTypeName'),t.classification_type_name).getClobVal()                                class_type_name,
        XMLElement(EVALNAME(all_tables_prefix || ':ObjectTypeName'),t.structured_type_name).getClobVal()                                            obj_type_name,
        XMLElement(EVALNAME(all_tables_prefix || ':NumberOfColumns'),t.number_data_elements).getClobVal()                                           number_cols,
        XMLElement(EVALNAME(all_tables_prefix || ':NumberOfRowsMin'),t.min_volume).getClobVal()                                                     number_rows_min,
        XMLElement(EVALNAME(all_tables_prefix || ':NumberOfRowsMax'),t.max_volume).getClobVal()                                                     number_rows_max,
        XMLElement(EVALNAME(all_tables_prefix || ':ExpectedNumberOfRows'),t.expected_volume).getClobVal()                                           number_rows_expected,
        XMLElement(EVALNAME(all_tables_prefix || ':ExpectedGrowth'),t.growth_rate_percents).getClobVal()                                            growth_expected,
        XMLElement(EVALNAME(all_tables_prefix || ':GrowthInterval'),t.growth_rate_interval).getClobVal()                                            growth_interval,
        XMLElement(EVALNAME(all_tables_prefix || ':FunctionalName'), (SELECT NVL(e.entity_name,'')                        
                                              FROM   dmrs_entities e,
                                                     dmrs_mappings m
                                              WHERE  m.relational_object_ovid = t.ovid
                                              AND    m.logical_object_ovid  = e.ovid
                                              AND    ROWNUM = 1)).getClobVal()                                                                      functional_name, 
       t.ovid                                                                                                                                       table_ovid,
       COUNT(t.table_name) over()                                                                                                                   total_row_count
 FROM 	 dmrs_tables t
 WHERE  t.model_ovid = v_m_ovid
 AND    t.ovid MEMBER OF objects
 ORDER BY t.table_name;
rec_all_tables cur_all_tables%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS

 SELECT XMLElement(EVALNAME(all_tables_prefix || ':Diagram'), 
          XMLElement(EVALNAME(all_tables_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
		  XMLElement(EVALNAME(all_tables_prefix || ':Link'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf')   link,          
          XMLElement(EVALNAME(all_tables_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                              total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

-- Columns Data
CURSOR cur_columns(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':Sequence'),c.sequence).getClobVal()                                                                                              seq,
        XMLElement(EVALNAME(all_tables_prefix || ':ColumnName'),c.column_name).getClobVal()                                                                                         column_name,
        XMLElement(EVALNAME(all_tables_prefix || ':PK'),c.pk_flag).getClobVal()                                                                                                     pk,
        XMLElement(EVALNAME(all_tables_prefix || ':FK'),c.fk_flag).getClobVal()                                                                                                     fk,
        XMLElement(EVALNAME(all_tables_prefix || ':M'),DECODE(c.mandatory,'N',' ',c.mandatory)).getClobVal()                                                                        m,
        XMLElement(EVALNAME(all_tables_prefix || ':DataTypeKind'),DECODE(c.datatype_kind,                                                                                           
                                                 'Domain',         'DOM',                                                                                   
                                                 'Logical Type',   'LT',                                                                                    
                                                 'Distinct Type',  'DT',                                                                                    
                                                 'Ref Struct Type','RST',                                                                                   
                                                 'Structured Type','ST',                                                                                    
                                                 'Collection Type','CT')                                                                                    
                  ).getClobVal()                                                                                                                             dt_kind,
         XMLElement(EVALNAME(all_tables_prefix || ':DataType'), 
            DECODE(c.datatype_kind, 
                  'Domain', c.logical_type_name ||' '||
                           DECODE (NVL(c.t_size,''),'',
                              DECODE(NVL(c.t_scale,0),0,
                                 DECODE(NVL(c.t_precision,0),0,null,'('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) ||')'),
                                   '('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) || ',' || DECODE(NVL(c.t_scale,0),0,null,c.t_scale)||')'),
                                   '('||TRIM(DECODE(c.t_size,'',null,c.t_size||' '||c.char_units ))||')'),
                   'Logical Type', c.logical_type_name  ||' '|| 
                           DECODE (NVL(c.t_size,''),'',
                              DECODE(NVL(c.t_scale,0),0,
                                 DECODE(NVL(c.t_precision,0),0,null,'('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) ||')'),
                                   '('|| DECODE(NVL(c.t_precision,0),0,null,c.t_precision) || ',' || DECODE(NVL(c.t_scale,0),0,null,c.t_scale)||')'),
                                   '('||TRIM(DECODE(c.t_size,'',null,c.t_size||' '||c.char_units ))||')')
            ) ||
            DECODE (c.auto_increment_column,'Y', ' - AI','') ||
            DECODE (c.identity_column,'Y', ' - ID','')
          ).getClobVal()                                                                                                                                     data_type,
        XMLElement(EVALNAME(all_tables_prefix || ':DomainName'),DECODE(c.domain_name,'Unknown',null,c.domain_name)).getClobVal()                                                     domain_name,
        XMLElement(EVALNAME(all_tables_prefix || ':Formula'),TRIM(c.formula||' '||c.default_value)).getClobVal()                                                                     formula,
        XMLElement(EVALNAME(all_tables_prefix || ':Security'),DECODE(c.personally_id_information ||'/'||c.sensitive_information||'/'||c.mask_for_none_production,'//',
                                      null,c.personally_id_information ||'/'||c.sensitive_information||'/'||c.mask_for_none_production)).getClobVal()        security,
        XMLElement(EVALNAME(all_tables_prefix || ':PreferredAbbreviation'),c.abbreviation).getClobVal()                                                                              abbreviation,
        COUNT(c.column_name) over()                                                                                                                          total_row_count
 FROM 	dmrs_columns c
 WHERE  c.container_ovid = v_t_ovid
 ORDER BY c.sequence;
rec_columns cur_columns%ROWTYPE;

-- Columns Comments Data
CURSOR cur_columns_comments(v_t_ovid IN VARCHAR2) IS
 SELECT a.seq                       seq, 
        a.column_name               column_name, 
        a.column_description        column_description, 
        a.column_notes              column_notes,
        COUNT(a.column_name) over() total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(all_tables_prefix || ':ColumnCommentsSequence'),c.sequence).getStringVal()  seq,
         XMLElement(EVALNAME(all_tables_prefix || ':ColumnCommentsName'),c.column_name).getStringVal()   column_name,
         XMLElement(EVALNAME(all_tables_prefix || ':ColumnDescription'),XMLCDATA(
            NVL(( SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = c.ovid
                  AND    t.type='Comments'),
                ( SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = c.ovid
                  AND    t.type='CommentsInRDBMS')))).getClobVal()                                       column_description, 
         XMLElement(EVALNAME(all_tables_prefix || ':ColumnNotes'),XMLCDATA(
                ( SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = c.ovid
                  AND    t.type='Note'))).getClobVal()                                                   column_notes
  FROM   dmrs_columns c
  WHERE  c.container_ovid = v_t_ovid
  ORDER BY c.sequence
 ) a
 WHERE DBMS_LOB.getlength(column_description) > 0 OR DBMS_LOB.getlength(column_notes) > 0;
rec_columns_comments cur_columns_comments%ROWTYPE;

--Indexes
CURSOR cur_indexes(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':IndexName'),i.index_name).getClobVal()                                                                                        idx_name,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexState'),DECODE(i.state,'Unique Plain Index','UN','Unique Constraint','UK','Primary Constraint','PK',null)).getClobVal()  state,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexFunctional'),DECODE(i.functional,'N',' ',i.functional)).getClobVal()                                                     functional,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexSpatial'),DECODE(i.spatial_index,'N',' ',i.spatial_index)).getClobVal()                                                  spatial,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexExpression'),i.expression).getClobVal()                                                                                  expression,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexColumnName'),c.column_name).getClobVal()                                                                                 col_name,
        XMLElement(EVALNAME(all_tables_prefix || ':IndexSortOrder'),c.sort_order).getClobVal()                                                                                   sort_order,
        c.sequence                                                                                                                                       idx_sequence,
        COUNT(c.column_name) over()                                                                                                                      total_row_count
 FROM   dmrs_tables t,
        dmrs_indexes i,
        dmrs_constr_index_columns c
 WHERE  t.ovid = i.container_ovid
 AND    i.ovid = c.index_ovid
 AND    t.ovid = v_t_ovid
 ORDER BY i.index_name, c.sequence, c.sort_order;
rec_indexes cur_indexes%ROWTYPE;

-- Table Level Constraints
CURSOR cur_tl_constraints(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':TLConstraintType'), CASE WHEN rownum>1 THEN ''
                                               ELSE 'Table Level'
                                               END ).getClobVal()               c_type,
        XMLElement(EVALNAME(all_tables_prefix || ':TLConstraintName'), tc.constraint_name).getClobVal() c_name,
        tc.text                                                                 c_details,
        COUNT(tc.constraint_name) over()                                        total_row_count
 FROM   dmrs_table_constraints tc
 WHERE  tc.table_ovid = v_t_ovid;
rec_tl_constraints cur_tl_constraints%ROWTYPE;

-- Column Level Constraints
CURSOR cur_cl_constraints(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':ContstraintType'), CASE WHEN rownum>1 THEN ''
                                              ELSE 'Column Level'
                                              END).getClobVal()                                        c_type,
        XMLElement(EVALNAME(all_tables_prefix || ':ALCConstraintName'), c.column_name || 
                                                DECODE((SELECT DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE c.ovid = dataelement_ovid),NULL,'',
                                               ' / '|| (SELECT  DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE c.ovid = dataelement_ovid))).getClobVal() c_name,
        Gather_Constraint_Details_XML(c.ovid, all_tables_prefix)                                        c_details,
        COUNT(c.column_name) over()                                                                     total_row_count
 FROM   dmrs_columns c
 WHERE  c.container_ovid = v_t_ovid
 AND    (c.ovid IN (SELECT dataelement_ovid FROM dmrs_avt) OR 
         c.ovid IN (SELECT dataelement_ovid FROM dmrs_value_ranges) OR 
         c.ovid IN (SELECT dataelement_ovid FROM dmrs_check_constraints));
rec_cl_constraints cur_cl_constraints%ROWTYPE;

--Foreign keys referring to other tables
CURSOR cur_fk_referring_to(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':FKName'),CASE WHEN ic.sequence>1 THEN ' '
                                    ELSE fk.fk_name
                                    END
                   ).getClobVal()                                               fk_name,
        XMLElement(EVALNAME(all_tables_prefix || ':FKReferringTo'),CASE WHEN ic.sequence>1 THEN ' '
                                          ELSE fk.referred_table_name
                                          END
                  ).getClobVal()                                                referring_to,
        XMLElement(EVALNAME(all_tables_prefix || ':FKMandatory'),CASE WHEN ic.sequence>1 THEN ' '
                                         ELSE DECODE(fk.mandatory,'Y',fk.mandatory,' ')
                                         END
                  ).getClobVal()                                                mandatory,
        XMLElement(EVALNAME(all_tables_prefix || ':FKTransferable'),CASE WHEN ic.sequence>1 THEN ' '
                                            ELSE DECODE(fk.transferable,'Y',fk.transferable,' ')
                                            END
                  ).getClobVal()                                                transferable,
        XMLElement(EVALNAME(all_tables_prefix || ':FKInArc'),CASE WHEN ic.sequence>1 THEN ' '
                                     ELSE DECODE(fk.in_arc,'Y',fk.in_arc,' ')
                                     END
                  ).getClobVal()                                                in_arc,
        XMLElement(EVALNAME(all_tables_prefix || ':FKColumnName'),ic.column_name).getClobVal()          col_name,
        ic.sequence                                                             seq,
        COUNT(ic.column_name) over()                                            total_row_count
 FROM   dmrs_foreignkeys fk,
        dmrs_constr_fk_columns ic
 WHERE  fk.child_table_ovid = v_t_ovid
 AND    fk.ovid = ic.fk_ovid
 ORDER BY fk.referred_table_name,fk.fk_name, ic.sequence;
rec_fk_referring_to cur_fk_referring_to%ROWTYPE;

--Foreign keys referring from other tables
CURSOR cur_fk_referred_from(v_t_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_tables_prefix || ':FKName'),CASE WHEN ic.sequence>1 THEN ' '
                                    ELSE fk.fk_name
                                    END
                   ).getClobVal()                                               fk_name,
        XMLElement(EVALNAME(all_tables_prefix || ':FKReferredFrom'),CASE WHEN ic.sequence>1 THEN ' '
                                           ELSE fk.child_table_name
                                           END
                  ).getClobVal()                                                referred_from,
        XMLElement(EVALNAME(all_tables_prefix || ':FKMandatory'),CASE WHEN ic.sequence>1 THEN ' '
                                         ELSE DECODE(fk.mandatory,'Y',fk.mandatory,' ')
                                         END
                  ).getClobVal()                                                mandatory,
        XMLElement(EVALNAME(all_tables_prefix || ':FKTransferable'),CASE WHEN ic.sequence>1 THEN ' '
                                            ELSE DECODE(fk.transferable,'Y',fk.transferable,' ')
                                            END
                  ).getClobVal()                                                transferable,
        XMLElement(EVALNAME(all_tables_prefix || ':FKInArc'),CASE WHEN ic.sequence>1 THEN ' '
                                     ELSE DECODE(fk.in_arc,'Y',fk.in_arc,' ')
                                     END
                  ).getClobVal()                                                in_arc,
        XMLElement(EVALNAME(all_tables_prefix || ':FKColumnName'),ic.column_name).getClobVal()          col_name,
        ic.sequence                                                             seq,
        COUNT(ic.column_name) over()                                            total_row_count
 FROM   dmrs_foreignkeys fk,
        dmrs_constr_fk_columns ic
 WHERE  fk.referred_table_ovid = v_t_ovid
 AND    fk.ovid = ic.fk_ovid
 ORDER BY fk.child_table_name,fk.fk_name, ic.sequence;
rec_fk_referred_from cur_fk_referred_from%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering all tables data started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);
  DBMS_LOB.APPEND (res,'<' || all_tables_prefix || ':Tables xmlns:' || all_tables_prefix || '="http://oracle.com/datamodeler/reports/tables">');

   -- Common Data
   FOR rec_common_data IN cur_common_data(v_model_ovid) LOOP

      DBMS_LOB.APPEND (res, rec_common_data.design_name);
      DBMS_LOB.APPEND (res, rec_common_data.version_date);
      DBMS_LOB.APPEND (res, rec_common_data.version_comment);
      DBMS_LOB.APPEND (res, rec_common_data.model_name);

   END LOOP;

   FOR rec_all_tables IN cur_all_tables(v_model_ovid) LOOP

      IF (cur_all_tables%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':TablesCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':TableDetails>');

      -- Description / Notes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

         DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':DescriptionNotes>');

         SELECT 
            XMLElement(EVALNAME(all_tables_prefix || ':Description'), XMLCDATA(
               NVL((SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = rec_all_tables.table_ovid
                    AND    t.type='Comments'),
                  ( SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = rec_all_tables.table_ovid
                    AND    t.type='CommentsInRDBMS')))).getClobVal(), 
            XMLElement(EVALNAME(all_tables_prefix || ':Notes'), XMLCDATA(
                  ( SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = rec_all_tables.table_ovid
                    AND    t.type='Note'))).getClobVal()
         INTO   v_description, 
                v_notes
         FROM  dual;

        DBMS_LOB.APPEND (res, v_description);
        DBMS_LOB.APPEND (res, v_notes);
        DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':DescriptionNotes>');

      END IF;

         DBMS_LOB.APPEND (res, rec_all_tables.table_name);
         DBMS_LOB.APPEND (res, rec_all_tables.xml_ovid);
         DBMS_LOB.APPEND (res, rec_all_tables.functional_name);      
         DBMS_LOB.APPEND (res, rec_all_tables.abbreviation);
         DBMS_LOB.APPEND (res, rec_all_tables.class_type_name);
         DBMS_LOB.APPEND (res, rec_all_tables.obj_type_name);
       IF (reportTemplate.reportType = 0 OR reportTemplate.useQuantitativeInfo = 1) THEN
         DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':QuantitativeInfoCollection>');
         DBMS_LOB.APPEND (res, rec_all_tables.number_cols);
         DBMS_LOB.APPEND (res, rec_all_tables.number_rows_min);
         DBMS_LOB.APPEND (res, rec_all_tables.number_rows_max);
         DBMS_LOB.APPEND (res, rec_all_tables.number_rows_expected);
         DBMS_LOB.APPEND (res, rec_all_tables.growth_expected);
         DBMS_LOB.APPEND (res, rec_all_tables.growth_interval);
         DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':QuantitativeInfoCollection>');
       END IF;

       -- Diagrams
       IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
         FOR rec_diagrams IN cur_diagrams(rec_all_tables.table_ovid, v_report_name) LOOP
            IF (cur_diagrams%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':DiagramsCollection>');
            END IF;

              DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

            IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':DiagramsCollection>');
            END IF;
         END LOOP;
       END IF;

       -- Columns
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableColumns = 1) THEN
         FOR rec_columns IN cur_columns(rec_all_tables.table_ovid) LOOP
            IF (cur_columns%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':ColumnsCollection>');
            END IF;

              DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':ColumnDetails>');
              DBMS_LOB.APPEND (res, rec_columns.seq);
              DBMS_LOB.APPEND (res, rec_columns.column_name);
              DBMS_LOB.APPEND (res, rec_columns.pk);
              DBMS_LOB.APPEND (res, rec_columns.fk);
              DBMS_LOB.APPEND (res, rec_columns.m);
              IF (INSTR(LOWER(rec_columns.data_type),'unknown') = 0) THEN
                DBMS_LOB.APPEND (res, rec_columns.data_type);
              ELSE
                SELECT XMLElement(EVALNAME(all_tables_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
                DBMS_LOB.APPEND (res, token_value);
              END IF;
              DBMS_LOB.APPEND (res, rec_columns.dt_kind);
              DBMS_LOB.APPEND (res, rec_columns.domain_name);
              DBMS_LOB.APPEND (res, rec_columns.formula);
              DBMS_LOB.APPEND (res, rec_columns.security);
              DBMS_LOB.APPEND (res, rec_columns.abbreviation);
              DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':ColumnDetails>');

            IF (cur_columns%ROWCOUNT = rec_columns.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':ColumnsCollection>');
            END IF;
         END LOOP;
       END IF;

       -- Columns Comments
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableColumnsComments = 1) THEN
         FOR rec_columns_comments IN cur_columns_comments(rec_all_tables.table_ovid) LOOP
            IF (cur_columns_comments%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':ColumnsCommentsCollection>');
            END IF;

            DBMS_LOB.APPEND (res, '<' || all_tables_prefix || ':ColumnCommentsDetails>');
            DBMS_LOB.APPEND (res, rec_columns_comments.seq);
            DBMS_LOB.APPEND (res, rec_columns_comments.column_name);
            DBMS_LOB.APPEND (res, rec_columns_comments.column_description);
            DBMS_LOB.APPEND (res, rec_columns_comments.column_notes);
            DBMS_LOB.APPEND (res,'</' || all_tables_prefix || ':ColumnCommentsDetails>');

            IF (cur_columns_comments%ROWCOUNT = rec_columns_comments.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':ColumnsCommentsCollection>');
            END IF;
         END LOOP;
       END IF;

       -- Indexes
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableIndexes = 1) THEN
       		FOR rec_indexes IN cur_indexes(rec_all_tables.table_ovid) LOOP
       		   IF (cur_indexes%ROWCOUNT = 1) THEN
       		     DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':IndexesCollection>');
       		   END IF;

       		     DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':IndexDetails>');
       		     DBMS_LOB.APPEND (res, rec_indexes.idx_name);
       		     DBMS_LOB.APPEND (res, rec_indexes.state);
       		     DBMS_LOB.APPEND (res, rec_indexes.functional);
       		     DBMS_LOB.APPEND (res, rec_indexes.spatial);
       		     DBMS_LOB.APPEND (res, rec_indexes.expression);
       		     DBMS_LOB.APPEND (res, rec_indexes.col_name);
       		     DBMS_LOB.APPEND (res, rec_indexes.sort_order);
       		     DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':IndexDetails>');

       		   IF (cur_indexes%ROWCOUNT = rec_indexes.total_row_count) THEN
       		    DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':IndexesCollection>');
       		   END IF;
       		END LOOP;
       END IF;

       v_cc_created := FALSE;
       -- Constraints
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableConstraints = 1) THEN
         -- Table Level Constraints
         FOR rec_tl_constraints IN cur_tl_constraints(rec_all_tables.table_ovid) LOOP
            IF (cur_tl_constraints%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':ConstraintsCollection>');
              v_cc_created := TRUE;
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':TableLevelConstraintsCollection>');
            END IF;

            DBMS_LOB.APPEND (res, '<' || all_tables_prefix || ':TableLevelConstraintDetails>');
            DBMS_LOB.APPEND (res, rec_tl_constraints.c_type);
            DBMS_LOB.APPEND (res, rec_tl_constraints.c_name);
            DBMS_LOB.APPEND (res, rec_tl_constraints.c_details);
            DBMS_LOB.APPEND (res, '</' || all_tables_prefix || ':TableLevelConstraintDetails>');

            IF (cur_tl_constraints%ROWCOUNT = rec_tl_constraints.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':TableLevelConstraintsCollection>');
            END IF;

         END LOOP;

         -- Column Level Constraints
         FOR rec_cl_constraints IN cur_cl_constraints(rec_all_tables.table_ovid) LOOP
            IF (cur_cl_constraints%ROWCOUNT = 1) THEN
              IF NOT v_cc_created THEN
                 DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':ConstraintsCollection>');
                 v_cc_created := TRUE;
              END IF;

             DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':ColumnLevelConstraintsCollection>');
             v_cc_created := TRUE;
            END IF;

             DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':ConstraintDetails>');
             DBMS_LOB.APPEND (res, rec_cl_constraints.c_type);
             DBMS_LOB.APPEND (res, rec_cl_constraints.c_name);
             DBMS_LOB.APPEND (res, rec_cl_constraints.c_details);
             DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':ConstraintDetails>');

            IF (cur_cl_constraints%ROWCOUNT = rec_cl_constraints.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':ColumnLevelConstraintsCollection>');
            END IF;
         END LOOP;

         IF v_cc_created THEN
           DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':ConstraintsCollection>');
         END IF;
       END IF;

       -- Foreign Keys Referring To
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableFKReferringTo = 1) THEN
         FOR rec_fk_referring_to IN cur_fk_referring_to(rec_all_tables.table_ovid) LOOP
            IF (cur_fk_referring_to%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':FKRTCollection>');
            END IF;

             DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':FKRTDetails>');
             DBMS_LOB.APPEND (res, rec_fk_referring_to.fk_name);
             DBMS_LOB.APPEND (res, rec_fk_referring_to.referring_to);
             DBMS_LOB.APPEND (res, rec_fk_referring_to.mandatory);
             DBMS_LOB.APPEND (res, rec_fk_referring_to.transferable);
             DBMS_LOB.APPEND (res, rec_fk_referring_to.in_arc);
             DBMS_LOB.APPEND (res, rec_fk_referring_to.col_name);
             DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':FKRTDetails>');

            IF (cur_fk_referring_to%ROWCOUNT = rec_fk_referring_to.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':FKRTCollection>');
            END IF;
         END LOOP;
      END IF;

       -- Foreign Keys Referred From
       IF (reportTemplate.reportType = 0 OR reportTemplate.useTableFKReferredFrom = 1) THEN         
         FOR rec_fk_referred_from IN cur_fk_referred_from(rec_all_tables.table_ovid) LOOP
            IF (cur_fk_referred_from%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<'||all_tables_prefix||':FKRFCollection>');
            END IF;

             DBMS_LOB.APPEND (res, '<'||all_tables_prefix||':FKRFDetails>');
             DBMS_LOB.APPEND (res, rec_fk_referred_from.fk_name);
             DBMS_LOB.APPEND (res, rec_fk_referred_from.referred_from);
             DBMS_LOB.APPEND (res, rec_fk_referred_from.mandatory);
             DBMS_LOB.APPEND (res, rec_fk_referred_from.transferable);
             DBMS_LOB.APPEND (res, rec_fk_referred_from.in_arc);
             DBMS_LOB.APPEND (res, rec_fk_referred_from.col_name);
             DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':FKRFDetails>');

            IF (cur_fk_referred_from%ROWCOUNT = rec_fk_referred_from.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</'||all_tables_prefix||':FKRFCollection>');
            END IF;
         END LOOP;
       END IF;

      DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':TableDetails>');

      IF (cur_all_tables%ROWCOUNT = rec_all_tables.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':TablesCollection>');
      END IF;

   END LOOP;

  DBMS_LOB.APPEND (res,'</'||all_tables_prefix||':Tables>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering all tables data ended.');

RETURN res;

 EXCEPTION
  WHEN others THEN
   UTL_FILE.PUT_LINE(log_file, 'Gathering all tables Exception : : ' || SQLERRM);  
   UTL_FILE.PUT_LINE(log_file, 'Gathering all tables Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllTables_Data;

FUNCTION Gather_SingleEntity_Data(v_entity_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, v_report_name IN VARCHAR2) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;

CURSOR cur_general_data(v_e_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(single_entity_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(single_entity_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(single_entity_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m,
        dmrs_entities e
 WHERE  d.design_ovid = m.design_ovid
 AND    e.model_ovid = m.model_ovid
 AND    e.ovid = v_e_ovid;
rec_general_data cur_general_data%ROWTYPE;

CURSOR cur_entity(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':EntityName'),e.entity_name).getClobVal()                                                                        entity_name,
        XMLElement(EVALNAME(single_entity_prefix || ':ClassificationTypeName'),e.classification_type_name).getClobVal()                                               classification_type_name,
        XMLElement(EVALNAME(single_entity_prefix || ':Abbreviation'),e.preferred_abbreviation).getClobVal()                                                           pref_abbreviation, 
        XMLElement(EVALNAME(single_entity_prefix || ':SuperType'),(SELECT e1.entity_name FROM  dmrs_entities e1 WHERE e.supertypeentity_ovid = e1.ovid)).getClobVal() super_type,
        XMLElement(EVALNAME(single_entity_prefix || ':Synonyms'), e.synonyms).getClobVal()                                                                            table_synonyms,
        XMLElement(EVALNAME(single_entity_prefix || ':ObjectTypeName'),e.structured_type_name).getClobVal()                                                           object_type_name,
        XMLElement(EVALNAME(single_entity_prefix || ':NumberOfAttributes'),e.number_data_elements).getClobVal()                                                       number_of_attributes, 
        XMLElement(EVALNAME(single_entity_prefix || ':NumberOfRowsMin'),e.min_volume).getClobVal()                                                                    number_rows_min, 
        XMLElement(EVALNAME(single_entity_prefix || ':NumberOfRowsMax'),e.max_volume).getClobVal()                                                                    number_rows_max, 
        XMLElement(EVALNAME(single_entity_prefix || ':ExpectedNumberOfRows'),e.expected_volume).getClobVal()                                                          expected_number_of_rows, 
        XMLElement(EVALNAME(single_entity_prefix || ':ExpectedGrowth'),e.growth_rate_percents).getClobVal()                                                           expected_growth,
        XMLElement(EVALNAME(single_entity_prefix || ':GrowthInterval'),e.growth_rate_interval).getClobVal()                                                           growth_interval
 FROM   dmrs_entities e
 WHERE  e.ovid = v_e_ovid;
rec_entity cur_entity%ROWTYPE;

CURSOR cur_mapped_tables(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':TableName'),t.model_name||'.'||t.table_name).getClobVal() table_name,
        COUNT(t.table_name) over()                                total_row_count
 FROM   dmrs_entities e,
        dmrs_tables t,
        dmrs_mappings m
 WHERE  m.relational_object_ovid = t.ovid
 AND    m.logical_object_ovid = e.ovid
 AND    e.ovid = v_e_ovid;
rec_mapped_tables cur_mapped_tables%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':Diagram'), 
          XMLElement(EVALNAME(single_entity_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
          XMLElement(EVALNAME(single_entity_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                                 total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

-- Attributes
CURSOR cur_attributes(v_e_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(single_entity_prefix || ':Sequence'),a.sequence).getClobVal()                                                                                             seq, 
         XMLElement(EVALNAME(single_entity_prefix || ':AttributeName'),a.attribute_name).getClobVal()                                                                                  attr_name,
         XMLElement(EVALNAME(single_entity_prefix || ':DataTypeKind'),DECODE(a.datatype_kind,
                                                 'Domain',         'DOM',
                                                 'Logical Type',   'LT',
                                                 'Distinct Type',  'DT',
                                                 'Ref Struct Type','RST',
                                                 'Structured Type','ST',
                                                 'Collection Type','CT')                                                                                
                   ).getClobVal()                                                                                                                           dt_kind,
         XMLElement(EVALNAME(single_entity_prefix || ':DomainName'),DECODE(a.domain_name,'Unknown',null,a.domain_name)).getClobVal()                                                   domain_name,
         XMLElement(EVALNAME(single_entity_prefix || ':DataType'), 
            DECODE(a.datatype_kind, 
                  'Domain', a.logical_type_name ||' '||
                           DECODE (NVL(a.t_size,''),'',
                              DECODE(NVL(a.t_scale,0),0,
                                 DECODE(NVL(a.t_precision,0),0,null,'('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) ||')'),
                                   '('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) || ',' || DECODE(NVL(a.t_scale,0),0,null,a.t_scale)||')'),
                                   '('||TRIM(DECODE(a.t_size,'',null,a.t_size||' '||a.char_units ))||')'),
                   'Logical Type', a.logical_type_name  ||' '|| 
                           DECODE (NVL(a.t_size,''),'',
                              DECODE(NVL(a.t_scale,0),0,
                                 DECODE(NVL(a.t_precision,0),0,null,'('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) ||')'),
                                   '('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) || ',' || DECODE(NVL(a.t_scale,0),0,null,a.t_scale)||')'),
                                   '('||TRIM(DECODE(a.t_size,'',null,a.t_size||' '||a.char_units ))||')')
            )
          ).getClobVal()                                                                                                                                   data_type,
         XMLElement(EVALNAME(single_entity_prefix || ':PK'),a.pk_flag).getClobVal()                                                                                                    pk,
         XMLElement(EVALNAME(single_entity_prefix || ':FK'),a.fk_flag).getClobVal()                                                                                                    fk,
         XMLElement(EVALNAME(single_entity_prefix || ':M'),DECODE(a.mandatory,'N',' ',a.mandatory)).getClobVal()                                                                       m,
         XMLElement(EVALNAME(single_entity_prefix || ':Formula'),TRIM(a.formula||' '||a.default_value)).getClobVal()                                                                   formula,
         XMLElement(EVALNAME(single_entity_prefix || ':AttributeSynonyms'),a.synonyms).getClobVal()                                                                                    synonyms,
         XMLElement(EVALNAME(single_entity_prefix || ':PreferredAbbreviation'),a.preferred_abbreviation).getClobVal()                                                                  pref_abbr,
         COUNT(a.sequence) over()                                                                                                                           total_row_count
  FROM   dmrs_attributes a
  WHERE  a.container_ovid = v_e_ovid
  ORDER BY a.sequence;
rec_attributes cur_attributes%ROWTYPE;

-- Attributes Comments Data
CURSOR cur_attributes_comments(v_e_ovid IN VARCHAR2) IS
 SELECT a.seq                          seq, 
        a.attribute_name               attribute_name, 
        a.attribute_description        attribute_description, 
        a.attribute_notes              attribute_notes,
        COUNT(a.attribute_name) over() total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(single_entity_prefix || ':AttributeCommentsSequence'),a.sequence).getStringVal()     seq,
         XMLElement(EVALNAME(single_entity_prefix || ':AttributeCommentsName'),a.attribute_name).getStringVal()   attribute_name,
         XMLElement(EVALNAME(single_entity_prefix || ':AttributeDescription'),XMLCDATA(
         NVL(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='Comments'),
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='CommentsInRDBMS')))).getClobVal()                                                         attribute_description, 
        XMLElement(EVALNAME(single_entity_prefix || ':AttributeNotes'),XMLCDATA(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='Note'))).getClobVal()                                                                     attribute_notes
  FROM   dmrs_entities e, 
         dmrs_attributes a
  WHERE  e.ovid = a.container_ovid
  and    e.ovid = v_e_ovid
  ORDER BY a.sequence
 ) a
 WHERE DBMS_LOB.getlength(attribute_description) > 0 OR DBMS_LOB.getlength(attribute_notes) > 0;
rec_attributes_comments cur_attributes_comments%ROWTYPE;

CURSOR cur_identifiers(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':IdentifierName'),CASE WHEN ke.sequence>1 THEN ' ' ELSE ke.key_name END).getClobVal()                          nn,
        XMLElement(EVALNAME(single_entity_prefix || ':PrimaryIdentifier'),CASE WHEN ke.sequence>1 THEN ' ' ELSE DECODE(k.state,'Primary Key','Y') END).getClobVal() pi, 
        XMLElement(EVALNAME(single_entity_prefix || ':ElementName'),ke.element_name).getClobVal()                                                                   element_name,
        XMLElement(EVALNAME(single_entity_prefix || ':ElementType'),ke.type).getClobVal()                                                                           type,
        XMLElement(EVALNAME(single_entity_prefix || ':SourceLabel'),ke.source_label).getClobVal()                                                                   source_label,
        XMLElement(EVALNAME(single_entity_prefix || ':TargetLabel'),ke.target_label).getClobVal()                                                                   target_label,
        COUNT(ke.sequence) over()                                                                                                        total_row_count
 FROM   dmrs_keys          k,
        dmrs_key_elements ke
 WHERE  k.container_ovid = v_e_ovid
 AND   ke.key_ovid = k.ovid
 ORDER BY ke.sequence;
rec_identifiers cur_identifiers%ROWTYPE;

CURSOR cur_relationships(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':SourceName'),r.target_entity_name).getClobVal()                                                                  source_name, 
        XMLElement(EVALNAME(single_entity_prefix || ':SourceRole'),r.source_label).getClobVal()                                                                        source_role,
        XMLElement(EVALNAME(single_entity_prefix || ':TargetRole'),r.target_label).getClobVal()                                                                        target_role,
        XMLElement(EVALNAME(single_entity_prefix || ':InArc'),DECODE(r.in_arc,'N','',r.in_arc)).getClobVal()                                                           in_arc,
        XMLElement(EVALNAME(single_entity_prefix || ':Cardinality'),
           DECODE(r.source_optional,'Y',0,'1') || '..' || r.sourceto_target_cardinality
           ||':'||
           DECODE(r.target_optional,'Y',0,'1') || '..' || r.targetto_source_cardinality
           ).getClobVal()                                                                                                                  cardinality,
        XMLElement(EVALNAME(single_entity_prefix || ':DominantRole'),DECODE(r.dominant_role,'None','')).getClobVal()                                                   dominant_role,
        XMLElement(EVALNAME(single_entity_prefix || ':Identifying'),DECODE(r.identifying,'N','',r.identifying)).getClobVal()                                           identifying,
        XMLElement(EVALNAME(single_entity_prefix || ':Transferable'),DECODE(r.transferable,'N','',r.transferable)).getClobVal()                                        transferable
 FROM   dmrs_relationships r
 WHERE  r.source_ovid  = v_e_ovid
 UNION ALL
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':SourceName'),r.source_entity_name).getClobVal()                                                                  source_name, 
        XMLElement(EVALNAME(single_entity_prefix || ':SourceRole'),r.source_label).getClobVal()                                                                        source_role,
        XMLElement(EVALNAME(single_entity_prefix || ':TargetRole'),r.target_label).getClobVal()                                                                        target_role,
        XMLElement(EVALNAME(single_entity_prefix || ':InArc'),DECODE(r.in_arc,'N','',r.in_arc)).getClobVal()                                                           in_arc,
        XMLElement(EVALNAME(single_entity_prefix || ':Cardinality'),
           DECODE(r.source_optional,'Y',0,'1') || '..' || r.sourceto_target_cardinality
           ||':'||
           DECODE(r.target_optional,'Y',0,'1') || '..' || r.targetto_source_cardinality
           ).getClobVal()                                                                                                                  cardinality,
        XMLElement(EVALNAME(single_entity_prefix || ':DominantRole'),DECODE(r.dominant_role,'None','')).getClobVal()                                                   dominant_role,
        XMLElement(EVALNAME(single_entity_prefix || ':Identifying'),DECODE(r.identifying,'N','',r.identifying)).getClobVal()                                           identifying,
        XMLElement(EVALNAME(single_entity_prefix || ':Transferable'),DECODE(r.transferable,'N','',r.transferable)).getClobVal()                                        transferable
 FROM   dmrs_relationships r
 WHERE  r.target_ovid  = v_e_ovid;
rec_relationships cur_relationships%ROWTYPE;

CURSOR cur_incoming_processes(v_e_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(single_entity_prefix || ':IncomingProcessName'), NVL(pe.process_name,' ')).getClobVal()  ipr_name,
         XMLElement(EVALNAME(single_entity_prefix || ':IncomingFlowName'), NVL(pe.flow_name,' ')).getClobVal()       ipr_flow_name,
         XMLElement(EVALNAME(single_entity_prefix || ':IncomingCRUDCode'), NVL(pe.crud_code,' ')).getClobVal()       ipr_crud_code,
         XMLElement(EVALNAME(single_entity_prefix || ':IncomingDFDName'), NVL(pe.dfd_name,' ')).getClobVal()         ipr_dfd_name,
         COUNT(pe.process_name) over()                                                    total_row_count
  FROM   dmrs_process_entities pe
  WHERE  pe.entity_ovid = v_e_ovid
  AND    pe.flow_direction = 'IN'
  ORDER BY pe.process_name;
rec_incoming_processes cur_incoming_processes%ROWTYPE;

CURSOR cur_outgoing_processes(v_e_ovid IN VARCHAR2) IS
  SELECT XMLElement(EVALNAME(single_entity_prefix || ':OutgoingProcessName'), pe.process_name).getClobVal() opr_name,
         XMLElement(EVALNAME(single_entity_prefix || ':OutgoingFlowName'), pe.flow_name).getClobVal()       opr_flow_name,
         XMLElement(EVALNAME(single_entity_prefix || ':OutgoingCRUDCode'), pe.crud_code).getClobVal()       opr_crud_code,
         XMLElement(EVALNAME(single_entity_prefix || ':OutgoingDFDName'), pe.dfd_name).getClobVal()         opr_dfd_name,
         COUNT(pe.process_name) over()                                           total_row_count
  FROM   dmrs_process_entities pe
  WHERE  pe.entity_ovid = v_e_ovid
  AND    pe.flow_direction = 'OUT'
  ORDER BY pe.process_name;
rec_outgoing_processes cur_outgoing_processes%ROWTYPE;

-- Constraints
CURSOR cur_constraints(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_entity_prefix || ':ContstraintType'), CASE WHEN rownum>1 THEN ''
                                              ELSE 'Attribute Level'
                                              END).getClobVal()                                        c_type,
        XMLElement(EVALNAME(single_entity_prefix || ':ALCConstraintName'), a.attribute_name || 
                                                DECODE((SELECT DISTINCT(constraint_name)
                                                        FROM dmrs_check_constraints 
                                                        WHERE a.ovid = dataelement_ovid),NULL,'',
                                               ' / '|| (SELECT  DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE a.ovid = dataelement_ovid))).getClobVal() c_name,
        Gather_Constraint_Details_XML(a.ovid, single_entity_prefix)                                     c_details,
        COUNT(a.attribute_name) over()                                                                  total_row_count
 FROM   dmrs_attributes a
 WHERE a.container_ovid = v_e_ovid
 AND  (a.ovid IN (SELECT dataelement_ovid FROM dmrs_avt) OR 
       a.ovid IN (SELECT dataelement_ovid FROM dmrs_value_ranges) OR 
       a.ovid IN (SELECT dataelement_ovid FROM dmrs_check_constraints));
rec_constraints cur_constraints%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering single entity data started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':Entity xmlns:' || single_entity_prefix || '="http://oracle.com/datamodeler/reports/entity">');

   FOR rec_general_data IN cur_general_data(v_entity_ovid) LOOP

      DBMS_LOB.APPEND (res, rec_general_data.design_name);
      DBMS_LOB.APPEND (res, rec_general_data.version_date);
      DBMS_LOB.APPEND (res, rec_general_data.version_comment);
      DBMS_LOB.APPEND (res, rec_general_data.model_name);

   END LOOP;

   -- Mapped tables
   FOR rec_mapped_tables IN cur_mapped_tables(v_entity_ovid) LOOP
      IF (cur_mapped_tables%ROWCOUNT = 1) THEN
        DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':MappedTablesCollection>');
      END IF;

        DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':MappedTablesDetails>');
        DBMS_LOB.APPEND (res, rec_mapped_tables.table_name);
        DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':MappedTablesDetails>');

      IF (cur_mapped_tables%ROWCOUNT = rec_mapped_tables.total_row_count) THEN
        DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':MappedTablesCollection>');
      END IF;
   END LOOP;

   -- Description / Notes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

    DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':DescriptionNotes>');

    SELECT  XMLElement(EVALNAME(single_entity_prefix || ':Description'), XMLCDATA(
              NVL((SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_entity_ovid
                    AND    t.type='Comments'),
                   (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_entity_ovid
                    AND    t.type='CommentsInRDBMS')))).getClobVal(), 
            XMLElement(EVALNAME(single_entity_prefix || ':Notes'), XMLCDATA(
                    (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_entity_ovid
                    AND    t.type='Note'))).getClobVal()
    INTO    v_description, 
            v_notes
    FROM  dual;

    DBMS_LOB.APPEND (res, v_description);
    DBMS_LOB.APPEND (res, v_notes);

    DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':DescriptionNotes>');

   END IF;

   FOR rec_entity IN cur_entity(v_entity_ovid) LOOP
      DBMS_LOB.APPEND (res, rec_entity.entity_name);
      DBMS_LOB.APPEND (res, rec_entity.pref_abbreviation);      
      DBMS_LOB.APPEND (res, rec_entity.classification_type_name);
      DBMS_LOB.APPEND (res, rec_entity.object_type_name);
      DBMS_LOB.APPEND (res, rec_entity.super_type);
      DBMS_LOB.APPEND (res, rec_entity.table_synonyms);
      IF (reportTemplate.reportType = 0 OR reportTemplate.useQuantitativeInfo = 1) THEN
        DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':QuantitativeInfoCollection>');
        DBMS_LOB.APPEND (res, rec_entity.number_of_attributes);
        DBMS_LOB.APPEND (res, rec_entity.number_rows_min);
        DBMS_LOB.APPEND (res, rec_entity.number_rows_max);
        DBMS_LOB.APPEND (res, rec_entity.expected_number_of_rows);
        DBMS_LOB.APPEND (res, rec_entity.expected_growth);
        DBMS_LOB.APPEND (res, rec_entity.growth_interval);
        DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':QuantitativeInfoCollection>');
      END IF;
   END LOOP;

   -- Diagrams
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
     FOR rec_diagrams IN cur_diagrams(v_entity_ovid, v_report_name) LOOP
        IF (cur_diagrams%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':DiagramsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

        IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':DiagramsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Attributes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityAttributes = 1) THEN
     FOR rec_attributes IN cur_attributes(v_entity_ovid) LOOP
        IF (cur_attributes%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':AttributesCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':AttributeDetails>');
          DBMS_LOB.APPEND (res, rec_attributes.seq);
          DBMS_LOB.APPEND (res, rec_attributes.attr_name);
          DBMS_LOB.APPEND (res, rec_attributes.pk);
          DBMS_LOB.APPEND (res, rec_attributes.fk);
          DBMS_LOB.APPEND (res, rec_attributes.m);
          IF (INSTR(LOWER(rec_attributes.data_type),'unknown') = 0) THEN
             DBMS_LOB.APPEND (res, rec_attributes.data_type);
          ELSE
             SELECT XMLElement(EVALNAME(single_entity_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
             DBMS_LOB.APPEND (res, token_value);
          END IF;
          DBMS_LOB.APPEND (res, rec_attributes.dt_kind);
          DBMS_LOB.APPEND (res, rec_attributes.domain_name);
          DBMS_LOB.APPEND (res, rec_attributes.formula);
          DBMS_LOB.APPEND (res, rec_attributes.pref_abbr);
          DBMS_LOB.APPEND (res, rec_attributes.synonyms);
          DBMS_LOB.APPEND (res,'</' || single_entity_prefix || ':AttributeDetails>');

        IF (cur_attributes%ROWCOUNT = rec_attributes.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':AttributesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Attribute Comments
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityAttributesComments = 1) THEN
     FOR rec_attributes_comments IN cur_attributes_comments(v_entity_ovid) LOOP
        IF (cur_attributes_comments%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':AttributesCommentsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':AttributeCommentsDetails>');
          DBMS_LOB.APPEND (res, rec_attributes_comments.seq);
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_name);
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_description);
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_notes);
          DBMS_LOB.APPEND (res,'</' || single_entity_prefix || ':AttributeCommentsDetails>');

        IF (cur_attributes_comments%ROWCOUNT = rec_attributes_comments.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':AttributesCommentsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Constraints
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityConstraints = 1) THEN
     FOR rec_constraints IN cur_constraints(v_entity_ovid) LOOP
        IF (cur_constraints%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':ConstraintsCollection>');
        END IF;

          DBMS_LOB.APPEND (res,'<' || single_entity_prefix || ':ConstraintDetails>');
          DBMS_LOB.APPEND (res,rec_constraints.c_type);
          DBMS_LOB.APPEND (res,rec_constraints.c_name);
          DBMS_LOB.APPEND (res,rec_constraints.c_details);
          DBMS_LOB.APPEND (res,'</' || single_entity_prefix || ':ConstraintDetails>');

        IF (cur_constraints%ROWCOUNT = rec_constraints.total_row_count) THEN
            DBMS_LOB.APPEND (res,'</' || single_entity_prefix || ':ConstraintsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Identifiers
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityIdentifiers = 1) THEN
     FOR rec_identifiers IN cur_identifiers(v_entity_ovid) LOOP
        IF (cur_identifiers%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':IdentifiersCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':IdentifierDetails>');
          DBMS_LOB.APPEND (res, rec_identifiers.nn);
          DBMS_LOB.APPEND (res, rec_identifiers.pi);
          DBMS_LOB.APPEND (res, rec_identifiers.element_name);
          DBMS_LOB.APPEND (res, rec_identifiers.type);
          DBMS_LOB.APPEND (res, rec_identifiers.source_label);
          DBMS_LOB.APPEND (res, rec_identifiers.target_label);
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':IdentifierDetails>');

        IF (cur_identifiers%ROWCOUNT = rec_identifiers.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':IdentifiersCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Relationships
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityRelationships = 1) THEN
     -- Total count of relationships
     SELECT COUNT(1)
     INTO   v_rel_total_count
     FROM (
      SELECT r.ovid
      FROM   dmrs_relationships r,
             dmrs_entities      e
      WHERE  r.source_ovid  = e.ovid
      AND    e.ovid         = v_entity_ovid
      UNION ALL
      SELECT r.ovid
      FROM   dmrs_relationships r,
             dmrs_entities      e
      WHERE  r.target_ovid  = e.ovid
      AND    e.ovid         = v_entity_ovid);

     FOR rec_relationships IN cur_relationships(v_entity_ovid) LOOP
        IF (cur_relationships%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':RelationshipsCollection>');
        END IF;

           DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':RelationshipDetails>');
           DBMS_LOB.APPEND (res, rec_relationships.source_name);
           DBMS_LOB.APPEND (res, rec_relationships.source_role);
           DBMS_LOB.APPEND (res, rec_relationships.target_role);
           DBMS_LOB.APPEND (res, rec_relationships.in_arc);
           DBMS_LOB.APPEND (res, rec_relationships.cardinality);
           DBMS_LOB.APPEND (res, rec_relationships.dominant_role);
           DBMS_LOB.APPEND (res, rec_relationships.identifying);
           DBMS_LOB.APPEND (res, rec_relationships.transferable);
           DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':RelationshipDetails>');

        IF (cur_relationships%ROWCOUNT = v_rel_total_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':RelationshipsCollection>');
        END IF;

     END LOOP;
   END IF;

   -- Incoming Processes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityIncomingProcesses = 1) THEN
     FOR rec_incoming_processes IN cur_incoming_processes(v_entity_ovid) LOOP
        IF (cur_incoming_processes%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':IncomingProcessesCollection>');
        END IF;
          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':IncomingProcessDetails>');
          DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_name);
          DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_flow_name);
          DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_crud_code);
          DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_dfd_name);
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':IncomingProcessDetails>');
        IF (cur_incoming_processes%ROWCOUNT = rec_incoming_processes.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':IncomingProcessesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Outgoing Processes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityOutgoingProcesses = 1) THEN
     FOR rec_outgoing_processes IN cur_outgoing_processes(v_entity_ovid) LOOP
        IF (cur_outgoing_processes%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':OutgoingProcessesCollection>');
        END IF;
          DBMS_LOB.APPEND (res, '<' || single_entity_prefix || ':OugoingProcessDetails>');
          DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_name);
          DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_flow_name);
          DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_crud_code);
          DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_dfd_name);
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':OugoingProcessDetails>');
        IF (cur_outgoing_processes%ROWCOUNT = rec_outgoing_processes.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_entity_prefix || ':OutgoingProcessesCollection>');
        END IF;
     END LOOP;
  END IF;

  DBMS_LOB.APPEND (res,'</' || single_entity_prefix || ':Entity>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering single entity data ended');

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleEntity_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleEntity_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_SingleEntity_Data;

FUNCTION Gather_AllEntities_Data(v_model_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, objects IN OBJECTS_LIST, v_report_name IN VARCHAR2) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;

CURSOR cur_general_data(v_m_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_entities_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_entities_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(all_entities_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m
 WHERE  d.design_ovid = m.design_ovid
 AND    m.model_ovid = v_model_ovid;
rec_general_data cur_general_data%ROWTYPE;

CURSOR cur_all_entities(v_m_ovid IN VARCHAR2) IS
 SELECT /*+ index(e ENTITIES_FK_IDXV1) */
        XMLElement(EVALNAME(all_entities_prefix || ':EntityName'),e.entity_name).getClobVal()                                                                        entity_name,
        XMLElement(EVALNAME(all_entities_prefix || ':EncodedEntityName'),e.ovid).getClobVal()																		 xml_ovid,
        XMLElement(EVALNAME(all_entities_prefix || ':ClassificationTypeName'),e.classification_type_name).getClobVal()                                               classification_type_name,
        XMLElement(EVALNAME(all_entities_prefix || ':Abbreviation'),e.preferred_abbreviation).getClobVal()                                                           pref_abbreviation, 
        XMLElement(EVALNAME(all_entities_prefix || ':SuperType'),(SELECT e1.entity_name FROM  dmrs_entities e1 WHERE e.supertypeentity_ovid = e1.ovid)).getClobVal() super_type,
        XMLElement(EVALNAME(all_entities_prefix || ':Synonyms'), e.synonyms).getClobVal()                                                                            table_synonyms,
        XMLElement(EVALNAME(all_entities_prefix || ':ObjectTypeName'),e.structured_type_name).getClobVal()                                                           object_type_name,
        XMLElement(EVALNAME(all_entities_prefix || ':NumberOfAttributes'),e.number_data_elements).getClobVal()                                                       number_of_attributes, 
        XMLElement(EVALNAME(all_entities_prefix || ':NumberOfRowsMin'),e.min_volume).getClobVal()                                                                    number_rows_min, 
        XMLElement(EVALNAME(all_entities_prefix || ':NumberOfRowsMax'),e.max_volume).getClobVal()                                                                    number_rows_max, 
        XMLElement(EVALNAME(all_entities_prefix || ':ExpectedNumberOfRows'),e.expected_volume).getClobVal()                                                          expected_number_of_rows, 
        XMLElement(EVALNAME(all_entities_prefix || ':ExpectedGrowth'),e.growth_rate_percents).getClobVal()                                                           expected_growth,
        XMLElement(EVALNAME(all_entities_prefix || ':GrowthInterval'),e.growth_rate_interval).getClobVal()                                                           growth_interval,
        e.ovid                                                                                                                             entity_ovid,
        COUNT(e.entity_name) over() total_row_count
 FROM   dmrs_entities    e
 WHERE  e.model_ovid = v_m_ovid
 AND    e.ovid MEMBER OF objects
 ORDER BY e.entity_name;
rec_all_entities cur_all_entities%ROWTYPE;

CURSOR cur_mapped_tables(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':TableName'),t.model_name||'.'||t.table_name).getClobVal() table_name,
        COUNT(t.table_name) over()                                total_row_count
 FROM   dmrs_entities e,
        dmrs_tables t,
        dmrs_mappings m
 WHERE  m.relational_object_ovid = t.ovid
 AND    m.logical_object_ovid = e.ovid
 AND    e.ovid = v_e_ovid;
rec_mapped_tables cur_mapped_tables%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':Diagram'), 
          XMLElement(EVALNAME(all_entities_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
          XMLElement(EVALNAME(all_entities_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                                total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

-- Attributes
CURSOR cur_attributes(v_e_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(all_entities_prefix || ':Sequence'),a.sequence).getClobVal()                                                                                              seq, 
         XMLElement(EVALNAME(all_entities_prefix || ':AttributeName'),a.attribute_name).getClobVal()                                                                                  attr_name,
         XMLElement(EVALNAME(all_entities_prefix || ':DataTypeKind'),DECODE(a.datatype_kind,
                                                 'Domain',         'DOM',
                                                 'Logical Type',   'LT',
                                                 'Distinct Type',  'DT',
                                                 'Ref Struct Type','RST',
                                                 'Structured Type','ST',
                                                 'Collection Type','CT')                                                                                
                   ).getClobVal()                                                                                                                           dt_kind,
         XMLElement(EVALNAME(all_entities_prefix || ':DomainName'),DECODE(a.domain_name,'Unknown',null,a.domain_name)).getClobVal()                                                   domain_name,
         XMLElement(EVALNAME(all_entities_prefix || ':DataType'), 
            DECODE(a.datatype_kind, 
                  'Domain', a.logical_type_name ||' '||
                           DECODE (NVL(a.t_size,''),'',
                              DECODE(NVL(a.t_scale,0),0,
                                 DECODE(NVL(a.t_precision,0),0,null,'('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) ||')'),
                                   '('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) || ',' || DECODE(NVL(a.t_scale,0),0,null,a.t_scale)||')'),
                                   '('||TRIM(DECODE(a.t_size,'',null,a.t_size||' '||a.char_units ))||')'),
                   'Logical Type', a.logical_type_name  ||' '|| 
                           DECODE (NVL(a.t_size,''),'',
                              DECODE(NVL(a.t_scale,0),0,
                                 DECODE(NVL(a.t_precision,0),0,null,'('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) ||')'),
                                   '('|| DECODE(NVL(a.t_precision,0),0,null,a.t_precision) || ',' || DECODE(NVL(a.t_scale,0),0,null,a.t_scale)||')'),
                                   '('||TRIM(DECODE(a.t_size,'',null,a.t_size||' '||a.char_units ))||')')
            )
          ).getClobVal()                                                                                                                                    data_type,
         XMLElement(EVALNAME(all_entities_prefix || ':PK'),a.pk_flag).getClobVal()                                                                                                    pk,
         XMLElement(EVALNAME(all_entities_prefix || ':FK'),a.fk_flag).getClobVal()                                                                                                    fk,
         XMLElement(EVALNAME(all_entities_prefix || ':M'),DECODE(a.mandatory,'N',' ',a.mandatory)).getClobVal()                                                                       m,
         XMLElement(EVALNAME(all_entities_prefix || ':Formula'),TRIM(a.formula||' '||a.default_value)).getClobVal()                                                                   formula,
         XMLElement(EVALNAME(all_entities_prefix || ':AttributeSynonyms'),a.synonyms).getClobVal()                                                                                    synonyms,
         XMLElement(EVALNAME(all_entities_prefix || ':PreferredAbbreviation'),a.preferred_abbreviation).getClobVal()                                                                  pref_abbr,
         COUNT(a.sequence) over()                                                                                                                           total_row_count
  FROM   dmrs_attributes a
  WHERE  a.container_ovid = v_e_ovid
  ORDER BY a.sequence;
rec_attributes cur_attributes%ROWTYPE;

-- Attributes Comments Data
CURSOR cur_attributes_comments(v_e_ovid IN VARCHAR2) IS
 SELECT a.seq                          seq, 
        a.attribute_name               attribute_name, 
        a.attribute_description        attribute_description, 
        a.attribute_notes              attribute_notes,
        COUNT(a.attribute_name) over() total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(all_entities_prefix || ':AttributeCommentsSequence'),a.sequence).getStringVal()     seq,
         XMLElement(EVALNAME(all_entities_prefix || ':AttributeCommentsName'),a.attribute_name).getStringVal()   attribute_name,
         XMLElement(EVALNAME(all_entities_prefix || ':AttributeDescription'),XMLCDATA(
         NVL(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='Comments'),
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='CommentsInRDBMS')))).getClobVal()                                                        attribute_description, 
         XMLElement(EVALNAME(all_entities_prefix || ':AttributeNotes'),XMLCDATA(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.ovid
         AND    t.type='Note'))).getClobVal()                                                                    attribute_notes
  FROM   dmrs_entities e, 
         dmrs_attributes a
  WHERE  e.ovid = a.container_ovid
  and    e.ovid = v_e_ovid
  ORDER BY a.sequence
 ) a
 WHERE DBMS_LOB.getlength(attribute_description) > 0 OR DBMS_LOB.getlength(attribute_notes) > 0;
rec_attributes_comments cur_attributes_comments%ROWTYPE;

CURSOR cur_identifiers(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':IdentifierName'),CASE WHEN ke.sequence>1 THEN ' ' ELSE ke.key_name END).getClobVal()                          nn,
        XMLElement(EVALNAME(all_entities_prefix || ':PrimaryIdentifier'),CASE WHEN ke.sequence>1 THEN ' ' ELSE DECODE(k.state,'Primary Key','Y') END).getClobVal() pi, 
        XMLElement(EVALNAME(all_entities_prefix || ':ElementName'),ke.element_name).getClobVal()                                                                   element_name,
        XMLElement(EVALNAME(all_entities_prefix || ':ElementType'),ke.type).getClobVal()                                                                           type,
        XMLElement(EVALNAME(all_entities_prefix || ':SourceLabel'),ke.source_label).getClobVal()                                                                   source_label,
        XMLElement(EVALNAME(all_entities_prefix || ':TargetLabel'),ke.target_label).getClobVal()                                                                   target_label,
        COUNT(ke.sequence) over()                                                                                                        total_row_count
 FROM   dmrs_keys          k,
        dmrs_key_elements ke
 WHERE  k.container_ovid = v_e_ovid
 AND   ke.key_ovid = k.ovid
 ORDER BY ke.sequence;
rec_identifiers cur_identifiers%ROWTYPE;

CURSOR cur_relationships(v_e_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':SourceName'),r.target_entity_name).getClobVal()                                                                  source_name, 
        XMLElement(EVALNAME(all_entities_prefix || ':SourceRole'),r.source_label).getClobVal()                                                                        source_role,
        XMLElement(EVALNAME(all_entities_prefix || ':TargetRole'),r.target_label).getClobVal()                                                                        target_role,
        XMLElement(EVALNAME(all_entities_prefix || ':InArc'),DECODE(r.in_arc,'N','',r.in_arc)).getClobVal()                                                           in_arc,
        XMLElement(EVALNAME(all_entities_prefix || ':Cardinality'),
           DECODE(r.source_optional,'Y',0,'1') || '..' || r.sourceto_target_cardinality
           ||':'||
           DECODE(r.target_optional,'Y',0,'1') || '..' || r.targetto_source_cardinality
           ).getClobVal()                                                                                                                   cardinality,
        XMLElement(EVALNAME(all_entities_prefix || ':DominantRole'),DECODE(r.dominant_role,'None','')).getClobVal()                                                   dominant_role,
        XMLElement(EVALNAME(all_entities_prefix || ':Identifying'),DECODE(r.identifying,'N','',r.identifying)).getClobVal()                                           identifying,
        XMLElement(EVALNAME(all_entities_prefix || ':Transferable'),DECODE(r.transferable,'N','',r.transferable)).getClobVal()                                        transferable
 FROM   dmrs_relationships r
 WHERE  r.source_ovid  = v_e_ovid
 UNION ALL
 SELECT XMLElement(EVALNAME(all_entities_prefix || ':SourceName'),r.source_entity_name).getClobVal()                                                                  source_name, 
        XMLElement(EVALNAME(all_entities_prefix || ':SourceRole'),r.source_label).getClobVal()                                                                        source_role,
        XMLElement(EVALNAME(all_entities_prefix || ':TargetRole'),r.target_label).getClobVal()                                                                        target_role,
        XMLElement(EVALNAME(all_entities_prefix || ':InArc'),DECODE(r.in_arc,'N','',r.in_arc)).getClobVal()                                                           in_arc,
        XMLElement(EVALNAME(all_entities_prefix || ':Cardinality'),
           DECODE(r.source_optional,'Y',0,'1') || '..' || r.sourceto_target_cardinality
           ||':'||
           DECODE(r.target_optional,'Y',0,'1') || '..' || r.targetto_source_cardinality
           ).getClobVal()                                                                                                                   cardinality,
        XMLElement(EVALNAME(all_entities_prefix || ':DominantRole'),DECODE(r.dominant_role,'None','')).getClobVal()                                                   dominant_role,
        XMLElement(EVALNAME(all_entities_prefix || ':Identifying'),DECODE(r.identifying,'N','',r.identifying)).getClobVal()                                           identifying,
        XMLElement(EVALNAME(all_entities_prefix || ':Transferable'),DECODE(r.transferable,'N','',r.transferable)).getClobVal()                                        transferable
 FROM   dmrs_relationships r
 WHERE  r.target_ovid  = v_e_ovid;
rec_relationships cur_relationships%ROWTYPE;

CURSOR cur_incoming_processes(v_e_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(all_entities_prefix || ':IncomingProcessName'), NVL(pe.process_name,' ')).getClobVal()  ipr_name,
         XMLElement(EVALNAME(all_entities_prefix || ':IncomingFlowName'), NVL(pe.flow_name,' ')).getClobVal()       ipr_flow_name,
         XMLElement(EVALNAME(all_entities_prefix || ':IncomingCRUDCode'), NVL(pe.crud_code,' ')).getClobVal()       ipr_crud_code,
         XMLElement(EVALNAME(all_entities_prefix || ':IncomingDFDName'), NVL(pe.dfd_name,' ')).getClobVal()         ipr_dfd_name,
         COUNT(pe.process_name) over()                                                    total_row_count
  FROM   dmrs_process_entities pe
  WHERE  pe.entity_ovid = v_e_ovid
  AND    pe.flow_direction = 'IN'
  ORDER BY pe.process_name;
rec_incoming_processes cur_incoming_processes%ROWTYPE;

CURSOR cur_outgoing_processes(v_e_ovid IN VARCHAR2) IS
  SELECT XMLElement(EVALNAME(all_entities_prefix || ':OutgoingProcessName'), pe.process_name).getClobVal() opr_name,
         XMLElement(EVALNAME(all_entities_prefix || ':OutgoingFlowName'), pe.flow_name).getClobVal()       opr_flow_name,
         XMLElement(EVALNAME(all_entities_prefix || ':OutgoingCRUDCode'), pe.crud_code).getClobVal()       opr_crud_code,
         XMLElement(EVALNAME(all_entities_prefix || ':OutgoingDFDName'), pe.dfd_name).getClobVal()         opr_dfd_name,
         COUNT(pe.process_name) over()                                           total_row_count
  FROM   dmrs_process_entities pe
  WHERE  pe.entity_ovid = v_e_ovid
  AND    pe.flow_direction = 'OUT'
  ORDER BY pe.process_name;
rec_outgoing_processes cur_outgoing_processes%ROWTYPE;

-- Constraints
CURSOR cur_constraints(v_e_ovid IN VARCHAR2) IS
SELECT XMLElement(EVALNAME(all_entities_prefix || ':ContstraintType'), CASE WHEN rownum>1 THEN ''
                                              ELSE 'Attribute Level'
                                              END).getClobVal()                                        c_type,
        XMLElement(EVALNAME(all_entities_prefix || ':ALCConstraintName'), a.attribute_name || 
                                                DECODE((SELECT DISTINCT(constraint_name)
                                                        FROM dmrs_check_constraints 
                                                        WHERE a.ovid = dataelement_ovid),NULL,'',
                                               ' / '|| (SELECT  DISTINCT(constraint_name) 
                                                        FROM dmrs_check_constraints 
                                                        WHERE a.ovid = dataelement_ovid))).getClobVal() c_name,
        Gather_Constraint_Details_XML(a.ovid, all_entities_prefix)                                      c_details,
        COUNT(a.attribute_name) over()                                                                  total_row_count
 FROM   dmrs_attributes a
 WHERE a.container_ovid = v_e_ovid
 AND  (a.ovid IN (SELECT dataelement_ovid FROM dmrs_avt) OR 
       a.ovid IN (SELECT dataelement_ovid FROM dmrs_value_ranges) OR 
       a.ovid IN (SELECT dataelement_ovid FROM dmrs_check_constraints));
rec_constraints cur_constraints%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all entities started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':Entities xmlns:' || all_entities_prefix || '="http://oracle.com/datamodeler/reports/entities">');

  FOR rec_general_data IN cur_general_data(v_model_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

   FOR rec_all_entities IN cur_all_entities(v_model_ovid) LOOP

      IF (cur_all_entities%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':EntitiesCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':EntityDetails>');

      -- Mapped tables
      FOR rec_mapped_tables IN cur_mapped_tables(rec_all_entities.entity_ovid) LOOP
        IF (cur_mapped_tables%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':MappedTablesCollection>');
        END IF;

         DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':MappedTablesDetails>');
         DBMS_LOB.APPEND (res, rec_mapped_tables.table_name);
         DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':MappedTablesDetails>');

        IF (cur_mapped_tables%ROWCOUNT = rec_mapped_tables.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':MappedTablesCollection>');
        END IF;
      END LOOP;

      -- Description / Notes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

        DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':DescriptionNotes>');

        SELECT  XMLElement(EVALNAME(all_entities_prefix || ':Description'), XMLCDATA(
                  NVL((SELECT t.text comments_in_rdbms
                       FROM   dmrs_large_text t
                       WHERE  t.ovid = rec_all_entities.entity_ovid
                       AND    t.type='Comments'),
                      (SELECT t.text comments_in_rdbms
                       FROM   dmrs_large_text t
                       WHERE  t.ovid = rec_all_entities.entity_ovid
                       AND    t.type='CommentsInRDBMS')))).getClobVal(), 
                XMLElement(EVALNAME(all_entities_prefix || ':Notes'), XMLCDATA(
                      (SELECT t.text comments_in_rdbms
                       FROM   dmrs_large_text t
                       WHERE  t.ovid = rec_all_entities.entity_ovid
                       AND    t.type='Note'))).getClobVal()
        INTO    v_description, 
                v_notes
        FROM dual;

        DBMS_LOB.APPEND (res, v_description);
        DBMS_LOB.APPEND (res, v_notes);
        DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':DescriptionNotes>');

      END IF;

      DBMS_LOB.APPEND (res, rec_all_entities.entity_name);
      DBMS_LOB.APPEND (res, rec_all_entities.xml_ovid);
      DBMS_LOB.APPEND (res, rec_all_entities.pref_abbreviation);      
      DBMS_LOB.APPEND (res, rec_all_entities.classification_type_name);
      DBMS_LOB.APPEND (res, rec_all_entities.object_type_name);
      DBMS_LOB.APPEND (res, rec_all_entities.super_type);
      DBMS_LOB.APPEND (res, rec_all_entities.table_synonyms);

      IF (reportTemplate.reportType = 0 OR reportTemplate.useQuantitativeInfo = 1) THEN
        DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':QuantitativeInfoCollection>');
        DBMS_LOB.APPEND (res, rec_all_entities.number_of_attributes);
        DBMS_LOB.APPEND (res, rec_all_entities.number_rows_min);
        DBMS_LOB.APPEND (res, rec_all_entities.number_rows_max);
        DBMS_LOB.APPEND (res, rec_all_entities.expected_number_of_rows);
        DBMS_LOB.APPEND (res, rec_all_entities.expected_growth);
        DBMS_LOB.APPEND (res, rec_all_entities.growth_interval);
        DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':QuantitativeInfoCollection>');
      END IF;

       -- Diagrams
       IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
         FOR rec_diagrams IN cur_diagrams(rec_all_entities.entity_ovid, v_report_name) LOOP
            IF (cur_diagrams%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':DiagramsCollection>');
            END IF;

              DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

            IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':DiagramsCollection>');
            END IF;
         END LOOP;
       END IF;

      -- Attributes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityAttributes = 1) THEN
        FOR rec_attributes IN cur_attributes(rec_all_entities.entity_ovid) LOOP

           IF (cur_attributes%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':AttributesCollection>');
           END IF;

             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':AttributeDetails>');
             DBMS_LOB.APPEND (res, rec_attributes.seq);
             DBMS_LOB.APPEND (res, rec_attributes.attr_name);
             DBMS_LOB.APPEND (res, rec_attributes.pk);
             DBMS_LOB.APPEND (res, rec_attributes.fk);
             DBMS_LOB.APPEND (res, rec_attributes.m);
             IF (INSTR(LOWER(rec_attributes.data_type),'unknown') = 0) THEN
                DBMS_LOB.APPEND (res, rec_attributes.data_type);
             ELSE
                SELECT XMLElement(EVALNAME(all_entities_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
                DBMS_LOB.APPEND (res, token_value);
             END IF;
             DBMS_LOB.APPEND (res, rec_attributes.dt_kind);
             DBMS_LOB.APPEND (res, rec_attributes.domain_name);
             DBMS_LOB.APPEND (res, rec_attributes.formula);
             DBMS_LOB.APPEND (res, rec_attributes.pref_abbr);
             DBMS_LOB.APPEND (res, rec_attributes.synonyms);
             DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':AttributeDetails>');

           IF (cur_attributes%ROWCOUNT = rec_attributes.total_row_count) THEN
            DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':AttributesCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Attribute Comments
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityAttributesComments = 1) THEN
        FOR rec_attributes_comments IN cur_attributes_comments(rec_all_entities.entity_ovid) LOOP
           IF (cur_attributes_comments%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':AttributesCommentsCollection>');
           END IF;

            DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':AttributeCommentsDetails>');
            DBMS_LOB.APPEND (res, rec_attributes_comments.seq);
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_name);
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_description);
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_notes);
            DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':AttributeCommentsDetails>');

           IF (cur_attributes_comments%ROWCOUNT = rec_attributes_comments.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':AttributesCommentsCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Constraints
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityConstraints = 1) THEN
        FOR rec_constraints IN cur_constraints(rec_all_entities.entity_ovid) LOOP
           IF (cur_constraints%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':ConstraintsCollection>');
           END IF;

             DBMS_LOB.APPEND (res,'<' || all_entities_prefix || ':ConstraintDetails>');
             DBMS_LOB.APPEND (res,rec_constraints.c_type);
             DBMS_LOB.APPEND (res,rec_constraints.c_name);
             DBMS_LOB.APPEND (res,rec_constraints.c_details);
             DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':ConstraintDetails>');

           IF (cur_constraints%ROWCOUNT = rec_constraints.total_row_count) THEN
               DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':ConstraintsCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Identifiers
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityIdentifiers = 1) THEN
        FOR rec_identifiers IN cur_identifiers(rec_all_entities.entity_ovid) LOOP
           IF (cur_identifiers%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':IdentifiersCollection>');
           END IF;

             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':IdentifierDetails>');
             DBMS_LOB.APPEND (res, rec_identifiers.nn);
             DBMS_LOB.APPEND (res, rec_identifiers.pi);
             DBMS_LOB.APPEND (res, rec_identifiers.element_name);
             DBMS_LOB.APPEND (res, rec_identifiers.type);
             DBMS_LOB.APPEND (res, rec_identifiers.source_label);
             DBMS_LOB.APPEND (res, rec_identifiers.target_label);
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':IdentifierDetails>');

           IF (cur_identifiers%ROWCOUNT = rec_identifiers.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':IdentifiersCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Relationships
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityRelationships = 1) THEN
        -- Total count of relationships
        SELECT COUNT(1)
        INTO   v_rel_total_count
        FROM (
         SELECT r.ovid
         FROM   dmrs_relationships r,
                dmrs_entities      e
         WHERE  r.source_ovid  = e.ovid
         AND    e.ovid         = rec_all_entities.entity_ovid
         UNION ALL
         SELECT r.ovid
         FROM   dmrs_relationships r,
                dmrs_entities      e
         WHERE  r.target_ovid  = e.ovid
         AND    e.ovid         = rec_all_entities.entity_ovid);

        FOR rec_relationships IN cur_relationships(rec_all_entities.entity_ovid) LOOP
           IF (cur_relationships%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':RelationshipsCollection>');
           END IF;

              DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':RelationshipDetails>');
              DBMS_LOB.APPEND (res, rec_relationships.source_name);
              DBMS_LOB.APPEND (res, rec_relationships.source_role);
              DBMS_LOB.APPEND (res, rec_relationships.target_role);
              DBMS_LOB.APPEND (res, rec_relationships.in_arc);
              DBMS_LOB.APPEND (res, rec_relationships.cardinality);
              DBMS_LOB.APPEND (res, rec_relationships.dominant_role);
              DBMS_LOB.APPEND (res, rec_relationships.identifying);
              DBMS_LOB.APPEND (res, rec_relationships.transferable);
              DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':RelationshipDetails>');

           IF (cur_relationships%ROWCOUNT = v_rel_total_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':RelationshipsCollection>');
           END IF;

        END LOOP;
      END IF;

      -- Incoming Processes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityIncomingProcesses = 1) THEN
        FOR rec_incoming_processes IN cur_incoming_processes(rec_all_entities.entity_ovid) LOOP
           IF (cur_incoming_processes%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':IncomingProcessesCollection>');
           END IF;
             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':IncomingProcessDetails>');
             DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_name);
             DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_flow_name);
             DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_crud_code);
             DBMS_LOB.APPEND (res, rec_incoming_processes.ipr_dfd_name);
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':IncomingProcessDetails>');
           IF (cur_incoming_processes%ROWCOUNT = rec_incoming_processes.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':IncomingProcessesCollection>');
           END IF;
        END LOOP;
      END IF;
      -- Outgoing Processes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useEntityOutgoingProcesses = 1) THEN
        FOR rec_outgoing_processes IN cur_outgoing_processes(rec_all_entities.entity_ovid) LOOP
           IF (cur_outgoing_processes%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':OutgoingProcessesCollection>');
           END IF;
             DBMS_LOB.APPEND (res, '<' || all_entities_prefix || ':OugoingProcessDetails>');
             DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_name);
             DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_flow_name);
             DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_crud_code);
             DBMS_LOB.APPEND (res, rec_outgoing_processes.opr_dfd_name);
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':OugoingProcessDetails>');
           IF (cur_outgoing_processes%ROWCOUNT = rec_outgoing_processes.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_entities_prefix || ':OutgoingProcessesCollection>');
           END IF;
        END LOOP;
      END IF;

      DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':EntityDetails>');

      IF (cur_all_entities%ROWCOUNT = rec_all_entities.total_row_count) THEN
         DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':EntitiesCollection>');
      END IF;

   END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_entities_prefix || ':Entities>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all entities ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllEntities_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllEntities_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllEntities_Data;

FUNCTION Gather_Glossary_Data(v_glossary_ovid IN VARCHAR2) RETURN CLOB IS 

res CLOB;

CURSOR cur_glossary(v_g_ovid IN VARCHAR2) IS
 SELECT  /*+ index(g GLOSSARIES_OVID_IDX) */
         XMLElement(EVALNAME(glossary_prefix || ':GlossaryName'), g.glossary_name).getClobVal()                                      glossary_name,
         XMLElement(EVALNAME(glossary_prefix || ':Description'), XMLCDATA(g.description)).getClobVal()                               description,
         XMLElement(EVALNAME(glossary_prefix || ':FileName'), g.file_name).getStringVal()                                            file_name,
         XMLElement(EVALNAME(glossary_prefix || ':IncompleteModifiers'), DECODE(g.incomplete_modifiers,'N','','Y')).getStringVal()   inc_modifiers,
         XMLElement(EVALNAME(glossary_prefix || ':CaseSensitive'), DECODE(g.case_sensitive,'N','','Y')).getStringVal()               case_sensitive,
         XMLElement(EVALNAME(glossary_prefix || ':UniqueAbbreviations'), DECODE(g.unique_abbrevs,'N','','Y')).getStringVal()         unique_abbreviations,
         XMLElement(EVALNAME(glossary_prefix || ':SeparatorType'), g.separator_type).getStringVal()                                  separator_type,
         XMLElement(EVALNAME(glossary_prefix || ':SeparatorChar'), g.separator_char).getStringVal()                                  separator_char
 FROM    dmrs_glossaries g
 WHERE   g.glossary_ovid = v_g_ovid;
rec_glossary cur_glossary%ROWTYPE;

CURSOR cur_glossary_words(v_g_ovid IN VARCHAR2) IS
 SELECT /*+ index(g GLOSSARIES_OVID_IDX) */
        XMLElement(EVALNAME(glossary_prefix || ':TermName'), gt.term_name).getClobVal()                            term_name,
        XMLElement(EVALNAME(glossary_prefix || ':Plural'), gt.plural).getClobVal()                                 plural,
        XMLElement(EVALNAME(glossary_prefix || ':Abbreviation'), gt.abbrev).getClobVal()                           abbr,
        XMLElement(EVALNAME(glossary_prefix || ':AltAbbreviation'), gt.alt_abbrev).getClobVal()                    alt_abbr,
        XMLElement(EVALNAME(glossary_prefix || ':P'), DECODE(gt.prime_word,'N','',gt.prime_word)).getClobVal()     p_word,
        XMLElement(EVALNAME(glossary_prefix || ':C'), DECODE(gt.class_word,'N','',gt.class_word)).getClobVal()     c_word,
        XMLElement(EVALNAME(glossary_prefix || ':M'), DECODE(gt.modifier,'N','',gt.modifier)).getClobVal()         modifier,
        XMLElement(EVALNAME(glossary_prefix || ':Q'), DECODE(gt.qualifier,'N','',gt.qualifier)).getClobVal()       qualifier,
        XMLElement(EVALNAME(glossary_prefix || ':SDescription'), XMLCDATA(gt.short_description)).getClobVal()      description,
        COUNT(gt.term_name) over() total_row_count
 FROM   dmrs_glossaries g,
        dmrs_glossary_terms gt
 WHERE  g.glossary_ovid = gt.glossary_ovid
 AND    g.glossary_ovid = v_g_ovid;
rec_glossary_words cur_glossary_words%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering glossary data started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || glossary_prefix || ':Glossary xmlns:' || glossary_prefix || '="http://oracle.com/datamodeler/reports/glossary">');

  FOR rec_glossary IN cur_glossary(v_glossary_ovid) LOOP
    DBMS_LOB.APPEND (res, rec_glossary.glossary_name);
    DBMS_LOB.APPEND (res, rec_glossary.description);
    DBMS_LOB.APPEND (res, rec_glossary.file_name);
    DBMS_LOB.APPEND (res, rec_glossary.inc_modifiers);
    DBMS_LOB.APPEND (res, rec_glossary.case_sensitive);
    DBMS_LOB.APPEND (res, rec_glossary.unique_abbreviations);
    DBMS_LOB.APPEND (res, rec_glossary.separator_type);
    DBMS_LOB.APPEND (res, rec_glossary.separator_char);
  END LOOP;

  FOR rec_glossary_words IN cur_glossary_words(v_glossary_ovid) LOOP
    IF (cur_glossary_words%ROWCOUNT = 1) THEN
      DBMS_LOB.APPEND (res, '<' || glossary_prefix || ':GlossaryCollection>');
    END IF;
      DBMS_LOB.APPEND (res, '<' || glossary_prefix || ':GlossaryDetail>');
      DBMS_LOB.APPEND (res, rec_glossary_words.term_name);
      DBMS_LOB.APPEND (res, rec_glossary_words.plural);
      DBMS_LOB.APPEND (res, rec_glossary_words.abbr);
      DBMS_LOB.APPEND (res, rec_glossary_words.alt_abbr);
      DBMS_LOB.APPEND (res, rec_glossary_words.p_word);
      DBMS_LOB.APPEND (res, rec_glossary_words.c_word);
      DBMS_LOB.APPEND (res, rec_glossary_words.modifier);
      DBMS_LOB.APPEND (res, rec_glossary_words.qualifier);
      DBMS_LOB.APPEND (res, rec_glossary_words.description);
      DBMS_LOB.APPEND (res, '</' || glossary_prefix || ':GlossaryDetail>');
    IF (cur_glossary_words%ROWCOUNT = rec_glossary_words.total_row_count) THEN
      DBMS_LOB.APPEND (res, '</' || glossary_prefix || ':GlossaryCollection>');
    END IF;
  END LOOP;

  DBMS_LOB.APPEND (res, '</' || glossary_prefix || ':Glossary>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering glossary data ended');

RETURN res;

  EXCEPTION
  WHEN others THEN
    UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Glossary_Data Exception : ' || SQLERRM);  
    UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Glossary_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_Glossary_Data;

FUNCTION Gather_SingleST_Data(v_str_type_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, v_report_name IN VARCHAR2) RETURN CLOB IS 

res               CLOB;
token_value       CLOB;
v_description     CLOB;
v_notes           CLOB;
v_rel_total_count INTEGER;
v_seq             INTEGER := 1;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

 -- General data
CURSOR cur_general_data(v_st_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_st_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(single_st_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(single_st_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(single_st_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m,
        dmrs_structured_types st
 WHERE  d.design_ovid = m.design_ovid
 AND    st.model_ovid = m.model_ovid
 AND    st.structured_type_ovid = v_st_ovid;
rec_general_data cur_general_data%ROWTYPE;

-- Structured Type General Data
CURSOR cur_st(v_st_ovid IN VARCHAR2) IS
SELECT XMLElement(EVALNAME(single_st_prefix || ':STName'),st.structured_type_name).getClobVal()                                                                                     stName,
       XMLElement(EVALNAME(single_st_prefix || ':STSuperType'),(SELECT st1.structured_type_name 
                                           FROM  dmrs_structured_types st1 
                                           WHERE st.super_type_ovid = st1.structured_type_ovid)).getClobVal()                                                  super_type
FROM   dmrs_structured_types st
WHERE  st.structured_type_ovid = v_st_ovid;
rec_st cur_st%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_st_prefix || ':Diagram'), 
          XMLElement(EVALNAME(single_st_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
          XMLElement(EVALNAME(single_st_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                             total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

--Attributes
CURSOR cur_st_attr(v_st_ovid IN VARCHAR2) IS
SELECT  XMLElement(EVALNAME(single_st_prefix || ':AttributeName'), sta.attribute_name).getClobVal()                                                                                 attr_name,
        XMLElement(EVALNAME(single_st_prefix || ':M'),DECODE(sta.mandatory,'N','','Y')).getClobVal()                                                                                m,
        XMLElement(EVALNAME(single_st_prefix || ':DataTypeKind'),DECODE(sta.datatype_kind,                                                                                           
                                                 'Domain',         'DOM',
                                                 'Logical Type',   'LT',
                                                 'Distinct Type',  'DT',
                                                 'Ref Struct Type','RST',
                                                 'Structured Type','ST',
                                                 'Collection Type','CT')
                  ).getClobVal()                                                                                                                               dt_kind,
         XMLElement(EVALNAME(single_st_prefix || ':DataType'), 
            DECODE(sta.datatype_kind, 
                  'Domain', sta.type_name ||' '||
                           DECODE (NVL(sta.t_size,''),'',
                              DECODE(NVL(sta.t_scale,0),0,
                                 DECODE(NVL(sta.t_precision,0),0,null,'('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) ||')'),
                                   '('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) || ',' || DECODE(NVL(sta.t_scale,0),0,null,sta.t_scale)||')'),
                                   '('||TRIM(DECODE(sta.t_size,'',null,sta.t_size||' '||sta.char_units ))||')'),
                   'Logical Type', sta.type_name  ||' '|| 
                           DECODE (NVL(sta.t_size,''),'',
                              DECODE(NVL(sta.t_scale,0),0,
                                 DECODE(NVL(sta.t_precision,0),0,null,'('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) ||')'),
                                   '('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) || ',' || DECODE(NVL(sta.t_scale,0),0,null,sta.t_scale)||')'),
                                   '('||TRIM(DECODE(sta.t_size,'',null,sta.t_size||' '||sta.char_units ))||')')
            )).getClobVal()                                                                                                                                    data_type,
        XMLElement(EVALNAME(single_st_prefix || ':DomainName'),DECODE(sta.domain_name,'Unknown',null,sta.domain_name)).getClobVal()                                                 domain_name,
      COUNT(sta.attribute_name) over()                                                                                                                         total_row_count
FROM  dmrs_struct_type_attrs sta,
      dmrs_structured_types st
WHERE sta.structured_type_ovid = st.structured_type_ovid
AND   st.structured_type_ovid = v_st_ovid;
rec_st_attr cur_st_attr%ROWTYPE;

-- Attributes Comments Data
CURSOR cur_attributes_comments(v_st_ovid IN VARCHAR2) IS
 SELECT a.attribute_name               attribute_name, 
        a.attribute_description        attribute_description, 
        a.attribute_notes              attribute_notes,
        COUNT(a.attribute_name) over() total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(single_st_prefix || ':AttributeCommentsName'),a.attribute_name).getStringVal()   attribute_name,
         XMLElement(EVALNAME(single_st_prefix || ':AttributeDescription'),XMLCDATA(
         NVL(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.attribute_ovid
         AND    t.type='Comments'),
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.attribute_ovid
         AND    t.type='CommentsInRDBMS')))).getClobVal()                                                     attribute_description, 
        XMLElement(EVALNAME(single_st_prefix || ':AttributeNotes'),XMLCDATA(
        (SELECT t.text comments_in_rdbms
         FROM   dmrs_large_text t
         WHERE  t.ovid = a.attribute_ovid
         AND    t.type='Note'))).getClobVal()                                                                 attribute_notes
  FROM   dmrs_struct_type_attrs a
  WHERE  a.structured_type_ovid = v_st_ovid
 ) a
 WHERE DBMS_LOB.getlength(attribute_description) > 0 OR DBMS_LOB.getlength(attribute_notes) > 0;
rec_attributes_comments cur_attributes_comments%ROWTYPE;

-- Methods
CURSOR  cur_st_methods(v_st_ovid IN VARCHAR2) IS
SELECT  XMLElement(EVALNAME(single_st_prefix || ':MethodName'), m.method_name).getClobVal()                           m_name,
        XMLElement(EVALNAME(single_st_prefix || ':MethodConstructor'), DECODE(m.constructor,'N','','Y')).getClobVal() m_constr,
        XMLElement(EVALNAME(single_st_prefix || ':MethodOverriding'), DECODE(m.overriding,'N','','Y')).getClobVal()   m_overriding,
        XMLElement(EVALNAME(single_st_prefix || ':MethodOverridenMethod'), m.overridden_method_name).getClobVal()     m_om_name,
        XMLElement(EVALNAME(single_st_prefix || ':MethodReturnValue'), 
        (SELECT sp.type_name  ||' '|| 
                DECODE (NVL(sp.t_size,''),'',
                 DECODE(NVL(sp.t_scale,0),0,
                  DECODE(NVL(sp.t_precision,0),0,null,'('|| DECODE(NVL(sp.t_precision,0),0,null,sp.t_precision) ||')'),
                  '('|| DECODE(NVL(sp.t_precision,0),0,null,sp.t_precision) || ',' || DECODE(NVL(sp.t_scale,0),0,null,sp.t_scale)||')'),
                  '('||TRIM(DECODE(sp.t_size,'',null,sp.t_size ))||')')
         FROM   dmrs_struct_type_method_pars sp 
         WHERE  return_value= 'Y'
         AND    sp.method_ovid = m.method_ovid)).getClobVal()                                    m_return_type,        
        COUNT(m.method_name) over()                                                              total_row_count,
        m.method_ovid                                                                            method_ovid
FROM dmrs_struct_type_methods m,
     dmrs_structured_types st
WHERE m.structured_type_ovid = st.structured_type_ovid
AND   st.structured_type_ovid = v_st_ovid;
rec_st_methods cur_st_methods%ROWTYPE;

-- Method params
CURSOR cur_st_methods_p(v_m_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_st_prefix || ':ParameterName'), parameter_name).getClobVal()  param_name,
        --XMLElement("osdm_s_st:ParameterType", type_name).getClobVal()       param_type,
        XMLElement(EVALNAME(single_st_prefix || ':ParameterType'), 
        type_name  ||' '|| 
                DECODE (NVL(t_size,0),0,
                 DECODE(NVL(t_scale,0),0,
                  DECODE(NVL(t_precision,0),0,null,'('|| DECODE(NVL(t_precision,0),0,null,t_precision) ||')'),
                  '('|| DECODE(NVL(t_precision,0),0,null,t_precision) || ',' || DECODE(NVL(t_scale,0),0,null,t_scale)||')'),
                  '('||TRIM(DECODE(t_size,0,null,t_size ))||')')
        ).getClobVal()       param_type,
        COUNT(parameter_name) over()                                        total_row_count
 FROM   dmrs_struct_type_method_pars
 WHERE  method_ovid = v_m_ovid
 AND    return_value = 'N'
 ORDER BY seq;
rec_st_methods_p cur_st_methods_p%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_st_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_st_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(single_st_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(single_st_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                       total_row_count
 FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_structured_types st,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.structured_type_ovid = st.structured_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Structured Type'
 AND    st.structured_type_ovid = v_st_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_st_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_st_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(single_st_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_structured_types st
 WHERE  e.ovid = a.container_ovid
 AND    a.structured_type_ovid = st.structured_type_ovid
 AND    a.datatype_kind = 'Structured Type'
 AND    st.structured_type_ovid = v_st_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single structured type started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':StructuredType xmlns:' || single_st_prefix || '="http://oracle.com/datamodeler/reports/structuredtype">');

  FOR rec_general_data IN cur_general_data(v_str_type_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

   FOR rec_st IN cur_st(v_str_type_ovid) LOOP
      DBMS_LOB.APPEND (res, rec_st.stName);
      DBMS_LOB.APPEND (res, rec_st.super_type);
   END LOOP;

   -- Description / Notes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

     DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':DescriptionNotes>');

     SELECT XMLElement(EVALNAME(single_st_prefix || ':Description'), XMLCDATA(
              NVL((SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = v_str_type_ovid
                  AND    t.type='Comments'),
                  (SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = v_str_type_ovid
                  AND    t.type='CommentsInRDBMS')))).getClobVal(), 
            XMLElement(EVALNAME(single_st_prefix || ':Notes'), XMLCDATA(
                  (SELECT t.text comments_in_rdbms
                  FROM   dmrs_large_text t
                  WHERE  t.ovid = v_str_type_ovid
                  AND    t.type='Note'))).getClobVal()
     INTO   v_description, 
            v_notes
     FROM  dual;

    DBMS_LOB.APPEND (res, v_description);
    DBMS_LOB.APPEND (res, v_notes);
    DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':DescriptionNotes>');

   END IF;

   -- Diagrams
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
     FOR rec_diagrams IN cur_diagrams(v_str_type_ovid, v_report_name) LOOP
        IF (cur_diagrams%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':DiagramsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

        IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
         DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':DiagramsCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Attributes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useSTAttributes = 1) THEN
     FOR rec_st_attr IN cur_st_attr(v_str_type_ovid) LOOP
        IF (cur_st_attr%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':AttributesCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':AttributeDetails>');
          DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':Sequence>' || TO_CHAR(v_seq) || '</' || single_st_prefix || ':Sequence>');
          DBMS_LOB.APPEND (res, rec_st_attr.attr_name);
          DBMS_LOB.APPEND (res, rec_st_attr.m);
          IF (INSTR(LOWER(rec_st_attr.data_type),'unknown') = 0) THEN
             DBMS_LOB.APPEND (res, rec_st_attr.data_type);
          ELSE
             SELECT XMLElement(EVALNAME(single_st_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
             DBMS_LOB.APPEND (res, token_value);
          END IF;
          DBMS_LOB.APPEND (res, rec_st_attr.dt_kind);
          DBMS_LOB.APPEND (res, rec_st_attr.domain_name);
          DBMS_LOB.APPEND (res,'</' || single_st_prefix || ':AttributeDetails>');

        IF (cur_st_attr%ROWCOUNT = rec_st_attr.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':AttributesCollection>');
        END IF;
        v_seq := v_seq + 1;
     END LOOP;
   END IF;

   v_seq := 1;
   -- Attribute Comments
   IF (reportTemplate.reportType = 0 OR reportTemplate.useSTAttributesComments = 1) THEN
     FOR rec_attributes_comments IN cur_attributes_comments(v_str_type_ovid) LOOP
        IF (cur_attributes_comments%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':AttributesCommentsCollection>');
        END IF;

          DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':AttributeCommentsDetails>');
          DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':AttributeCommentsSequence>' || TO_CHAR(v_seq) || '</' || single_st_prefix || ':AttributeCommentsSequence>');
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_name);
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_description);
          DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_notes);
          DBMS_LOB.APPEND (res,'</' || single_st_prefix || ':AttributeCommentsDetails>');

        IF (cur_attributes_comments%ROWCOUNT = rec_attributes_comments.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':AttributesCommentsCollection>');
        END IF;
        v_seq := v_seq + 1;
     END LOOP;
   END IF;

   v_seq := 1;
   IF (reportTemplate.reportType = 0 OR reportTemplate.useSTMethods = 1) THEN
     FOR rec_st_methods IN cur_st_methods(v_str_type_ovid) LOOP
        IF (cur_st_methods%ROWCOUNT = 1) THEN
          DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':MethodsCollection>');
        END IF;

            DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':MethodDetails>');
            DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':MethodSequence>' || TO_CHAR(v_seq) || '</' || single_st_prefix || ':MethodSequence>');
            DBMS_LOB.APPEND (res, rec_st_methods.m_name);
            DBMS_LOB.APPEND (res, rec_st_methods.m_constr);
            DBMS_LOB.APPEND (res, rec_st_methods.m_overriding);
            DBMS_LOB.APPEND (res, rec_st_methods.m_om_name);
            DBMS_LOB.APPEND (res, rec_st_methods.m_return_type);

            FOR rec_st_methods_p IN cur_st_methods_p(rec_st_methods.method_ovid) LOOP
               IF (cur_st_methods_p%ROWCOUNT = 1) THEN
                 DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':MethodParametersCollection>');
               END IF;

                 DBMS_LOB.APPEND (res, '<' || single_st_prefix || ':MethodParameterDetails>');
                 DBMS_LOB.APPEND (res, rec_st_methods_p.param_name);
                 DBMS_LOB.APPEND (res, rec_st_methods_p.param_type);
                 DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':MethodParameterDetails>');

               IF (cur_st_methods_p%ROWCOUNT = rec_st_methods_p.total_row_count) THEN
                 DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':MethodParametersCollection>');
               END IF;
            END LOOP;       

            DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':MethodDetails>');

        IF (cur_st_methods%ROWCOUNT = rec_st_methods.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':MethodsCollection>');
        END IF;
        v_seq := v_seq + 1;
     END LOOP;
   END IF;

   -- Used in tables
   IF (reportTemplate.reportType = 0 OR reportTemplate.useSTUsedInTables = 1) THEN
     FOR rec_used_in_tables IN cur_used_in_tables(v_str_type_ovid) LOOP
        IF (cur_used_in_tables%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':TablesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':TableDetails>');

           v_model_name := rec_used_in_tables.model_name;
           IF (v_model_name != p_model_name) THEN
             DBMS_LOB.APPEND (res,v_model_name);
             p_model_name := v_model_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':ModelName></' || single_st_prefix || ':ModelName>');
           END IF;

           v_table_name := rec_used_in_tables.table_name;
           IF (v_table_name != p_table_name) THEN
           DBMS_LOB.APPEND (res,v_table_name);
             p_table_name := v_table_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':TableName></' || single_st_prefix || ':TableName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
           DBMS_LOB.APPEND (res,'</' || single_st_prefix || ':TableDetails>');
        IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':TablesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Used in entities
   IF (reportTemplate.reportType = 0 OR reportTemplate.useSTUsedInEntities = 1) THEN
     FOR rec_used_in_entities IN cur_used_in_entities(v_str_type_ovid) LOOP
        IF (cur_used_in_entities%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':EntitiesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':EntityDetails>');

           v_entity_name := rec_used_in_entities.entity_name;
           IF (v_entity_name != p_entity_name) THEN
             DBMS_LOB.APPEND (res,v_entity_name);
             p_entity_name := v_entity_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_st_prefix || ':EntityName></' || single_st_prefix || ':EntityName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
           DBMS_LOB.APPEND (res,'</' || single_st_prefix || ':EntityDetails>');
        IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_st_prefix || ':EntitiesCollection>');
        END IF;
     END LOOP;
   END IF;

  DBMS_LOB.APPEND (res,'</' || single_st_prefix || ':StructuredType>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single structured type ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleST_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleST_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_SingleST_Data;

FUNCTION Gather_AllST_Data(v_model_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, objects IN OBJECTS_LIST, v_report_name IN VARCHAR2) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
v_seq             INTEGER := 1;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

-- General data
CURSOR cur_general_data(v_m_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_st_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_st_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(all_st_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m
 WHERE  d.design_ovid = m.design_ovid
 AND    m.model_ovid = v_model_ovid;
rec_general_data cur_general_data%ROWTYPE;

-- All structured types general data
CURSOR cur_all_st(v_m_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':STName'),st.structured_type_name).getClobVal()                                    st_name,
        XMLElement(EVALNAME(all_st_prefix || ':EncodedSTName'),st.structured_type_ovid).getClobVal()                             xml_ovid,
 		XMLElement(EVALNAME(all_st_prefix || ':STSuperType'),(SELECT st1.structured_type_name 
                                            FROM  dmrs_structured_types st1 
                                            WHERE st.super_type_ovid = st1.structured_type_ovid)).getClobVal() super_type,
        st.structured_type_ovid                                                                                					st_ovid,

        COUNT(st.structured_type_name) over()                                                                  					total_row_count
 FROM   dmrs_structured_types st
 WHERE  st.model_ovid = v_m_ovid
 AND    st.structured_type_ovid MEMBER OF objects
 ORDER BY st.structured_type_name;
rec_all_st cur_all_st%ROWTYPE;

-- Diagrams
CURSOR cur_diagrams(v_t_ovid IN VARCHAR2, v_rep_name IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':Diagram'), 
          XMLElement(EVALNAME(all_st_prefix || ':Name'), v_rep_name || '_files/' || REGEXP_REPLACE(SUBSTR(d.pdf_name, 1, INSTR(d.pdf_name, '.PDF')-1), '[^a-zA-Z1-9_]', '_') || '.pdf'),
          XMLElement(EVALNAME(all_st_prefix || ':Suffix'), NULL)).getClobVal()                                                                                                            pdf_name,
        COUNT(d.pdf_name) over()                                                                                                                                                          total_row_count
 FROM   dmrs_vdiagrams d,
       (SELECT diagram_ovid 
        FROM   dmrs_diagram_elements
        WHERE  ovid = v_t_ovid) b
 WHERE d.ovid = b.diagram_ovid
 AND   d.diagram_type = 'Subview'
 AND   d.is_display = 'N';
rec_diagrams cur_diagrams%ROWTYPE;

--Attributes
CURSOR cur_st_attr(v_st_ovid IN VARCHAR2) IS
SELECT  XMLElement(EVALNAME(all_st_prefix || ':AttributeName'), sta.attribute_name).getClobVal()                                                                                 attr_name,
        XMLElement(EVALNAME(all_st_prefix || ':M'),DECODE(sta.mandatory,'N','','Y')).getClobVal()                                                                                m,
        XMLElement(EVALNAME(all_st_prefix || ':DataTypeKind'),DECODE(sta.datatype_kind,                                                                                           
                                                 'Domain',         'DOM',
                                                 'Logical Type',   'LT',
                                                 'Distinct Type',  'DT',
                                                 'Ref Struct Type','RST',
                                                 'Structured Type','ST',
                                                 'Collection Type','CT')
                  ).getClobVal()                                                                                                                               dt_kind,
         XMLElement(EVALNAME(all_st_prefix || ':DataType'), 
            DECODE(sta.datatype_kind, 
                  'Domain', sta.type_name ||' '||
                           DECODE (NVL(sta.t_size,''),'',
                              DECODE(NVL(sta.t_scale,0),0,
                                 DECODE(NVL(sta.t_precision,0),0,null,'('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) ||')'),
                                   '('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) || ',' || DECODE(NVL(sta.t_scale,0),0,null,sta.t_scale)||')'),
                                   '('||TRIM(DECODE(sta.t_size,'',null,sta.t_size||' '||sta.char_units ))||')'),
                   'Logical Type', sta.type_name  ||' '|| 
                           DECODE (NVL(sta.t_size,''),'',
                              DECODE(NVL(sta.t_scale,0),0,
                                 DECODE(NVL(sta.t_precision,0),0,null,'('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) ||')'),
                                   '('|| DECODE(NVL(sta.t_precision,0),0,null,sta.t_precision) || ',' || DECODE(NVL(sta.t_scale,0),0,null,sta.t_scale)||')'),
                                   '('||TRIM(DECODE(sta.t_size,'',null,sta.t_size||' '||sta.char_units ))||')')
            )).getClobVal()                                                                                                                                    data_type,
        XMLElement(EVALNAME(all_st_prefix || ':DomainName'),DECODE(sta.domain_name,'Unknown',null,sta.domain_name)).getClobVal()                                                 domain_name,
      COUNT(sta.attribute_name) over()                                                                                                                         total_row_count
FROM  dmrs_struct_type_attrs sta,
      dmrs_structured_types st
WHERE sta.structured_type_ovid = st.structured_type_ovid
AND   st.structured_type_ovid = v_st_ovid;
rec_st_attr cur_st_attr%ROWTYPE;

-- Attributes Comments Data
CURSOR cur_attributes_comments(v_st_ovid IN VARCHAR2) IS
 SELECT a.attribute_name                              attribute_name, 
        a.attribute_description                       attribute_description, 
        a.attribute_notes                             attribute_notes,
        COUNT(a.attribute_name) over()                total_row_count
 FROM (
  SELECT XMLElement(EVALNAME(all_st_prefix || ':AttributeCommentsName'),a.attribute_name).getStringVal()          attribute_name,
         XMLElement(EVALNAME(all_st_prefix || ':AttributeDescription'),XMLCDATA(
            NVL((SELECT t.text comments_in_rdbms
                 FROM   dmrs_large_text t
                 WHERE  t.ovid = a.attribute_ovid
                 AND    t.type='Comments'),
                (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = a.attribute_ovid
                AND    t.type='CommentsInRDBMS')))).getClobVal()                                                  attribute_description, 
         XMLElement(EVALNAME(all_st_prefix || ':AttributeNotes'),XMLCDATA(
                (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = a.attribute_ovid
                AND    t.type='Note'))).getClobVal()                                                              attribute_notes
  FROM   dmrs_struct_type_attrs a
  WHERE  a.structured_type_ovid = v_st_ovid
 ) a
 WHERE DBMS_LOB.getlength(attribute_description) > 0 OR DBMS_LOB.getlength(attribute_notes) > 0;
rec_attributes_comments cur_attributes_comments%ROWTYPE;

-- Methods
CURSOR  cur_st_methods(v_st_ovid IN VARCHAR2) IS
SELECT  XMLElement(EVALNAME(all_st_prefix || ':MethodName'), m.method_name).getClobVal()                           m_name,
        XMLElement(EVALNAME(all_st_prefix || ':MethodConstructor'), DECODE(m.constructor,'N','','Y')).getClobVal() m_constr,
        XMLElement(EVALNAME(all_st_prefix || ':MethodOverriding'), DECODE(m.overriding,'N','','Y')).getClobVal()   m_overriding,
        XMLElement(EVALNAME(all_st_prefix || ':MethodOverridenMethod'), m.overridden_method_name).getClobVal()     m_om_name,
        XMLElement(EVALNAME(all_st_prefix || ':MethodReturnValue'), 
        (SELECT sp.type_name  ||' '|| 
                DECODE (NVL(sp.t_size,''),'',
                 DECODE(NVL(sp.t_scale,0),0,
                  DECODE(NVL(sp.t_precision,0),0,null,'('|| DECODE(NVL(sp.t_precision,0),0,null,sp.t_precision) ||')'),
                  '('|| DECODE(NVL(sp.t_precision,0),0,null,sp.t_precision) || ',' || DECODE(NVL(sp.t_scale,0),0,null,sp.t_scale)||')'),
                  '('||TRIM(DECODE(sp.t_size,'',null,sp.t_size ))||')')
         FROM   dmrs_struct_type_method_pars sp 
         WHERE  return_value= 'Y'
         AND    sp.method_ovid = m.method_ovid)).getClobVal()                                    m_return_type,        
        COUNT(m.method_name) over()                                                              total_row_count,
        m.method_ovid                                                                            method_ovid
FROM dmrs_struct_type_methods m,
     dmrs_structured_types st
WHERE m.structured_type_ovid = st.structured_type_ovid
AND   st.structured_type_ovid = v_st_ovid;
rec_st_methods cur_st_methods%ROWTYPE;

-- Method params
CURSOR cur_st_methods_p(v_m_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':ParameterName'), parameter_name).getClobVal()  param_name,
        XMLElement(EVALNAME(all_st_prefix || ':ParameterType'), 
        type_name  ||' '|| 
                DECODE (NVL(t_size,0),0,
                 DECODE(NVL(t_scale,0),0,
                  DECODE(NVL(t_precision,0),0,null,'('|| DECODE(NVL(t_precision,0),0,null,t_precision) ||')'),
                  '('|| DECODE(NVL(t_precision,0),0,null,t_precision) || ',' || DECODE(NVL(t_scale,0),0,null,t_scale)||')'),
                  '('||TRIM(DECODE(t_size,0,null,t_size ))||')')
        ).getClobVal()       param_type,
        COUNT(parameter_name) over()                                        total_row_count
 FROM   dmrs_struct_type_method_pars
 WHERE  method_ovid = v_m_ovid
 AND    return_value = 'N'
 ORDER BY seq;
rec_st_methods_p cur_st_methods_p%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_st_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(all_st_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(all_st_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                       total_row_count
 FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_structured_types st,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.structured_type_ovid = st.structured_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Structured Type'
 AND    st.structured_type_ovid = v_st_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_st_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_st_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(all_st_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_structured_types st
 WHERE  e.ovid = a.container_ovid
 AND    a.structured_type_ovid = st.structured_type_ovid
 AND    a.datatype_kind = 'Structured Type'
 AND    st.structured_type_ovid = v_st_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all structured types started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':StructuredTypes xmlns:' || all_st_prefix || '="http://oracle.com/datamodeler/reports/structuredtypes">');

  FOR rec_general_data IN cur_general_data(v_model_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

  -- All structured types
  FOR rec_all_st IN cur_all_st(v_model_ovid) LOOP

      IF (cur_all_st%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':STCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':STDetails>');

      DBMS_LOB.APPEND (res, rec_all_st.st_name);
      DBMS_LOB.APPEND (res, rec_all_st.xml_ovid);
      DBMS_LOB.APPEND (res, rec_all_st.super_type);

      -- Description / Notes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

         DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':DescriptionNotes>');

         SELECT XMLElement(EVALNAME(all_st_prefix || ':Description'), XMLCDATA(
                  NVL((SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_st.st_ovid
                      AND    t.type='Comments'),
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_st.st_ovid
                      AND    t.type='CommentsInRDBMS')))).getClobVal(), 
                XMLElement(EVALNAME(all_st_prefix || ':Notes'), XMLCDATA(
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_st.st_ovid
                      AND    t.type='Note'))).getClobVal()
         INTO   v_description, 
                v_notes
         FROM  dual;

        DBMS_LOB.APPEND (res, v_description);
        DBMS_LOB.APPEND (res, v_notes);
        DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':DescriptionNotes>');

      END IF;

       -- Diagrams
       IF (reportTemplate.reportType = 0 OR reportTemplate.useDiagrams = 1) THEN
         FOR rec_diagrams IN cur_diagrams(rec_all_st.st_ovid, v_report_name) LOOP
            IF (cur_diagrams%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':DiagramsCollection>');
            END IF;

              DBMS_LOB.APPEND (res, rec_diagrams.pdf_name);

            IF (cur_diagrams%ROWCOUNT = rec_diagrams.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':DiagramsCollection>');
            END IF;
         END LOOP;
       END IF;

      v_seq := 1;
      -- Attributes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useSTAttributes = 1) THEN
        FOR rec_st_attr IN cur_st_attr(rec_all_st.st_ovid) LOOP
           IF (cur_st_attr%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':AttributesCollection>');
           END IF;

             DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':AttributeDetails>');
             DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':Sequence>' || TO_CHAR(v_seq) || '</' || all_st_prefix || ':Sequence>');
             DBMS_LOB.APPEND (res, rec_st_attr.attr_name);
             DBMS_LOB.APPEND (res, rec_st_attr.m);
             IF (INSTR(LOWER(rec_st_attr.data_type),'unknown') = 0) THEN
                DBMS_LOB.APPEND (res, rec_st_attr.data_type);
             ELSE
                SELECT XMLElement(EVALNAME(all_st_prefix || ':DataType'), '').getClobVal() INTO token_value FROM dual;
                DBMS_LOB.APPEND (res, token_value);
             END IF;
             DBMS_LOB.APPEND (res, rec_st_attr.dt_kind);
             DBMS_LOB.APPEND (res, rec_st_attr.domain_name);
             DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':AttributeDetails>');

           IF (cur_st_attr%ROWCOUNT = rec_st_attr.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':AttributesCollection>');
           END IF;
           v_seq := v_seq + 1;
        END LOOP;
      END IF;

      v_seq := 1;
      -- Attribute Comments
      IF (reportTemplate.reportType = 0 OR reportTemplate.useSTAttributesComments = 1) THEN
        FOR rec_attributes_comments IN cur_attributes_comments(rec_all_st.st_ovid) LOOP
           IF (cur_attributes_comments%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':AttributesCommentsCollection>');
           END IF;

            DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':AttributeCommentsDetails>');

            DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':AttributeCommentsSequence>' || TO_CHAR(v_seq) || '</' || all_st_prefix || ':AttributeCommentsSequence>');
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_name);
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_description);
            DBMS_LOB.APPEND (res, rec_attributes_comments.attribute_notes); 
            DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':AttributeCommentsDetails>');

           IF (cur_attributes_comments%ROWCOUNT = rec_attributes_comments.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':AttributesCommentsCollection>');
           END IF;
           v_seq := v_seq + 1;
        END LOOP;
      END IF;

      v_seq := 1;
      IF (reportTemplate.reportType = 0 OR reportTemplate.useSTMethods = 1) THEN
        FOR rec_st_methods IN cur_st_methods(rec_all_st.st_ovid) LOOP
           IF (cur_st_methods%ROWCOUNT = 1) THEN
             DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':MethodsCollection>');
           END IF;

               DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':MethodDetails>');
               DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':MethodSequence>' || TO_CHAR(v_seq) || '</' || all_st_prefix || ':MethodSequence>');
               DBMS_LOB.APPEND (res, rec_st_methods.m_name);
               DBMS_LOB.APPEND (res, rec_st_methods.m_constr);
               DBMS_LOB.APPEND (res, rec_st_methods.m_overriding);
               DBMS_LOB.APPEND (res, rec_st_methods.m_om_name);
               DBMS_LOB.APPEND (res, rec_st_methods.m_return_type);

               FOR rec_st_methods_p IN cur_st_methods_p(rec_st_methods.method_ovid) LOOP
                  IF (cur_st_methods_p%ROWCOUNT = 1) THEN
                    DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':MethodParametersCollection>');
                  END IF;

                    DBMS_LOB.APPEND (res, '<' || all_st_prefix || ':MethodParameterDetails>');
                    DBMS_LOB.APPEND (res, rec_st_methods_p.param_name);
                    DBMS_LOB.APPEND (res, rec_st_methods_p.param_type);
                    DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':MethodParameterDetails>');

                  IF (cur_st_methods_p%ROWCOUNT = rec_st_methods_p.total_row_count) THEN
                    DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':MethodParametersCollection>');
                  END IF;
               END LOOP;       

               DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':MethodDetails>');

           IF (cur_st_methods%ROWCOUNT = rec_st_methods.total_row_count) THEN
             DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':MethodsCollection>');
           END IF;
           v_seq := v_seq + 1;
        END LOOP;
      END IF;

      -- Used in tables
      IF (reportTemplate.reportType = 0 OR reportTemplate.useSTUsedInTables = 1) THEN
        FOR rec_used_in_tables IN cur_used_in_tables(rec_all_st.st_ovid) LOOP
           IF (cur_used_in_tables%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':TablesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':TableDetails>');

              v_model_name := rec_used_in_tables.model_name;
              IF (v_model_name != p_model_name) THEN
                DBMS_LOB.APPEND (res,v_model_name);
                p_model_name := v_model_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':ModelName></' || all_st_prefix || ':ModelName>');
              END IF;

              v_table_name := rec_used_in_tables.table_name;
              IF (v_table_name != p_table_name) THEN
              DBMS_LOB.APPEND (res,v_table_name);
                p_table_name := v_table_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':TableName></' || all_st_prefix || ':TableName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
              DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':TableDetails>');
           IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':TablesCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Used in entities
      IF (reportTemplate.reportType = 0 OR reportTemplate.useSTUsedInEntities = 1) THEN
        FOR rec_used_in_entities IN cur_used_in_entities(rec_all_st.st_ovid) LOOP
           IF (cur_used_in_entities%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':EntitiesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':EntityDetails>');

              v_entity_name := rec_used_in_entities.entity_name;
              IF (v_entity_name != p_entity_name) THEN
                DBMS_LOB.APPEND (res,v_entity_name);
                p_entity_name := v_entity_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_st_prefix || ':EntityName></' || all_st_prefix || ':EntityName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
              DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':EntityDetails>');
           IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_st_prefix || ':EntitiesCollection>');
           END IF;
        END LOOP;
      END IF;

      DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':STDetails>');

      IF (cur_all_st%ROWCOUNT = rec_all_st.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':STCollection>');
      END IF;

  END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_st_prefix || ':StructuredTypes>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all structured types ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllST_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllST_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllST_Data;

FUNCTION Gather_SingleCT_Data(v_ct_type_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

-- General data
CURSOR cur_general_data(v_ct_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_ct_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(single_ct_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(single_ct_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(single_ct_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m,
        dmrs_collection_types ct
 WHERE  d.design_ovid = m.design_ovid
 AND    ct.model_ovid = m.model_ovid
 AND    ct.collection_type_ovid = v_ct_ovid;
rec_general_data cur_general_data%ROWTYPE;

CURSOR cur_ct_data(v_ct_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(single_ct_prefix || ':CTName'),ct.collection_type_name).getClobVal()                                                                                   ct_name,
         XMLElement(EVALNAME(single_ct_prefix || ':CTType'),ct.c_type).getClobVal()                                                                                                 ct_type,
         XMLElement(EVALNAME(single_ct_prefix || ':CTMaxElements'),ct.max_element).getClobVal()                                                                                     max_element,
         XMLElement(EVALNAME(single_ct_prefix || ':CTDataTypeKind'),DECODE(ct.datatype_kind,
                                                  'Domain',         'DOM',
                                                  'Logical Type',   'LT',
                                                  'Distinct Type',  'DT',
                                                  'Ref Struct Type','RST',
                                                  'Structured Type','ST',
                                                  'Collection Type','CT')
                   ).getClobVal()                                                                                                                               dt_kind,
          XMLElement(EVALNAME(single_ct_prefix || ':CTDataType'), 
             DECODE(ct.datatype_kind, 
                  'Domain', ct.dt_type ||' '||
                           DECODE (NVL(ct.t_size,''),'',
                              DECODE(NVL(ct.t_scale,0),0,
                                 DECODE(NVL(ct.t_precision,0),0,null,'('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) ||')'),
                                   '('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) || ',' || DECODE(NVL(ct.t_scale,0),0,null,ct.t_scale)||')'),
                                   '('||TRIM(DECODE(ct.t_size,'',null,ct.t_size||' '||ct.char_units ))||')'),
                   'Logical Type', ct.dt_type  ||' '|| 
                           DECODE (NVL(ct.t_size,''),'',
                              DECODE(NVL(ct.t_scale,0),0,
                                 DECODE(NVL(ct.t_precision,0),0,null,'('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) ||')'),
                                   '('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) || ',' || DECODE(NVL(ct.t_scale,0),0,null,ct.t_scale)||')'),
                                   '('||TRIM(DECODE(ct.t_size,'',null,ct.t_size||' '||ct.char_units ))||')')
             )).getClobVal()                                                                                                                                    data_type,
       XMLElement(EVALNAME(single_ct_prefix || ':CTDomainName'),DECODE(ct.domain_name,'Unknown',null,ct.domain_name)).getClobVal()                                                   domain_name
 FROM  dmrs_collection_types ct
 WHERE ct.collection_type_ovid = v_ct_ovid;
rec_ct_data cur_ct_data%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_ct_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_ct_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(single_ct_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(single_ct_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                       total_row_count
FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_collection_types ct,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.collection_type_ovid = ct.collection_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Collection Type'
 AND    ct.collection_type_ovid = v_ct_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_ct_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_ct_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(single_ct_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_collection_types ct
 WHERE  e.ovid = a.container_ovid
 AND    a.collection_type_ovid = ct.collection_type_ovid
 AND    a.datatype_kind = 'Collection Type'
 AND    ct.collection_type_ovid = v_ct_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single collection type started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':CollectionType xmlns:' || single_ct_prefix || '="http://oracle.com/datamodeler/reports/collectiontype">');

  FOR rec_general_data IN cur_general_data(v_ct_type_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

   -- Description / Notes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

      DBMS_LOB.APPEND (res, '<' || single_ct_prefix || ':DescriptionNotes>');

      SELECT  XMLElement(EVALNAME(single_ct_prefix || ':Description'), XMLCDATA(
                NVL((SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_ct_type_ovid
                    AND    t.type='Comments'),
                    (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_ct_type_ovid
                    AND    t.type='CommentsInRDBMS')))).getClobVal(),
              XMLElement(EVALNAME(single_ct_prefix || ':Notes'), XMLCDATA(
                    (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_ct_type_ovid
                    AND    t.type='Note'))).getClobVal()
      INTO   v_description, 
             v_notes
      FROM  dual;

      DBMS_LOB.APPEND (res, v_description);
      DBMS_LOB.APPEND (res, v_notes);
      DBMS_LOB.APPEND (res, '</' || single_ct_prefix || ':DescriptionNotes>');

   END IF;

   FOR rec_ct_data IN cur_ct_data(v_ct_type_ovid) LOOP
      DBMS_LOB.APPEND (res, rec_ct_data.ct_name);
      DBMS_LOB.APPEND (res, rec_ct_data.ct_type);
      DBMS_LOB.APPEND (res, rec_ct_data.max_element);
      DBMS_LOB.APPEND (res, rec_ct_data.data_type);
      DBMS_LOB.APPEND (res, rec_ct_data.dt_kind);
      DBMS_LOB.APPEND (res, rec_ct_data.domain_name);
   END LOOP;

   -- Used in tables
   IF (reportTemplate.reportType = 0 OR reportTemplate.useCTUsedInTables = 1) THEN
     FOR rec_used_in_tables IN cur_used_in_tables(v_ct_type_ovid) LOOP
        IF (cur_used_in_tables%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':TablesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':TableDetails>');

           v_model_name := rec_used_in_tables.model_name;
           IF (v_model_name != p_model_name) THEN
             DBMS_LOB.APPEND (res,v_model_name);
             p_model_name := v_model_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':ModelName></' || single_ct_prefix || ':ModelName>');
           END IF;

           v_table_name := rec_used_in_tables.table_name;
           IF (v_table_name != p_table_name) THEN
           DBMS_LOB.APPEND (res,v_table_name);
             p_table_name := v_table_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':TableName></' || single_ct_prefix || ':TableName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
           DBMS_LOB.APPEND (res,'</' || single_ct_prefix || ':TableDetails>');
        IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_ct_prefix || ':TablesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Used in entities
   IF (reportTemplate.reportType = 0 OR reportTemplate.useCTUsedInEntities = 1) THEN
     FOR rec_used_in_entities IN cur_used_in_entities(v_ct_type_ovid) LOOP
        IF (cur_used_in_entities%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':EntitiesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':EntityDetails>');

           v_entity_name := rec_used_in_entities.entity_name;
           IF (v_entity_name != p_entity_name) THEN
             DBMS_LOB.APPEND (res,v_entity_name);
             p_entity_name := v_entity_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_ct_prefix || ':EntityName></' || single_ct_prefix || ':EntityName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
           DBMS_LOB.APPEND (res,'</' || single_ct_prefix || ':EntityDetails>');
        IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_ct_prefix || ':EntitiesCollection>');
        END IF;
     END LOOP;
   END IF;

  DBMS_LOB.APPEND (res,'</' || single_ct_prefix || ':CollectionType>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single collection type ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleCT_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleCT_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_SingleCT_Data;

FUNCTION Gather_AllCT_Data(v_model_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, objects IN OBJECTS_LIST) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

CURSOR cur_general_data(v_m_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(all_ct_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_ct_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_ct_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(all_ct_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m
 WHERE  d.design_ovid = m.design_ovid
 AND    m.model_ovid = v_model_ovid;
rec_general_data cur_general_data%ROWTYPE;

-- All collection types data 
CURSOR cur_all_ct_data(v_m_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(all_ct_prefix || ':CTName'),ct.collection_type_name).getClobVal()                                                                                   ct_name,
		 XMLElement(EVALNAME(all_ct_prefix || ':EncodedName'),ct.collection_type_ovid).getClobVal()                                                                              xml_ovid,
 		 XMLElement(EVALNAME(all_ct_prefix || ':CTType'),ct.c_type).getClobVal()                                                                                                 ct_type,
         XMLElement(EVALNAME(all_ct_prefix || ':CTMaxElements'),ct.max_element).getClobVal()                                                                                     max_element,
         XMLElement(EVALNAME(all_ct_prefix || ':CTDataTypeKind'),DECODE(ct.datatype_kind,
                                                  'Domain',         'DOM',
                                                  'Logical Type',   'LT',
                                                  'Distinct Type',  'DT',
                                                  'Ref Struct Type','RST',
                                                  'Structured Type','ST',
                                                  'Collection Type','CT')
                   ).getClobVal()                                                                                                                               dt_kind,
          XMLElement(EVALNAME(all_ct_prefix || ':CTDataType'), 
             DECODE(ct.datatype_kind, 
                  'Domain', ct.dt_type ||' '||
                           DECODE (NVL(ct.t_size,''),'',
                              DECODE(NVL(ct.t_scale,0),0,
                                 DECODE(NVL(ct.t_precision,0),0,null,'('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) ||')'),
                                   '('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) || ',' || DECODE(NVL(ct.t_scale,0),0,null,ct.t_scale)||')'),
                                   '('||TRIM(DECODE(ct.t_size,'',null,ct.t_size||' '||ct.char_units ))||')'),
                   'Logical Type', ct.dt_type  ||' '|| 
                           DECODE (NVL(ct.t_size,''),'',
                              DECODE(NVL(ct.t_scale,0),0,
                                 DECODE(NVL(ct.t_precision,0),0,null,'('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) ||')'),
                                   '('|| DECODE(NVL(ct.t_precision,0),0,null,ct.t_precision) || ',' || DECODE(NVL(ct.t_scale,0),0,null,ct.t_scale)||')'),
                                   '('||TRIM(DECODE(ct.t_size,'',null,ct.t_size||' '||ct.char_units ))||')')
             )).getClobVal()                                                                                                                                    data_type,
       XMLElement(EVALNAME(all_ct_prefix || ':CTDomainName'),DECODE(ct.domain_name,'Unknown',null,ct.domain_name)).getClobVal()                                                   domain_name,
       ct.collection_type_ovid                                                                                                                                  ct_ovid,
       COUNT(ct.collection_type_name) over()                                                                                                                    total_row_count
 FROM  dmrs_collection_types ct
 WHERE ct.model_ovid = v_m_ovid
 AND   ct.collection_type_ovid MEMBER OF objects
 ORDER BY ct.collection_type_name;
rec_all_ct_data cur_all_ct_data%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_ct_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_ct_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(all_ct_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(all_ct_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                       total_row_count
FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_collection_types ct,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.collection_type_ovid = ct.collection_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Collection Type'
 AND    ct.collection_type_ovid = v_ct_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_ct_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_ct_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(all_ct_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_collection_types ct
 WHERE  e.ovid = a.container_ovid
 AND    a.collection_type_ovid = ct.collection_type_ovid
 AND    a.datatype_kind = 'Collection Type'
 AND    ct.collection_type_ovid = v_ct_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all collection types started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':CollectionTypes xmlns:' || all_ct_prefix || '="http://oracle.com/datamodeler/reports/collectiontypes">');

  FOR rec_general_data IN cur_general_data(v_model_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

  -- All structured types
  FOR rec_all_ct_data IN cur_all_ct_data(v_model_ovid) LOOP

      IF (cur_all_ct_data%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':CTCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':CTDetails>');

      -- Description / Notes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

         DBMS_LOB.APPEND (res, '<' || all_ct_prefix || ':DescriptionNotes>');

         SELECT XMLElement(EVALNAME(all_ct_prefix || ':Description'), XMLCDATA(
                  NVL((SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_ct_data.ct_ovid
                      AND    t.type='Comments'),
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_ct_data.ct_ovid
                      AND    t.type='CommentsInRDBMS')))).getClobVal(),
                XMLElement(EVALNAME(all_ct_prefix || ':Notes'), XMLCDATA(
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_ct_data.ct_ovid
                      AND    t.type='Note'))).getClobVal()
         INTO   v_description, 
                v_notes
         FROM  dual;

        DBMS_LOB.APPEND (res, v_description);
        DBMS_LOB.APPEND (res, v_notes);
        DBMS_LOB.APPEND (res, '</' || all_ct_prefix || ':DescriptionNotes>');

      END IF;

      DBMS_LOB.APPEND (res, rec_all_ct_data.ct_name);
      DBMS_LOB.APPEND (res, rec_all_ct_data.xml_ovid);
      DBMS_LOB.APPEND (res, rec_all_ct_data.ct_type);
      DBMS_LOB.APPEND (res, rec_all_ct_data.max_element);
      DBMS_LOB.APPEND (res, rec_all_ct_data.dt_kind);
      DBMS_LOB.APPEND (res, rec_all_ct_data.data_type);
      DBMS_LOB.APPEND (res, rec_all_ct_data.domain_name);

      -- Used in tables
      IF (reportTemplate.reportType = 0 OR reportTemplate.useCTUsedInTables = 1) THEN
        FOR rec_used_in_tables IN cur_used_in_tables(rec_all_ct_data.ct_ovid) LOOP
           IF (cur_used_in_tables%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':TablesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':TableDetails>');

              v_model_name := rec_used_in_tables.model_name;
              IF (v_model_name != p_model_name) THEN
                DBMS_LOB.APPEND (res,v_model_name);
                p_model_name := v_model_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':ModelName></' || all_ct_prefix || ':ModelName>');
              END IF;

              v_table_name := rec_used_in_tables.table_name;
              IF (v_table_name != p_table_name) THEN
              DBMS_LOB.APPEND (res,v_table_name);
                p_table_name := v_table_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':TableName></' || all_ct_prefix || ':TableName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
              DBMS_LOB.APPEND (res,'</' || all_ct_prefix || ':TableDetails>');
           IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_ct_prefix || ':TablesCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Used in entities
      IF (reportTemplate.reportType = 0 OR reportTemplate.useCTUsedInEntities = 1) THEN
        FOR rec_used_in_entities IN cur_used_in_entities(rec_all_ct_data.ct_ovid) LOOP
           IF (cur_used_in_entities%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':EntitiesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':EntityDetails>');

              v_entity_name := rec_used_in_entities.entity_name;
              IF (v_entity_name != p_entity_name) THEN
                DBMS_LOB.APPEND (res,v_entity_name);
                p_entity_name := v_entity_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_ct_prefix || ':EntityName></' || all_ct_prefix || ':EntityName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
              DBMS_LOB.APPEND (res,'</' || all_ct_prefix || ':EntityDetails>');
           IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_ct_prefix || ':EntitiesCollection>');
           END IF;
        END LOOP;
      END IF;

      DBMS_LOB.APPEND (res,'</' || all_ct_prefix || ':CTDetails>');

      IF (cur_all_ct_data%ROWCOUNT = rec_all_ct_data.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</' || all_ct_prefix || ':CTCollection>');
      END IF;

  END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_ct_prefix || ':CollectionTypes>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all collection types ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllCT_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllCT_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllCT_Data;

FUNCTION Gather_SingleDT_Data(v_dt_type_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

-- General data
CURSOR cur_general_data(v_dt_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_dt_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(single_dt_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(single_dt_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(single_dt_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m,
        dmrs_distinct_types dt
 WHERE  d.design_ovid = m.design_ovid
 AND    dt.model_ovid = m.model_ovid
 AND    dt.distinct_type_ovid = v_dt_ovid;
rec_general_data cur_general_data%ROWTYPE;

-- Distinct type data
CURSOR cur_dt_data(v_ct_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(single_dt_prefix || ':DTName'),dt.distinct_type_name).getClobVal()                             dt_name,
         XMLElement(EVALNAME(single_dt_prefix || ':DTLogicalType'),dt.logical_type_name).getClobVal()                       lt_type,
         XMLElement(EVALNAME(single_dt_prefix || ':DTSize'),DECODE(dt.t_size,'0','',dt.t_size)).getClobVal()                dt_size,
         XMLElement(EVALNAME(single_dt_prefix || ':DTPrecision'),DECODE(dt.t_precision,'0','',dt.t_precision)).getClobVal() dt_precision,
         XMLElement(EVALNAME(single_dt_prefix || ':DTScale'),DECODE(dt.t_scale,'0','',dt.t_scale)).getClobVal()             dt_scale
 FROM  dmrs_distinct_types dt
 WHERE dt.distinct_type_ovid = v_ct_ovid;
rec_dt_data cur_dt_data%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_dt_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_dt_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(single_dt_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(single_dt_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                       total_row_count
FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_distinct_types dt,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.distinct_type_ovid = dt.distinct_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Distinct Type'
 AND    dt.distinct_type_ovid = v_dt_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_dt_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(single_dt_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(single_dt_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_distinct_types dt
 WHERE  e.ovid = a.container_ovid
 AND    a.distinct_type_ovid = dt.distinct_type_ovid
 AND    a.datatype_kind = 'Distinct Type'
 AND    dt.distinct_type_ovid = v_dt_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single distinct type started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':DistinctType xmlns:' || single_dt_prefix || '="http://oracle.com/datamodeler/reports/distincttype">');

  FOR rec_general_data IN cur_general_data(v_dt_type_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);  
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

   -- Description / Notes
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

      DBMS_LOB.APPEND (res, '<' || single_dt_prefix || ':DescriptionNotes>');

      SELECT  XMLElement(EVALNAME(single_dt_prefix || ':Description'), XMLCDATA(
                NVL((SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_dt_type_ovid
                    AND    t.type='Comments'),
                  (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_dt_type_ovid
                    AND    t.type='CommentsInRDBMS')))).getClobVal(), 
              XMLElement(EVALNAME(single_dt_prefix || ':Notes'), XMLCDATA(
                    (SELECT t.text comments_in_rdbms
                    FROM   dmrs_large_text t
                    WHERE  t.ovid = v_dt_type_ovid
                    AND    t.type='Note'))).getClobVal()
      INTO   v_description, 
             v_notes
      FROM  dual;

      DBMS_LOB.APPEND (res, v_description);
      DBMS_LOB.APPEND (res, v_notes);
      DBMS_LOB.APPEND (res, '</' || single_dt_prefix || ':DescriptionNotes>');

   END IF;

   FOR rec_dt_data IN cur_dt_data(v_dt_type_ovid) LOOP
      DBMS_LOB.APPEND (res, rec_dt_data.dt_name);
      DBMS_LOB.APPEND (res, rec_dt_data.lt_type);
      DBMS_LOB.APPEND (res, rec_dt_data.dt_size);
      DBMS_LOB.APPEND (res, rec_dt_data.dt_precision);
      DBMS_LOB.APPEND (res, rec_dt_data.dt_scale);
   END LOOP;

   -- Used in tables
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDTUsedInTables = 1) THEN
     FOR rec_used_in_tables IN cur_used_in_tables(v_dt_type_ovid) LOOP
        IF (cur_used_in_tables%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':TablesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':TableDetails>');

           v_model_name := rec_used_in_tables.model_name;
           IF (v_model_name != p_model_name) THEN
             DBMS_LOB.APPEND (res,v_model_name);
             p_model_name := v_model_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':ModelName></' || single_dt_prefix || ':ModelName>');
           END IF;

           v_table_name := rec_used_in_tables.table_name;
           IF (v_table_name != p_table_name) THEN
           DBMS_LOB.APPEND (res,v_table_name);
             p_table_name := v_table_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':TableName></' || single_dt_prefix || ':TableName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
           DBMS_LOB.APPEND (res,'</' || single_dt_prefix || ':TableDetails>');
        IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_dt_prefix || ':TablesCollection>');
        END IF;
     END LOOP;
   END IF;

   -- Used in entities
   IF (reportTemplate.reportType = 0 OR reportTemplate.useDTUsedInEntities = 1) THEN
     FOR rec_used_in_entities IN cur_used_in_entities(v_dt_type_ovid) LOOP
        IF (cur_used_in_entities%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':EntitiesCollection>');
        END IF;
           DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':EntityDetails>');

           v_entity_name := rec_used_in_entities.entity_name;
           IF (v_entity_name != p_entity_name) THEN
             DBMS_LOB.APPEND (res,v_entity_name);
             p_entity_name := v_entity_name;
           ELSE
             DBMS_LOB.APPEND (res,'<' || single_dt_prefix || ':EntityName></' || single_dt_prefix || ':EntityName>');
           END IF;

           DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
           DBMS_LOB.APPEND (res,'</' || single_dt_prefix || ':EntityDetails>');
        IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
           DBMS_LOB.APPEND (res, '</' || single_dt_prefix || ':EntitiesCollection>');
        END IF;
     END LOOP;
   END IF;

  DBMS_LOB.APPEND (res,'</' || single_dt_prefix || ':DistinctType>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for single distinct type ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleDT_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_SingleDT_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_SingleDT_Data;

FUNCTION Gather_AllDT_Data(v_model_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE, objects IN OBJECTS_LIST) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';
p_table_name      VARCHAR2(100) :='_';
v_table_name      VARCHAR2(100) :='';
p_entity_name     VARCHAR2(100) :='_';
v_entity_name     VARCHAR2(100) :='';

CURSOR cur_general_data(v_m_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(all_dt_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_dt_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_dt_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment,
        XMLElement(EVALNAME(all_dt_prefix || ':ModelName'),m.model_name).getClobVal()                                          model_name
 FROM   dmrs_designs d, 
        dmrs_models m
 WHERE  d.design_ovid = m.design_ovid
 AND    m.model_ovid = v_model_ovid;
rec_general_data cur_general_data%ROWTYPE;

-- All distinct types data 
CURSOR cur_all_dt_data(v_m_ovid IN VARCHAR2) IS
 SELECT  XMLElement(EVALNAME(all_dt_prefix || ':DTName'),dt.distinct_type_name).getClobVal()                             dt_name,
		 XMLElement(EVALNAME(all_dt_prefix || ':EncodedName'),dt.distinct_type_ovid).getClobVal()   	                 xml_ovid,
		 XMLElement(EVALNAME(all_dt_prefix || ':DTLogicalType'),dt.logical_type_name).getClobVal()                       lt_type,
         XMLElement(EVALNAME(all_dt_prefix || ':DTSize'),DECODE(dt.t_size,'0','',dt.t_size)).getClobVal()                dt_size,
         XMLElement(EVALNAME(all_dt_prefix || ':DTPrecision'),DECODE(dt.t_precision,'0','',dt.t_precision)).getClobVal() dt_precision,
         XMLElement(EVALNAME(all_dt_prefix || ':DTScale'),DECODE(dt.t_scale,'0','',dt.t_scale)).getClobVal()             dt_scale,
         dt.distinct_type_ovid                                                                                           dt_ovid,
         COUNT(dt.distinct_type_name) over()                                                                             total_row_count
 FROM  dmrs_distinct_types dt
 WHERE dt.model_ovid = v_m_ovid
 AND   dt.distinct_type_ovid MEMBER OF objects
 ORDER BY dt.distinct_type_name;
rec_all_dt_data cur_all_dt_data%ROWTYPE;

-- Used In tables
CURSOR cur_used_in_tables(v_dt_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_dt_prefix || ':ModelName'), m.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(all_dt_prefix || ':TableName'), t.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(all_dt_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(m.model_name) over()                                                         total_row_count
FROM   dmrs_tables t,
        dmrs_columns c,
        dmrs_distinct_types dt,
        dmrs_models  m
 WHERE  t.ovid = c.container_ovid
 AND    c.distinct_type_ovid = dt.distinct_type_ovid
 AND    m.model_ovid = t.model_ovid
 AND    c.datatype_kind = 'Distinct Type'
 AND    dt.distinct_type_ovid = v_dt_ovid
 ORDER BY m.model_name,
          t.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

-- Used In entities
CURSOR cur_used_in_entities(v_dt_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_dt_prefix || ':EntityName'), e.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(all_dt_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(e.entity_name) over()                                           total_row_count
 FROM   dmrs_entities e,
        dmrs_attributes a,
        dmrs_distinct_types dt
 WHERE  e.ovid = a.container_ovid
 AND    a.distinct_type_ovid = dt.distinct_type_ovid
 AND    a.datatype_kind = 'Distinct Type'
 AND    dt.distinct_type_ovid = v_dt_ovid
 ORDER BY e.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all distinct types started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':DistinctTypes xmlns:' || all_dt_prefix || '="http://oracle.com/datamodeler/reports/distincttypes">');

  FOR rec_general_data IN cur_general_data(v_model_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);
    DBMS_LOB.APPEND (res, rec_general_data.model_name);

  END LOOP;

  -- All distinct types
  FOR rec_all_dt_data IN cur_all_dt_data(v_model_ovid) LOOP

      IF (cur_all_dt_data%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':DTCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':DTDetails>');

      -- Description / Notes
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDescriptionInfo = 1) THEN

         DBMS_LOB.APPEND (res, '<' || all_dt_prefix || ':DescriptionNotes>');

         SELECT XMLElement(EVALNAME(all_dt_prefix || ':Description'), XMLCDATA(
                  NVL((SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_dt_data.dt_ovid
                      AND    t.type='Comments'),
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_dt_data.dt_ovid
                      AND    t.type='CommentsInRDBMS')))).getClobVal(), 
                XMLElement(EVALNAME(all_dt_prefix || ':Notes'), XMLCDATA(
                      (SELECT t.text comments_in_rdbms
                      FROM   dmrs_large_text t
                      WHERE  t.ovid = rec_all_dt_data.dt_ovid
                      AND    t.type='Note'))).getClobVal()
         INTO   v_description, 
                v_notes
         FROM  dual;

        DBMS_LOB.APPEND (res, v_description);
        DBMS_LOB.APPEND (res, v_notes);
        DBMS_LOB.APPEND (res, '</' || all_dt_prefix || ':DescriptionNotes>');

      END IF;

      DBMS_LOB.APPEND (res, rec_all_dt_data.dt_name);
      DBMS_LOB.APPEND (res, rec_all_dt_data.xml_ovid);
      DBMS_LOB.APPEND (res, rec_all_dt_data.lt_type);
      DBMS_LOB.APPEND (res, rec_all_dt_data.dt_size);
      DBMS_LOB.APPEND (res, rec_all_dt_data.dt_precision);
      DBMS_LOB.APPEND (res, rec_all_dt_data.dt_scale);

      -- Used in tables
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDTUsedInTables = 1) THEN
        FOR rec_used_in_tables IN cur_used_in_tables(rec_all_dt_data.dt_ovid) LOOP
           IF (cur_used_in_tables%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':TablesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':TableDetails>');

              v_model_name := rec_used_in_tables.model_name;
              IF (v_model_name != p_model_name) THEN
                DBMS_LOB.APPEND (res,v_model_name);
                p_model_name := v_model_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':ModelName></' || all_dt_prefix || ':ModelName>');
              END IF;

              v_table_name := rec_used_in_tables.table_name;
              IF (v_table_name != p_table_name) THEN
              DBMS_LOB.APPEND (res,v_table_name);
                p_table_name := v_table_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':TableName></' || all_dt_prefix || ':TableName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
              DBMS_LOB.APPEND (res,'</' || all_dt_prefix || ':TableDetails>');
           IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_dt_prefix || ':TablesCollection>');
           END IF;
        END LOOP;
      END IF;

      -- Used in entities
      IF (reportTemplate.reportType = 0 OR reportTemplate.useDTUsedInEntities = 1) THEN
        FOR rec_used_in_entities IN cur_used_in_entities(rec_all_dt_data.dt_ovid) LOOP
           IF (cur_used_in_entities%ROWCOUNT = 1) THEN
              DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':EntitiesCollection>');
           END IF;
              DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':EntityDetails>');

              v_entity_name := rec_used_in_entities.entity_name;
              IF (v_entity_name != p_entity_name) THEN
                DBMS_LOB.APPEND (res,v_entity_name);
                p_entity_name := v_entity_name;
              ELSE
                DBMS_LOB.APPEND (res,'<' || all_dt_prefix || ':EntityName></' || all_dt_prefix || ':EntityName>');
              END IF;

              DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
              DBMS_LOB.APPEND (res,'</' || all_dt_prefix || ':EntityDetails>');
           IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
              DBMS_LOB.APPEND (res, '</' || all_dt_prefix || ':EntitiesCollection>');
           END IF;
        END LOOP;
      END IF;

      DBMS_LOB.APPEND (res,'</' || all_dt_prefix || ':DTDetails>');

      IF (cur_all_dt_data%ROWCOUNT = rec_all_dt_data.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</' || all_dt_prefix || ':DTCollection>');
      END IF;

  END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_dt_prefix || ':DistinctTypes>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for all distinct types ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllDT_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllDT_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllDT_Data;

FUNCTION Gather_CR_Data(v_design_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_description     CLOB;
v_reason          CLOB;
v_imp_note        CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;
p_model_name      VARCHAR2(100) :='_';
v_model_name      VARCHAR2(100) :='';

CURSOR cur_general_data(v_d_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(all_cr_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_cr_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_cr_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                     version_comment
 FROM   dmrs_designs d
 WHERE  d.design_ovid = v_d_ovid;
rec_general_data cur_general_data%ROWTYPE;

CURSOR cur_all_cr(v_d_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_cr_prefix || ':CRName'),cr.change_request_name).getClobVal()                  cr_name,
		XMLElement(EVALNAME(all_cr_prefix || ':EncodedName'),cr.change_request_ovid).getClobVal()             xml_ovid,
 		XMLElement(EVALNAME(all_cr_prefix || ':CRReason'), XMLCDATA(cr.reason)).getClobVal()                  cr_reason,
        XMLElement(EVALNAME(all_cr_prefix || ':CRStatus'),cr.request_status).getClobVal()                     cr_status,
        XMLElement(EVALNAME(all_cr_prefix || ':CRCompleted'),cr.is_completed).getClobVal()                    cr_completed,
        XMLElement(EVALNAME(all_cr_prefix || ':CRRequestDate'),cr.request_date_string).getClobVal()           cr_req_date,
        XMLElement(EVALNAME(all_cr_prefix || ':CRCompletionDate'),cr.completion_date_string).getClobVal()     cr_compl_date,
        cr.change_request_ovid                                                                                cr_ovid,
        COUNT(cr.change_request_name) over()                                                                  total_row_count
 FROM   dmrs_change_requests cr
 WHERE  design_ovid = v_d_ovid;
rec_all_cr cur_all_cr%ROWTYPE;

--Impacted Objects
CURSOR cur_i_objects(v_cr_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_cr_prefix || ':ModelName'),cre.element_model_name).getClobVal()    model_name,
        XMLElement(EVALNAME(all_cr_prefix || ':TypeName'),cre.element_type).getClobVal()           type_name,
        XMLElement(EVALNAME(all_cr_prefix || ':ObjectName'),cre.element_name).getClobVal()         obj_name,
        COUNT(cre.element_name) over()                                         total_row_count
 FROM   dmrs_change_request_elements cre
 WHERE  cre.change_request_ovid = v_cr_ovid
 ORDER BY cre.element_model_name,
          cre.element_type,
          cre.element_name;
rec_i_objects cur_i_objects%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for change requests started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':ChangeRequests xmlns:' || all_cr_prefix || '="http://oracle.com/datamodeler/reports/changerequests">');  

  FOR rec_general_data IN cur_general_data(v_design_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);

  END LOOP;

  FOR rec_all_cr IN cur_all_cr(v_design_ovid) LOOP

      IF (cur_all_cr%ROWCOUNT = 1) THEN
           DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':CRCollection>');
      END IF;

      DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':CRDetails>');
      DBMS_LOB.APPEND (res,rec_all_cr.cr_name);
      DBMS_LOB.APPEND (res,rec_all_cr.xml_ovid);

      -- Comments / Notes / Implementation notes
      SELECT 
            XMLElement(EVALNAME(all_cr_prefix || ':CRComment'), XMLCDATA(
              NVL(
               (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = rec_all_cr.cr_ovid
                AND    t.type='Comments'),
               (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = rec_all_cr.cr_ovid
                AND    t.type='CommentsInRDBMS')))).getClobVal(),
            XMLElement(EVALNAME(all_cr_prefix || ':CRNotes'), XMLCDATA(
               (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = rec_all_cr.cr_ovid
                AND    t.type='Note'))).getClobVal(),

            XMLElement(EVALNAME(all_cr_prefix || ':CRImplementationNote'), XMLCDATA(
                (SELECT t.text comments_in_rdbms
                FROM   dmrs_large_text t
                WHERE  t.ovid = rec_all_cr.cr_ovid
                AND    t.type='Implementation Note'))).getClobVal()
      INTO  v_description, 
            v_notes,
            v_imp_note
      FROM  dual;

      DBMS_LOB.APPEND (res, v_description);
      DBMS_LOB.APPEND (res, v_notes);
      DBMS_LOB.APPEND (res,rec_all_cr.cr_reason);
      DBMS_LOB.APPEND (res,rec_all_cr.cr_status);
      DBMS_LOB.APPEND (res,rec_all_cr.cr_completed);
      DBMS_LOB.APPEND (res,rec_all_cr.cr_req_date);
      DBMS_LOB.APPEND (res,rec_all_cr.cr_compl_date);
      DBMS_LOB.APPEND (res, v_imp_note);

      -- Impacted Objects
      IF (reportTemplate.reportType = 0 OR reportTemplate.useCRImpactedObjects = 1) THEN
        FOR rec_i_objects IN cur_i_objects(rec_all_cr.cr_ovid) LOOP

             IF (cur_i_objects%ROWCOUNT = 1) THEN
                DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':CRUsedInObjectCollection>');
             END IF;
                DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':CRUsedInObjectDetails>');

                v_model_name := rec_i_objects.model_name;
                IF (v_model_name != p_model_name) THEN
                  DBMS_LOB.APPEND (res,v_model_name);
                  p_model_name := v_model_name;
                ELSE
                  DBMS_LOB.APPEND (res,'<' || all_cr_prefix || ':ModelName></' || all_cr_prefix || ':ModelName>');
                END IF;

                DBMS_LOB.APPEND (res,rec_i_objects.type_name);
                DBMS_LOB.APPEND (res,rec_i_objects.obj_name);
                DBMS_LOB.APPEND (res,'</' || all_cr_prefix || ':CRUsedInObjectDetails>');
             IF (cur_i_objects%ROWCOUNT = rec_i_objects.total_row_count) THEN
                DBMS_LOB.APPEND (res, '</' || all_cr_prefix || ':CRUsedInObjectCollection>');
             END IF;

        END LOOP;
      END IF;
      DBMS_LOB.APPEND (res,'</' || all_cr_prefix || ':CRDetails>');

      IF (cur_all_cr%ROWCOUNT = rec_all_cr.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</' || all_cr_prefix || ':CRCollection>');
      END IF;

  END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_cr_prefix || ':ChangeRequests>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for change requests ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_CR_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_CR_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_CR_Data;

FUNCTION Gather_MR_Data(v_design_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE) RETURN CLOB IS 

res               CLOB;
v_notes           CLOB;
v_comment         CLOB;
v_rel_total_count INTEGER;
token_value       CLOB;

CURSOR cur_general_data(v_d_ovid IN VARCHAR2) IS
 -- General data
 SELECT XMLElement(EVALNAME(all_mr_prefix || ':DesignName'),d.design_name).getClobVal()                                        design_name,
        XMLElement(EVALNAME(all_mr_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal()   version_date,
        XMLElement(EVALNAME(all_mr_prefix || ':VersionComment'), XMLCDATA(d.version_comments)).getClobVal()                    version_comment
 FROM   dmrs_designs d
 WHERE  d.design_ovid = v_d_ovid;
rec_general_data cur_general_data%ROWTYPE;

CURSOR cur_all_measurements(v_d_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_mr_prefix || ':MName'),mr.measurement_name).getClobVal()             m_name,
        XMLElement(EVALNAME(all_mr_prefix || ':MValue'),mr.measurement_value).getClobVal()           m_value,
        XMLElement(EVALNAME(all_mr_prefix || ':MType'),mr.measurement_type).getClobVal()             m_type,
        XMLElement(EVALNAME(all_mr_prefix || ':MUnit'),mr.measurement_unit).getClobVal()             m_unit,
        XMLElement(EVALNAME(all_mr_prefix || ':MCreationDate'),mr.measurement_cr_date).getClobVal()  m_cr_date,
        XMLElement(EVALNAME(all_mr_prefix || ':MEffectiveDate'),mr.measurement_ef_date).getClobVal() m_ef_date,
        XMLElement(EVALNAME(all_mr_prefix || ':ModelName'),mr.object_model).getClobVal()             obj_model_name,
        XMLElement(EVALNAME(all_mr_prefix || ':ObjectName'),mr.object_name).getClobVal()             object_name,
        XMLElement(EVALNAME(all_mr_prefix || ':TypeName'),mr.object_type).getClobVal()               object_type,
        mr.measurement_ovid                                                                          m_ovid,
        COUNT(mr.measurement_name) over()                                                            total_row_count
 FROM dmrs_measurements mr
 WHERE design_ovid = v_d_ovid;
rec_all_measurements cur_all_measurements%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for measurements started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_mr_prefix || ':Measurements xmlns:' || all_mr_prefix || '="http://oracle.com/datamodeler/reports/measurements">');

  FOR rec_general_data IN cur_general_data(v_design_ovid) LOOP

    DBMS_LOB.APPEND (res, rec_general_data.design_name);
    DBMS_LOB.APPEND (res, rec_general_data.version_date);
    DBMS_LOB.APPEND (res, rec_general_data.version_comment);

  END LOOP;

  IF (reportTemplate.reportType = 0 OR reportTemplate.useMRImpactedObjects = 1) THEN
    FOR rec_all_measurements IN cur_all_measurements(v_design_ovid) LOOP

      IF (cur_all_measurements%ROWCOUNT = 1) THEN
        DBMS_LOB.APPEND (res,'<' || all_mr_prefix || ':MCollection>');
      END IF;
        DBMS_LOB.APPEND (res,'<' || all_mr_prefix || ':MDetails>');
        DBMS_LOB.APPEND (res,rec_all_measurements.m_name);

        -- Comment & Notes
        SELECT  XMLElement(EVALNAME(all_mr_prefix || ':MComment'),XMLCDATA(
                  NVL(( SELECT t.text comments_in_rdbms
                        FROM   dmrs_large_text t
                        WHERE  t.ovid = rec_all_measurements.m_ovid
                        AND    t.type='Comments'),
                        (SELECT t.text comments_in_rdbms
                        FROM   dmrs_large_text t
                        WHERE  t.ovid = rec_all_measurements.m_ovid
                        AND    t.type='CommentsInRDBMS')))).getClobVal(),
                XMLElement(EVALNAME(all_mr_prefix || ':MNotes'),XMLCDATA(
                       (SELECT t.text comments_in_rdbms
                        FROM   dmrs_large_text t
                        WHERE  t.ovid = rec_all_measurements.m_ovid
                        AND    t.type='Note'))).getClobVal()
        INTO  v_comment, 
              v_notes
        FROM dual;

        DBMS_LOB.APPEND (res,v_comment);
        DBMS_LOB.APPEND (res,v_notes);
        DBMS_LOB.APPEND (res,rec_all_measurements.m_value);
        DBMS_LOB.APPEND (res,rec_all_measurements.m_unit);
        DBMS_LOB.APPEND (res,rec_all_measurements.m_type);
        DBMS_LOB.APPEND (res,rec_all_measurements.m_cr_date);
        DBMS_LOB.APPEND (res,rec_all_measurements.m_ef_date);
        DBMS_LOB.APPEND (res,'<' || all_mr_prefix || ':MUsedInObjectCollection>');
        DBMS_LOB.APPEND (res,'<' || all_mr_prefix || ':MUsedInObjectDetails>');
        DBMS_LOB.APPEND (res,rec_all_measurements.obj_model_name);
        DBMS_LOB.APPEND (res,rec_all_measurements.object_type);
        DBMS_LOB.APPEND (res,rec_all_measurements.object_name);
        DBMS_LOB.APPEND (res,'</' || all_mr_prefix || ':MUsedInObjectDetails>');
        DBMS_LOB.APPEND (res,'</' || all_mr_prefix || ':MUsedInObjectCollection>');
        DBMS_LOB.APPEND (res,'</' || all_mr_prefix || ':MDetails>');

      IF (cur_all_measurements%ROWCOUNT = rec_all_measurements.total_row_count) THEN
          DBMS_LOB.APPEND (res,'</' || all_mr_prefix || ':MCollection>');
      END IF;

    END LOOP;
  END IF;

  DBMS_LOB.APPEND (res,'</' || all_mr_prefix || ':Measurements>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering data for measurements ended');  

RETURN res;

 EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_MR_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_MR_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_MR_Data;

FUNCTION Gather_Constraint_Details_HTML(col_attr_ovid VARCHAR2) RETURN CLOB IS

clob_ CLOB;
clob_constraints CLOB;
clob_ranges CLOB;
clob_vl CLOB;

CURSOR cur_c_constraints(v_ovid IN VARCHAR2) IS
 SELECT constraint_name,
        text,
        database_type
 FROM   dmrs_check_constraints
 WHERE  dataelement_ovid = v_ovid
 ORDER BY sequence;
 rec_c_constraints cur_c_constraints % rowtype;

 CURSOR cur_ranges(v_ovid IN VARCHAR2) IS
 SELECT begin_value,
        end_value,
        short_description
 FROM   dmrs_value_ranges
 WHERE  dataelement_ovid = v_ovid
 ORDER BY sequence;
rec_ranges cur_ranges % rowtype;

CURSOR cur_valuelist_columns(v_ovid IN VARCHAR2) IS
 SELECT av.VALUE,
        av.short_description
 FROM   dmrs_avt av,
        dmrs_columns c
 WHERE  c.ovid = av.dataelement_ovid
 AND    av.dataelement_ovid = v_ovid;
rec_valuelist_columns cur_valuelist_columns % rowtype;

BEGIN

    FOR rec_c_constraints IN cur_c_constraints(col_attr_ovid) LOOP
      clob_constraints := clob_constraints 
                                           || '<tr><td>'
                                           || REPLACE(rec_c_constraints.text, Chr(10), '<br/>')
                                           || '</td><td align="center">' 
                                           || rec_c_constraints.database_type 
                                           || '</td></tr>';
    END LOOP;

    FOR rec_ranges IN cur_ranges(col_attr_ovid) LOOP
      clob_ranges := clob_ranges || '<tr><td align="right">' 
                                 || rec_ranges.begin_value 
                                 || '</td><td align="right">' 
                                 || rec_ranges.end_value 
                                 || '</td><td>' 
                                 || REPLACE(rec_ranges.short_description, Chr(10), '<br/>')
                                 || '</td></tr>';
    END LOOP;

    FOR rec_valuelist_columns IN cur_valuelist_columns(col_attr_ovid) LOOP
      clob_vl := clob_vl || '<tr><td align="right">' 
                         || rec_valuelist_columns.VALUE 
                         || '</td><td>' 
                         || REPLACE(rec_valuelist_columns.short_description, Chr(10), '<br/>')
                         || '</td></tr>';

    END LOOP;

    IF (clob_constraints IS NULL AND clob_ranges IS NULL AND clob_vl IS NULL) THEN
      RETURN '';
    ELSE

      clob_ := '<table class="inlineTable">';

      IF clob_constraints IS NOT NULL THEN
        clob_ := clob_ || '<tr><th>';
        clob_ := clob_ || '<table class="inlineTable">';
        clob_ := clob_ || '<tr><th colspan="3">Check Constraint</th></tr>';
        clob_ := clob_ || '<tr><th>Text</th><th>DB Type</th></tr>';
        clob_ := clob_ || clob_constraints;
        clob_ := clob_ || '</table>';
        clob_ := clob_ || '</th></tr>';
      END IF;

      IF clob_ranges IS NOT NULL THEN
        clob_ := clob_ || '<tr><th>';
        clob_ := clob_ || '<table class="inlineTable">';
        clob_ := clob_ || '<tr><th colspan="3">Ranges</th></tr>';
        clob_ := clob_ || '<tr><th>Begin Value</th><th>End Value</th><th>Description</th></tr>';
        clob_ := clob_ || clob_ranges;
        clob_ := clob_ || '</table>';
        clob_ := clob_ || '</th></tr>';
      END IF;

      IF clob_vl IS NOT NULL THEN
        clob_ := clob_ || '<tr><th>';
        clob_ := clob_ || '<table class="inlineTable">';
        clob_ := clob_ || '<tr><th colspan="2">Value List</th></tr>';
        clob_ := clob_ || '<tr><th>Value</th><th>Description</th></tr>';
        clob_ := clob_ || clob_vl;
        clob_ := clob_ || '</table>';
        clob_ := clob_ || '</th></tr>';
      END IF;

      clob_ := clob_ || '</table>';

      RETURN clob_;

    END IF;

EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Constraint_Details_HTML Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Constraint_Details_HTML Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN clob_;

END Gather_Constraint_Details_HTML;

FUNCTION Gather_Domain_Constraints_HTML (domain_ovid VARCHAR2) RETURN CLOB IS

clob_            CLOB;
clob_constraints CLOB;
clob_ranges      CLOB;
clob_vl          CLOB;

CURSOR cur_c_constraints(v_c_ovid IN VARCHAR2) IS
 SELECT NVL(text,' ')           text,
        NVL(database_type,' ')  database_type
 FROM   dmrs_domain_check_constraints
 WHERE  domain_ovid = v_c_ovid
 ORDER BY sequence;
rec_c_constraints cur_c_constraints%rowtype;

CURSOR cur_ranges(v_c_ovid IN VARCHAR2) IS
 SELECT NVL(begin_value,' ')           begin_value,
        NVL(end_value, ' ')            end_value,
        NVL(short_description,' ')     short_description
 FROM   dmrs_domain_value_ranges
 WHERE  domain_ovid = v_c_ovid
 ORDER BY sequence;
rec_ranges cur_ranges%rowtype;

CURSOR cur_valuelist_columns(v_c_ovid IN VARCHAR2) IS
 SELECT NVL(av.value,' ')             value,
        NVL(av.short_description,' ') short_description
 FROM   dmrs_domain_avt av
 WHERE  av.domain_ovid = v_c_ovid;
rec_valuelist_columns cur_valuelist_columns%rowtype;

BEGIN

    DBMS_LOB.CREATETEMPORARY(clob_constraints, TRUE);
    DBMS_LOB.CREATETEMPORARY(clob_ranges, TRUE);
    DBMS_LOB.CREATETEMPORARY(clob_vl, TRUE);
    DBMS_LOB.CREATETEMPORARY(clob_, TRUE);

    FOR rec_c_constraints IN cur_c_constraints(domain_ovid) LOOP
        DBMS_LOB.APPEND (clob_constraints, '<tr><td>');
        DBMS_LOB.APPEND (clob_constraints, REPLACE(rec_c_constraints.text, Chr(10), '<br/>'));
        DBMS_LOB.APPEND (clob_constraints, '</td><td align="center">' );
        DBMS_LOB.APPEND (clob_constraints, rec_c_constraints.database_type );
        DBMS_LOB.APPEND (clob_constraints, '</td></tr>');
    END LOOP;

    FOR rec_ranges IN cur_ranges(domain_ovid) LOOP
        DBMS_LOB.APPEND (clob_ranges,'<tr><td align="right">');
        DBMS_LOB.APPEND (clob_ranges, rec_ranges.begin_value);
        DBMS_LOB.APPEND (clob_ranges,'</td><td align="right">');    
        DBMS_LOB.APPEND (clob_ranges, rec_ranges.end_value);
        DBMS_LOB.APPEND (clob_ranges,'</td><td>');
        DBMS_LOB.APPEND (clob_ranges,REPLACE(rec_ranges.short_description, Chr(10), '<br/>'));
        DBMS_LOB.APPEND (clob_ranges,'</td></tr>');
    END LOOP;

    FOR rec_valuelist_columns IN cur_valuelist_columns(domain_ovid) LOOP
        DBMS_LOB.APPEND (clob_vl,'<tr><td align="right">');
        DBMS_LOB.APPEND (clob_vl,rec_valuelist_columns.VALUE);
        DBMS_LOB.APPEND (clob_vl,'</td><td>'); 
        DBMS_LOB.APPEND (clob_vl,REPLACE(rec_valuelist_columns.short_description, Chr(10), '<br/>'));
        DBMS_LOB.APPEND (clob_vl,'</td></tr>');
    END LOOP;

    IF (clob_constraints IS NULL AND clob_ranges IS NULL AND clob_vl IS NULL) THEN
      RETURN '';
    ELSE

      DBMS_LOB.APPEND (clob_, '<table class="inlineTable">');

      IF clob_constraints IS NOT NULL THEN
         DBMS_LOB.APPEND (clob_,'<tr><th>');
         DBMS_LOB.APPEND (clob_,'<table class="inlineTable">');
         DBMS_LOB.APPEND (clob_,'<tr><th colspan="3">Check Constraint</th></tr>');
         DBMS_LOB.APPEND (clob_,'<tr><th>Text</th><th>DB Type</th></tr>');
         DBMS_LOB.APPEND (clob_,clob_constraints);
         DBMS_LOB.APPEND (clob_,'</table>');
         DBMS_LOB.APPEND (clob_,'</th></tr>');
      END IF;

      IF clob_ranges IS NOT NULL THEN
         DBMS_LOB.APPEND (clob_,'<tr><th>');
         DBMS_LOB.APPEND (clob_,'<table class="inlineTable">');
         DBMS_LOB.APPEND (clob_,'<tr><th colspan="3">Ranges</th></tr>');
         DBMS_LOB.APPEND (clob_,'<tr><th>Begin Value</th><th>End Value</th><th>Description</th></tr>');
         DBMS_LOB.APPEND (clob_,clob_ranges);
         DBMS_LOB.APPEND (clob_,'</table>');
         DBMS_LOB.APPEND (clob_,'</th></tr>');
      END IF;

      IF clob_vl IS NOT NULL THEN
         DBMS_LOB.APPEND (clob_,'<tr><th>');
         DBMS_LOB.APPEND (clob_,'<table class="inlineTable">');
         DBMS_LOB.APPEND (clob_,'<tr><th colspan="2">Value List</th></tr>');
         DBMS_LOB.APPEND (clob_,'<tr><th>Value</th><th>Description</th></tr>');
         DBMS_LOB.APPEND (clob_,clob_vl);
         DBMS_LOB.APPEND (clob_,'</table>');
         DBMS_LOB.APPEND (clob_,'</th></tr>');
      END IF;

      DBMS_LOB.APPEND (clob_,'</table>');
    END IF;

 RETURN clob_;

EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Domain_Constraints_HTML Exception : : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Domain_Constraints_HTML Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN clob_;

END Gather_Domain_Constraints_HTML;

FUNCTION Gather_Domain_Constraints_XML(domain_ovid VARCHAR2) RETURN CLOB IS

res          CLOB;
v_cc_created BOOLEAN := FALSE;

CURSOR cur_c_constraints(v_c_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':Text'),d.text).getClobVal()                  text,
        XMLElement(EVALNAME(all_domains_prefix || ':DatabaseType'),d.database_type).getClobVal() database_type,
        COUNT(text) over()                                                                       total_row_count
 FROM   dmrs_domain_check_constraints d
 WHERE  d.domain_ovid = v_c_ovid
 ORDER BY d.database_type;
rec_c_constraints cur_c_constraints%rowtype;

CURSOR cur_ranges(v_c_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':RangeBeginValue'),d.begin_value).getClobVal()             begin_value,
        XMLElement(EVALNAME(all_domains_prefix || ':RangeEndValue'),d.end_value).getClobVal()                 end_value,
        XMLElement(EVALNAME(all_domains_prefix || ':RangeShortDescription'),d.short_description).getClobVal() short_description,
        COUNT(begin_value) over() total_row_count
 FROM   dmrs_domain_value_ranges d
 WHERE  d.domain_ovid = v_c_ovid
 ORDER BY d.begin_value, 
          d.end_value,
          d.short_description;
rec_ranges cur_ranges%rowtype;

CURSOR cur_valuelist_columns(v_c_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':VLValue'),av.value).getClobVal()                         v_value, 
        XMLElement(EVALNAME(all_domains_prefix || ':VLShortDescription'),av.short_description).getClobVal()  short_description,
        COUNT(value) over() total_row_count
 FROM   dmrs_domain_avt av
 WHERE  av.domain_ovid = v_c_ovid
 ORDER BY av.value, 
          av.short_description;
rec_valuelist_columns cur_valuelist_columns%rowtype;

BEGIN

    DBMS_LOB.CREATETEMPORARY(res, TRUE);

    FOR rec_ranges IN cur_ranges(domain_ovid) LOOP
       IF (cur_ranges%ROWCOUNT = 1) THEN
          IF NOT v_cc_created THEN 
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintsCollection>');
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintDetails>');
            v_cc_created := TRUE;
          END IF;
          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':RangesCollection>');
       END IF;
          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':RangeDetails>');
          DBMS_LOB.APPEND (res,rec_ranges.begin_value);
          DBMS_LOB.APPEND (res,rec_ranges.end_value);
          DBMS_LOB.APPEND (res,rec_ranges.short_description);
          DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':RangeDetails>');
       IF (cur_ranges%ROWCOUNT = rec_ranges.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':RangesCollection>');
       END IF;
    END LOOP;

    FOR rec_valuelist_columns IN cur_valuelist_columns(domain_ovid) LOOP
       IF (cur_valuelist_columns%ROWCOUNT = 1) THEN
          IF NOT v_cc_created THEN 
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintsCollection>');
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintDetails>');
            v_cc_created := TRUE;
          END IF;
          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':ValueListsCollection>');
       END IF;
          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':ValueListDetails>');
          DBMS_LOB.APPEND (res,rec_valuelist_columns.v_value);
          DBMS_LOB.APPEND (res,rec_valuelist_columns.short_description);
          DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':ValueListDetails>');
       IF (cur_valuelist_columns%ROWCOUNT = rec_valuelist_columns.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':ValueListsCollection>');
       END IF;
    END LOOP;

    FOR rec_c_constraints IN cur_c_constraints(domain_ovid) LOOP
       IF (cur_c_constraints%ROWCOUNT = 1) THEN
          IF NOT v_cc_created THEN 
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintsCollection>');
            DBMS_LOB.APPEND (res, '<' || all_domains_prefix || ':ConstraintDetails>');
            v_cc_created := TRUE;
          END IF;
          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':CheckConstraintsCollection>');
       END IF;

          DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':CheckConstraintDetails>');
          DBMS_LOB.APPEND (res,rec_c_constraints.text);
          DBMS_LOB.APPEND (res,rec_c_constraints.database_type);
          DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':CheckConstraintDetails>');
       IF (cur_c_constraints%ROWCOUNT = rec_c_constraints.total_row_count) THEN
          DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':CheckConstraintsCollection>');
       END IF;
    END LOOP;

    IF v_cc_created THEN 
       DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':ConstraintDetails>');
       DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':ConstraintsCollection>');
    END IF;

  RETURN res;

EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Domain_Constraints_XML Exception : : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_Domain_Constraints_XML Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_Domain_Constraints_XML;

FUNCTION Gather_AllDomains_Data(v_obj_ovid IN VARCHAR2, reportTemplate IN REPORT_TEMPLATE) RETURN CLOB IS 

res          CLOB;
token_value  CLOB;
v_comment    CLOB;

-- Common Data
CURSOR cur_common_data(v_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':DesignName'),d.design_name).getClobVal()                                      design_name,
        XMLElement(EVALNAME(all_domains_prefix || ':VersionDate'),TO_CHAR(d.date_published,'dd.mm.yyyy hh24:mi:ss')).getClobVal() version_date,
        XMLElement(EVALNAME(all_domains_prefix || ':VersionComment'),XMLCDATA(d.version_comments)).getClobVal()                   version_comment
 FROM   dmrs_designs d
 WHERE  d.design_ovid = v_ovid;
rec_common_data cur_common_data%ROWTYPE;

CURSOR cur_all_domains(v_o_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':DomainName'), d.domain_name).getClobVal()                        domain_name, 
		XMLElement(EVALNAME(all_domains_prefix || ':EncodedName'), d.ovid).getClobVal()                        		 xml_ovid, 
 		XMLElement(EVALNAME(all_domains_prefix || ':Synonyms'), d.synonyms).getClobVal()                             synonyms,
        XMLElement(EVALNAME(all_domains_prefix || ':DataType'), d.native_type  ||' '||
           DECODE (NVL(d.t_size,''),'',
           DECODE(NVL(d.t_scale,0),0,
                DECODE(NVL(d.t_precision,0),0,null,'('|| DECODE(NVL(d.t_precision,0),0,null,d.t_precision) ||')'),
                        '('|| DECODE(NVL(d.t_precision,0),0,null,d.t_precision) || ',' || DECODE(NVL(d.t_scale,0),0,null,d.t_scale)||')'),
       '('||TRIM(DECODE(d.t_size,'',null,d.t_size||' '||d.char_units ))||')')).getClobVal()  data_type,
        XMLElement(EVALNAME(all_domains_prefix || ':LogicalType'), d.lt_name).getClobVal()                           lt_name,
        XMLElement(EVALNAME(all_domains_prefix || ':UnitOfMeasure'), d.unit_of_measure).getClobVal()                 unit_of_measure,
        XMLElement(EVALNAME(all_domains_prefix || ':DefaultValue'), d.default_value).getClobVal()                    default_value,
        Gather_Domain_Constraints_XML(d.ovid)                                               constraint_details,
        d.ovid                                                                              domain_ovid,
        COUNT(d.domain_name) over()                                                         total_row_count
 FROM   dmrs_domains d
 WHERE  d.design_ovid = v_o_ovid
 ORDER BY d. domain_name;
rec_all_domains cur_all_domains%ROWTYPE;

CURSOR cur_used_in_tables(v_d_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':ModelName'), c.model_name).getClobVal()     model_name,
        XMLElement(EVALNAME(all_domains_prefix || ':TableName'), c.table_name).getClobVal()     table_name,
        XMLElement(EVALNAME(all_domains_prefix || ':ColumnName'), c.column_name).getClobVal()   column_name,
        COUNT(c.model_name) over()                                     total_row_count
 FROM   dmrs_columns c,
        dmrs_domains d
 WHERE  d.ovid = v_d_ovid
 AND    c.domain_ovid = d.ovid
 ORDER BY c.model_name,
          c.table_name,
          c.column_name;
rec_used_in_tables cur_used_in_tables%ROWTYPE;

CURSOR cur_used_in_entities(v_d_ovid IN VARCHAR2) IS
 SELECT XMLElement(EVALNAME(all_domains_prefix || ':EntityName'), a.entity_name).getClobVal()        entity_name,
        XMLElement(EVALNAME(all_domains_prefix || ':AttributeName'), a.attribute_name).getClobVal()  attribute_name,
        COUNT(a.entity_name) over()                                         total_row_count
 FROM   dmrs_attributes a,
        dmrs_domains d
 WHERE  d.ovid = v_d_ovid
 AND    a.domain_ovid = d.ovid
 ORDER BY a.entity_name,
          a.attribute_name;
rec_used_in_entities cur_used_in_entities%ROWTYPE;

BEGIN

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering all domains data started ...');

  DBMS_LOB.CREATETEMPORARY(res, TRUE);

  DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':Domains xmlns:' || all_domains_prefix || '="http://oracle.com/datamodeler/reports/domains">');

   -- Common Data
   FOR rec_common_data IN cur_common_data(v_obj_ovid) LOOP

      DBMS_LOB.APPEND (res, rec_common_data.design_name);
      DBMS_LOB.APPEND (res, rec_common_data.version_date);
      DBMS_LOB.APPEND (res, rec_common_data.version_comment);

   END LOOP;

   FOR rec_all_domains IN cur_all_domains(v_obj_ovid) LOOP
      IF (cur_all_domains%ROWCOUNT = 1) THEN
        DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':DomainsCollection>');
      END IF;

        DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':DomainDetails>');

        DBMS_LOB.APPEND (res,rec_all_domains.domain_name);
        DBMS_LOB.APPEND (res,rec_all_domains.xml_ovid);
        DBMS_LOB.APPEND (res,rec_all_domains.synonyms);
        DBMS_LOB.APPEND (res,rec_all_domains.data_type);
        DBMS_LOB.APPEND (res,rec_all_domains.lt_name);
        DBMS_LOB.APPEND (res,rec_all_domains.unit_of_measure);
        DBMS_LOB.APPEND (res,rec_all_domains.default_value);

        BEGIN
            SELECT  XMLElement(EVALNAME(all_domains_prefix || ':DomainComment'), XMLCDATA(lt.text)).getClobVal()
            INTO    v_comment
            FROM    dmrs_large_text lt
            WHERE   lt.ovid = rec_all_domains.domain_ovid;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                SELECT  XMLElement(EVALNAME(all_domains_prefix || ':DomainComment'), '').getClobVal()
                INTO    v_comment
                FROM    dual;
        END;

        DBMS_LOB.APPEND (res,v_comment);

        -- Constraints
        IF (reportTemplate.reportType = 0 OR reportTemplate.useDomainConstraints = 1) THEN
          DBMS_LOB.APPEND (res,rec_all_domains.constraint_details);
        END IF;

        -- Used in tables
        IF (reportTemplate.reportType = 0 OR reportTemplate.useDomainUsedInTables = 1) THEN
          FOR rec_used_in_tables IN cur_used_in_tables(rec_all_domains.domain_ovid) LOOP
             IF (cur_used_in_tables%ROWCOUNT = 1) THEN
                DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':TablesCollection>');
             END IF;
                DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':TableDetails>');
                DBMS_LOB.APPEND (res,rec_used_in_tables.model_name);
                DBMS_LOB.APPEND (res,rec_used_in_tables.table_name);
                DBMS_LOB.APPEND (res,rec_used_in_tables.column_name);
                DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':TableDetails>');
             IF (cur_used_in_tables%ROWCOUNT = rec_used_in_tables.total_row_count) THEN
                DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':TablesCollection>');
             END IF;
          END LOOP;
        END IF;

        -- Used in entities
        IF (reportTemplate.reportType = 0 OR reportTemplate.useDomainUsedInEntities = 1) THEN
          FOR rec_used_in_entities IN cur_used_in_entities(rec_all_domains.domain_ovid) LOOP
             IF (cur_used_in_entities%ROWCOUNT = 1) THEN
                DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':EntitiesCollection>');
             END IF;
                DBMS_LOB.APPEND (res,'<' || all_domains_prefix || ':EntityDetails>');
                DBMS_LOB.APPEND (res,rec_used_in_entities.entity_name);
                DBMS_LOB.APPEND (res,rec_used_in_entities.attribute_name);
                DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':EntityDetails>');
             IF (cur_used_in_entities%ROWCOUNT = rec_used_in_entities.total_row_count) THEN
                DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':EntitiesCollection>');
             END IF;
          END LOOP;
        END IF;

        DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':DomainDetails>');

      IF (cur_all_domains%ROWCOUNT = rec_all_domains.total_row_count) THEN
       DBMS_LOB.APPEND (res, '</' || all_domains_prefix || ':DomainsCollection>');
      END IF;
   END LOOP;

  DBMS_LOB.APPEND (res,'</' || all_domains_prefix || ':Domains>');

  UTL_FILE.PUT_LINE(log_file, TO_CHAR(SYSDATE,'yy.mm.dd hh:mi:ss') ||' '|| 'Gathering all domains data ended');

RETURN res;

EXCEPTION
 WHEN others THEN
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllDomains_Data Exception : ' || SQLERRM);  
  UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Gather_AllDomains_Data Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  RETURN res;

END Gather_AllDomains_Data;  

FUNCTION Create_Log_File(v_reports_dir IN VARCHAR2) RETURN NUMBER IS 

insufficient_privileges EXCEPTION;
PRAGMA EXCEPTION_INIT(insufficient_privileges, -01031);

BEGIN

 IF v_reports_dir IS NOT NULL THEN
  EXECUTE IMMEDIATE 'CREATE OR REPLACE DIRECTORY OSDDM_REPORTS_DIR AS '''|| v_reports_dir ||'''';
  EXECUTE IMMEDIATE 'GRANT READ, WRITE ON DIRECTORY OSDDM_REPORTS_DIR TO PUBLIC';
 END IF;

 log_file := UTL_FILE.Fopen('OSDDM_REPORTS_DIR','osddm_reports.log','w', 32767);

RETURN 0;

 EXCEPTION
  WHEN UTL_FILE.Invalid_Path THEN
   RETURN 1;
  WHEN  UTL_FILE.Read_Error OR UTL_FILE.Write_Error OR UTL_FILE.Access_Denied THEN 
   RETURN 2;
  WHEN insufficient_privileges THEN
   RETURN 3;

END Create_Log_File;

PROCEDURE Generate_Report(v_rep_id           IN NUMBER,
                          v_obj_ovid         IN VARCHAR2,
                          v_mode             IN NUMBER,
                          v_reports_dir      IN VARCHAR2,
                          v_report_name      IN VARCHAR2, 
                          reportTemplate     IN REPORT_TEMPLATE,
                          objects            IN OBJECTS_LIST,
                          v_raw_xml         OUT BFILE, 
                          v_status          OUT NUMBER, 
                          osddm_reports_dir OUT VARCHAR2,
                          v_diagrams        OUT SYS_REFCURSOR,
                          v_diagrams_svg    OUT SYS_REFCURSOR) IS

raw_xml_fn        CONSTANT VARCHAR2(20) := 'report_data_rs.xml';
res               CLOB;
db_data_clob      CLOB;
v_blob						BLOB;
v_blob_xml				BLOB;
v_dest_offset			INTEGER := 1;
v_src_offset			INTEGER := 1;
warning						INTEGER;
rseq              INTEGER;
nseq              INTEGER;
v_lang_context		NUMBER 	:= DBMS_LOB.Default_Lang_Ctx;
v_p_doc_xml_lngth NUMBER;
j_status          NUMBER;
db_version        VARCHAR2(100);

BEGIN

    v_status := Create_Log_File(v_reports_dir);

    IF (v_status = 0)  THEN

      DBMS_LOB.CREATETEMPORARY(v_blob, TRUE);
      DBMS_LOB.CREATETEMPORARY(v_blob_xml, TRUE);
      DBMS_LOB.CREATETEMPORARY(db_data_clob, TRUE);

      DBMS_LOB.APPEND (db_data_clob,'<?xml version = ''1.0'' encoding = ''UTF-8''?>');

      IF v_rep_id = 1 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_SingleTable_Data(v_obj_ovid, reportTemplate, v_report_name));
      ELSIF v_rep_id = 2 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllTables_Data(v_obj_ovid, reportTemplate, objects, v_report_name));
      ELSIF v_rep_id = 3 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_SingleEntity_Data(v_obj_ovid, reportTemplate, v_report_name));
      ELSIF v_rep_id = 4 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllEntities_Data(v_obj_ovid, reportTemplate, objects, v_report_name));
      ELSIF v_rep_id = 5 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllDomains_Data(v_obj_ovid, reportTemplate));
      ELSIF v_rep_id = 6 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_Glossary_Data(v_obj_ovid));
      ELSIF v_rep_id = 7 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_SingleST_Data(v_obj_ovid, reportTemplate, v_report_name));
      ELSIF v_rep_id = 8 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllST_Data(v_obj_ovid, reportTemplate, objects, v_report_name));
      ELSIF v_rep_id = 9 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_SingleCT_Data(v_obj_ovid, reportTemplate));
      ELSIF v_rep_id = 10 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllCT_Data(v_obj_ovid, reportTemplate, objects));
      ELSIF v_rep_id = 11 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_SingleDT_Data(v_obj_ovid, reportTemplate));
      ELSIF v_rep_id = 12 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_AllDT_Data(v_obj_ovid, reportTemplate, objects));
      ELSIF v_rep_id = 13 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_CR_Data(v_obj_ovid, reportTemplate));
      ELSIF v_rep_id = 14 THEN
         DBMS_LOB.APPEND (db_data_clob, Gather_MR_Data(v_obj_ovid, reportTemplate));
      END IF;

      -- Get the PDF diagrams if they are exported
      IF v_rep_id IN(2, 4, 8) THEN
		 -- All Tables, All Entities, All Structured Types
         OPEN v_diagrams FOR
             SELECT pdf_name,
                    diagram_pdf
             FROM   dmrs_vdiagrams
             WHERE  model_ovid = v_obj_ovid
             AND    diagram_type = 'Subview'
             AND    diagram_pdf IS NOT NULL
             AND    is_display = 'N';

      ELSIF v_rep_id IN (1, 3, 7) THEN
		 --Single Table, Single Entity, Single tructured Type
         OPEN v_diagrams FOR
             SELECT d.pdf_name,
                    d.diagram_pdf
             FROM   dmrs_vdiagrams d,
                   (SELECT diagram_ovid 
                    FROM   dmrs_diagram_elements
                    WHERE  ovid = v_obj_ovid) b
             WHERE d.ovid = b.diagram_ovid
             AND   d.diagram_type = 'Subview'
             AND   d.diagram_pdf IS NOT NULL
             AND   d.is_display = 'N';

      END IF;

      -- Get the SVG diagrams if they are exported
      IF v_rep_id IN(2, 4, 8) THEN
		 -- All Tables, All Entities, All Structured Types
         OPEN v_diagrams_svg FOR
             SELECT svg_name,
                    diagram_svg
             FROM   dmrs_vdiagrams
             WHERE  model_ovid = v_obj_ovid
             AND    diagram_type = 'Subview'
             AND    diagram_svg IS NOT NULL
             AND    is_display = 'N';

      ELSIF v_rep_id IN (1, 3, 7) THEN
		 --Single Table, Single Entity, Single tructured Type
         OPEN v_diagrams FOR
             SELECT d.svg_name,
                    d.diagram_svg
             FROM   dmrs_vdiagrams d,
                   (SELECT diagram_ovid 
                    FROM   dmrs_diagram_elements
                    WHERE  ovid = v_obj_ovid) b
             WHERE d.ovid = b.diagram_ovid
             AND   d.diagram_type = 'Subview'
             AND   d.diagram_svg IS NOT NULL
             AND   d.is_display = 'N';

      END IF;

	  SELECT banner
      INTO   db_version
      FROM   v$version
      WHERE  banner LIKE 'Oracle%';

      -- raw xml
      DBMS_LOB.CONVERTTOBLOB(v_blob_xml,
                             db_data_clob,
                             DBMS_LOB.LOBMAXSIZE,
                             v_dest_offset,
                             v_src_offset,
                             873, -- AL32UTF8
                             v_lang_context,
                             warning);
      Generate_OS_File(v_blob_xml, raw_xml_fn);
      v_raw_xml := BFILENAME('OSDDM_REPORTS_DIR', raw_xml_fn);

      UTL_FILE.fclose(log_file);

   END IF;

COMMIT;

   SELECT directory_path
   INTO   osddm_reports_dir
   FROM   all_directories
   WHERE  directory_name = 'OSDDM_REPORTS_DIR';

EXCEPTION

   WHEN others THEN
     ROLLBACK;
     IF (v_mode = 1) THEN
        UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_Report Exception : ' || SQLERRM);  
        UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_Report Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        UTL_FILE.fclose(log_file);
     ELSIF (v_mode = 2) THEN
        htp.p('<br/>');
        htp.p('<br/>');
        htp.p('Error occured during report generation:');
        htp.p('<br/>');
        htp.p('Pkg_Osdm_Utils.Generate_Report Exception:');
        htp.p(sqlerrm);
        htp.p('<br/>');
        htp.p('For more details see the report generation log file in OSDDM_REPORTS_DIR directory.');
        UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_Report Exception : ' || SQLERRM);  
        UTL_FILE.PUT_LINE(log_file, 'Pkg_Osdm_Utils.Generate_Report Exception : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
     END IF;

     IF UTL_FILE.is_open(log_file) THEN
        UTL_FILE.fclose(log_file);
     END IF;
     IF UTL_FILE.is_open(temp_file) THEN
        UTL_FILE.fclose(temp_file);
     END IF;

END Generate_Report;

END PKG_OSDM_UTILS;

/
--------------------------------------------------------
--  DDL for Function DATA_CLEANUP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."DATA_CLEANUP" (P_RUN_DATE VARCHAR2, P_IS_BACKFILL VARCHAR2 DEFAULT 'N') 
RETURN VARCHAR2
IS
    V_PREV_CALENDAR_DAY VARCHAR2(100);
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN

    IF P_IS_BACKFILL = 'Y' 
    THEN   
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_TRADING_CALENDAR';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MKT_DATA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_DATA_STATS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_PIVOTS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_EMA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_SR';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_TRENDS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TRENDS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_DATA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_PREDICT';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_SIGNALS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_TRADE';



    ELSE

        SELECT MAX(PREV_CALENDAR_DAY) 
        INTO V_PREV_CALENDAR_DAY
        FROM D_TRADING_CALENDAR
        WHERE CALENDAR_DAY = P_RUN_DATE;

        DELETE FROM O_MKT_DATA WHERE TICK_TIMESTAMP = P_RUN_DATE;
        DELETE FROM D_MKT_DATA_STATS WHERE TICK_TIMESTAMP = P_RUN_DATE;

        DELETE FROM D_MKT_PIVOTS WHERE PIVOT_TIMESTAMP = V_PREV_CALENDAR_DAY;
        UPDATE D_MKT_PIVOTS
            SET PIVOT_STATUS_TS = NULL,
                PIVOT_STATUS = 'P'
            WHERE PIVOT_STATUS_TS = P_RUN_DATE;
        UPDATE D_MKT_PIVOTS
            SET SIG_PIVOT_STATUS_TS = NULL
            WHERE SIG_PIVOT_STATUS_TS = P_RUN_DATE;

        DELETE FROM D_MKT_TICK_EMA WHERE TICK_TIMESTAMP = P_RUN_DATE;
        DELETE FROM D_MKT_TICK_SR WHERE TICK_TIMESTAMP = P_RUN_DATE;
        DELETE FROM D_MKT_TICK_TRENDS WHERE TICK_TIMESTAMP = P_RUN_DATE;

        DELETE FROM D_MKT_TRENDS WHERE TREND_START_TS = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_START_STATUS_TS = NULL
        WHERE TREND_START_STATUS_TS = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_END_STATUS_TS = NULL
        WHERE TREND_END_STATUS_TS = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_START_NEXT_TS = NULL
        WHERE TREND_START_NEXT_TS = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_END_TS = NULL
        WHERE TREND_END_TS = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_START_STATUS_TS_FILTER = NULL
        WHERE TREND_START_STATUS_TS_FILTER = P_RUN_DATE;
        UPDATE D_MKT_TRENDS
            SET TREND_END_STATUS_TS_FILTER = NULL
        WHERE TREND_END_STATUS_TS_FILTER = P_RUN_DATE;

        DELETE FROM O_MODEL_DATA WHERE TICK_TIMESTAMP = P_RUN_DATE;
        DELETE FROM O_MODEL_PREDICT WHERE TICK_TIMESTAMP = P_RUN_DATE;
        DELETE FROM O_MODEL_SIGNALS WHERE TICK_TIMESTAMP = P_RUN_DATE;

        UPDATE O_MODEL_TRADE A
        SET TRAILING_TP = (SELECT NVL(MAX(B.ORIGINAL_VALUE), A.TRAILING_TP)
                            FROM O_MODEL_TRADE_CHANGE B
                            WHERE A.SYMBOL = B.SYMBOL
                            AND A.CREATE_MODEL_TIMESTAMP = B.CREATE_MODEL_TIMESTAMP
                            AND B.CHANGE_TYPE = 'TP'
                            AND TRADE_CHANGE_TIMESTAMP = P_RUN_DATE
                         ),
            TRAILING_SL = (SELECT NVL(MAX(B.ORIGINAL_VALUE), A.TRAILING_SL)
                            FROM O_MODEL_TRADE_CHANGE B
                            WHERE A.SYMBOL = B.SYMBOL
                            AND A.CREATE_MODEL_TIMESTAMP = B.CREATE_MODEL_TIMESTAMP
                            AND B.CHANGE_TYPE = 'SL'
                            AND TRADE_CHANGE_TIMESTAMP = P_RUN_DATE
                         )
        WHERE (SYMBOL, CREATE_MODEL_TIMESTAMP) IN 
                (SELECT SYMBOL, CREATE_MODEL_TIMESTAMP
                    FROM O_MODEL_TRADE_CHANGE
                    WHERE TRADE_CHANGE_TIMESTAMP = P_RUN_DATE);


        DELETE FROM O_MODEL_TRADE WHERE CREATE_MODEL_TIMESTAMP = P_RUN_DATE;
        DELETE FROM O_MODEL_TRADE_CHANGE WHERE TRADE_CHANGE_TIMESTAMP = P_RUN_DATE;
    END IF;





    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function DATA_TRANSFORM
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."DATA_TRANSFORM" (P_RUN_DATE VARCHAR2, P_IS_BACKFILL VARCHAR2 DEFAULT 'N', P_IS_TRAIN VARCHAR2 DEFAULT 'N')
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    V_RUN_DATE VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN

    select POP_D_MKT_PIVOTS 
    INTO V_OUTPUT
    from dual;

    select POP_D_MKT_TRENDS 
    INTO V_OUTPUT
    from dual;

    select POP_D_MKT_TICK_TRENDS 
    INTO V_OUTPUT
    from dual;

    select POP_D_MKT_DATA_STATS 
    INTO V_OUTPUT
    from dual;

    select POP_D_MKT_TICK_EMA 
    INTO V_OUTPUT
    from dual;

    select POP_D_MKT_TICK_SR 
    INTO V_OUTPUT
    from dual;

    IF P_IS_TRAIN = 'Y'
    THEN
        select POP_O_MODEL_SL_TP 
        INTO V_OUTPUT
        from dual;
    END IF;


    IF P_IS_BACKFILL = 'Y' 
    THEN
        V_RUN_DATE := '2015-01-01 00:00:00';
    ELSE
        V_RUN_DATE := P_RUN_DATE;
    END IF;

    select POP_O_MODEL_DATA (V_RUN_DATE) 
    INTO V_OUTPUT
    from dual;

    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function INSERT_LOG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."INSERT_LOG" (P_RUN_DATE VARCHAR2, P_RUN_GROUP_NAME VARCHAR2,  P_STEP_NAME VARCHAR2)
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN
    INSERT INTO RUN_LOG VALUES (P_RUN_DATE, P_RUN_GROUP_NAME, P_STEP_NAME, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function POP_D_ACCOUNT_TRADE_ENTER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_ACCOUNT_TRADE_ENTER" (P_RUN_DATE VARCHAR2, P_RUN_GROUP_NAME VARCHAR2) 
RETURN VARCHAR2
IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    V_TOTAL_ACCOUNT NUMBER;
    v_MAX_TRADE_SIZE NUMBER;
    V_R NUMBER;
    V_RISK_LEVEL NUMBER;
    V_OPEN_ACCOUNT NUMBER;
    V_OPEN_TRADES NUMBER;
    V_TRADE_SIZE NUMBER;
    V_TRADE_R NUMBER;
    V_POS_UNITS NUMBER;

BEGIN

    FOR ACCOUNT_REC IN 
        (SELECT A.ACCOUNT_ID
         FROM D_ACCOUNT_SETTING A
         JOIN D_ACCOUNT B
         ON A.ACCOUNT_ID = B.ACCOUNT_ID
         AND B.CLOSE_DATE IS NULL
         AND A.SETTING_CATEGORY = 'StartTrading'
         AND SETTING_VALUE <= P_RUN_DATE
         AND P_RUN_DATE BETWEEN START_DATE AND END_DATE
         AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
         WHERE B.IS_ACTIVE = 'Y'
         )
    LOOP
            IF P_RUN_GROUP_NAME <> 'RunGroupLive' 
            THEN
                DELETE FROM D_ACCOUNT_TRADE 
                WHERE ACCOUNT_ID = ACCOUNT_REC.ACCOUNT_ID
                AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
                AND ENTER_MODEL_TIMESTAMP = P_RUN_DATE;
            END IF;

            -- CALCUALTE AVAILABLE BALANCE
            SELECT NVL(SUM(AMOUNT),0) 
            INTO V_TOTAL_ACCOUNT
            FROM D_ACCOUNT_PNL
            WHERE ACCOUNT_ID = ACCOUNT_REC.ACCOUNT_ID
            AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
            AND REPORT_DATE <= P_RUN_DATE;

            -- PULL MAX TRADE SIZE and R based on the risk profile of the account
            WITH D0
            AS
                (SELECT B.TRADE_SIZE, B.R, B.RISK_LEVEL, ROW_NUMBER() OVER (ORDER BY A.ACCOUNT_ID) RN
                FROM D_ACCOUNT_SETTING A
                JOIN D_RISK_PROFILES B
                ON A.SETTING_VALUE = B.RISK_LEVEL
                WHERE P_RUN_DATE BETWEEN A.START_DATE AND A.END_DATE
                AND P_RUN_DATE BETWEEN B.START_DATE AND B.END_DATE
                AND NVL(A.ACCOUNT_ID, ACCOUNT_REC.ACCOUNT_ID) = ACCOUNT_REC.ACCOUNT_ID
                AND A.SETTING_CATEGORY = 'Risk'
                AND RUN_GROUP_NAME = P_RUN_GROUP_NAME)
            SELECT TRADE_SIZE, R, RISK_LEVEL
            INTO v_MAX_TRADE_SIZE, V_R, V_RISK_LEVEL
            FROM D0
            WHERE ROWNUM = 1;


            FOR TRADE_REC IN 
                (
                    WITH D0
                    AS
                    (
                        SELECT B.*,
                            (ENTER_MODEL_PRICE)/ (ENTER_MODEL_PRICE - INITIAL_SL) R_RANKING
                        FROM O_MODEL_TRADE B
                        LEFT JOIN D_SYMBOL_EXCLUDE A
                        ON A.SYMBOL = B.SYMBOL
                        WHERE P_RUN_DATE = B.CREATE_MODEL_TIMESTAMP
                        AND TRADE_TYPE = 'BUY'
                        AND A.SYMBOL IS NULL
                    )
                    SELECT * 
                    FROM D0
                    ORDER BY R_RANKING
                )
            LOOP

                    WITH D0
                    AS
                    (
                        SELECT NVL(SUM(CASE WHEN NVL(EXIT_TRADE_TIMESTAMP, CANCEL_TRADE_TIMESTAMP) IS NULL THEN POSITION_SIZE END),0) OPEN_ACCOUNT
                        FROM D_ACCOUNT_TRADE
                        WHERE ENTER_MODEL_TIMESTAMP <= P_RUN_DATE
                        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
                        AND ACCOUNT_ID = ACCOUNT_REC.ACCOUNT_ID
                    ),
                    D1
                    AS
                    (
                        SELECT  OPEN_ACCOUNT,
                                CASE
                                    WHEN V_MAX_TRADE_SIZE < 1 THEN V_MAX_TRADE_SIZE * V_TOTAL_ACCOUNT 
                                    WHEN V_MAX_TRADE_SIZE > 1 THEN V_MAX_TRADE_SIZE 
                                END MAX_TRADE_SIZE, 
                                CASE 
                                    --WHEN V_R < 1 THEN V_MAX_TRADE_SIZE * V_TOTAL_ACCOUNT * V_R 
                                    WHEN V_R < 1 THEN V_TOTAL_ACCOUNT * V_R 
                                    WHEN V_R > 1 THEN V_R 
                                END MAX_R
                        FROM D0 A
                    ),
                    D2
                    AS
                    (
                        SELECT OPEN_ACCOUNT, MAX_TRADE_SIZE, MAX_R,
                            TRUNC(MAX_TRADE_SIZE/TRADE_REC.ENTER_MODEL_PRICE) CAP_UNITS, 
                            ROUND(MAX_R/(TRADE_REC.ENTER_MODEL_PRICE - TRADE_REC.INITIAL_SL)) R_UNITS,
                            LEAST(TRUNC(MAX_TRADE_SIZE/TRADE_REC.ENTER_MODEL_PRICE) , ROUND(MAX_R/(TRADE_REC.ENTER_MODEL_PRICE - TRADE_REC.INITIAL_SL))) POS_UNITS
                        FROM D1 B
                    ),
                    D3
                    AS
                    (
                        SELECT OPEN_ACCOUNT, MAX_TRADE_SIZE, MAX_R, CAP_UNITS, R_UNITS, POS_UNITS, 
                            ROUND(TRADE_REC.ENTER_MODEL_PRICE * POS_UNITS) TRADE_SIZE,
                            ROUND((TRADE_REC.ENTER_MODEL_PRICE - TRADE_REC.INITIAL_SL) * POS_UNITS) R
                        FROM D2
                    )
                    SELECT OPEN_ACCOUNT, TRADE_SIZE, R, POS_UNITS
                    INTO V_OPEN_ACCOUNT, V_TRADE_SIZE, V_TRADE_R, V_POS_UNITS
                    FROM D3;

                IF V_TRADE_SIZE > V_TOTAL_ACCOUNT * 1.7 - V_OPEN_ACCOUNT -- this is a margin leverage factor. it can go higher.
                THEN   
                    CONTINUE;
                END IF;

                SELECT COUNT(*) 
                INTO V_OPEN_TRADES
                FROM D_ACCOUNT_TRADE 
                WHERE SYMBOL = TRADE_REC.SYMBOL
                AND ACCOUNT_ID = ACCOUNT_REC.ACCOUNT_ID
                AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
                AND NVL(EXIT_TRADE_TIMESTAMP, CANCEL_TRADE_TIMESTAMP) IS NULL 
                AND ENTER_MODEL_TIMESTAMP <= P_RUN_DATE ;

                IF V_OPEN_TRADES = 0 AND TRADE_REC.INITIAL_SL > 0 AND V_POS_UNITS > 0
                THEN
                    --Note: position Size will get updated from the python scripts once the trade is submitted and we have actual data.
                    INSERT INTO D_ACCOUNT_TRADE(ACCOUNT_ID, RUN_GROUP_NAME, SYMBOL, RISK, TRADE_SHARE, QTY, TRADE_TYPE, ENTER_MODEL_TIMESTAMP, 
                                                ENTER_MODEL_PRICE, INITIAL_STOP_LOSS, TRAILING_STOP_LOSS, INITIAL_TAKE_PROFIT, TRAILING_TAKE_PROFIT, POSITION_SIZE)
                    VALUES (ACCOUNT_REC.ACCOUNT_ID, P_RUN_GROUP_NAME, TRADE_REC.SYMBOL, V_RISK_LEVEL, ROUND(V_TRADE_SIZE/V_TOTAL_ACCOUNT, 2), V_POS_UNITS,
                                        TRADE_REC.TRADE_TYPE, TRADE_REC.CREATE_MODEL_TIMESTAMP, TRADE_REC.ENTER_MODEL_PRICE, TRADE_REC.INITIAL_SL, TRADE_REC.INITIAL_SL, 
                                        TRADE_REC.INITIAL_TP, TRADE_REC.INITIAL_TP, round(V_TRADE_SIZE));
                END IF; 
            END LOOP;
            COMMIT;

    END LOOP;
    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function POP_D_ACCOUNT_TRADE_EXIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_ACCOUNT_TRADE_EXIT" (P_RUN_DATE VARCHAR2, P_RUN_GROUP_NAME VARCHAR2) 
RETURN VARCHAR2
IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    IS_VALID_EXIT NUMBER;
    V_LAST_SYMBOL_PRICE NUMBER;
BEGIN
    FOR OPEN_REC IN
    (
        SELECT *
        FROM O_MODEL_TRADE 
        WHERE EXIT_MODEL_TIMESTAMP =  P_RUN_DATE 
    )
    LOOP
        UPDATE D_ACCOUNT_TRADE
        SET EXIT_MODEL_TIMESTAMP = OPEN_REC.EXIT_MODEL_TIMESTAMP,
            EXIT_MODEL_PRICE = OPEN_REC.EXIT_MODEL_PRICE,
            EXIT_TYPE = OPEN_REC.EXIT_TYPE
        WHERE SYMBOL = OPEN_REC.SYMBOL
        AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP
        AND EXIT_MODEL_TIMESTAMP IS NULL
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

    END LOOP;

--- Canceling Trades
    FOR OPEN_REC IN
    (
        SELECT A.SYMBOL, A.ENTER_MODEL_TIMESTAMP, COUNT(*) DAYS_OPEN
        FROM D_ACCOUNT_TRADE  A
        JOIN D_TRADING_CALENDAR B
        ON B.CALENDAR_DAY BETWEEN A.ENTER_MODEL_TIMESTAMP AND P_RUN_DATE
        WHERE ENTER_TRADE_TIMESTAMP IS NULL
        AND CANCEL_TRADE_TIMESTAMP IS NULL
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME
        GROUP BY A.SYMBOL, A.ENTER_MODEL_TIMESTAMP

        HAVING COUNT(*) >= 3
    )
    LOOP
        UPDATE D_ACCOUNT_TRADE
        SET CANCEL_TRADE_TIMESTAMP = P_RUN_DATE,
            EXIT_TYPE = 'CANCEL'
        WHERE SYMBOL = OPEN_REC.SYMBOL
        AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP
        AND CANCEL_TRADE_TIMESTAMP IS NULL
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

    END LOOP;



-- UPDATEING TRAILING TP SL
    UPDATE D_ACCOUNT_TRADE A
    SET (TRAILING_STOP_LOSS, TRAILING_TAKE_PROFIT) = (SELECT NVL(MAX(B.TRAILING_SL), A.TRAILING_STOP_LOSS) , NVL(MAX(B.TRAILING_TP), A.TRAILING_TAKE_PROFIT)
                                        FROM O_MODEL_TRADE B
                                        WHERE A.SYMBOL = B.SYMBOL
                                        AND A.ENTER_MODEL_TIMESTAMP = B.ENTER_MODEL_TIMESTAMP
                                    )
    WHERE RUN_GROUP_NAME = P_RUN_GROUP_NAME
    AND NVL(EXIT_TRADE_TIMESTAMP, CANCEL_TRADE_TIMESTAMP) IS NULL;



    COMMIT;
    RETURN 'SUCCESS';
END;


/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_DATA_STATS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_DATA_STATS" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE T
                        AS
                        WITH intervals
                        as
                        (
                            select ''1D'' interval 
                            from dual 
                            union all
                            select ''1W'' interval 
                            from dual 
                            union all
                            select ''1M'' interval 
                            from dual 
                        ),
                        D0
                        AS
                        (
                            SELECT A.SYMBOL, c.interval, NVL(MAX(B.TICK_TIMESTAMP),''2015-01-01 00:00:00'') FIRST_TICK_TIMESTAMP
                            FROM D_SYMBOL A
                            cross join intervals c
                            LEFT JOIN D_MKT_DATA_STATS B
                            ON A.SYMBOL = B.SYMBOL
                            AND b.INTERVAL = c.interval
                            GROUP BY A.SYMBOL, c.interval
                        )
                        SELECT * FROM D0';



    EXECUTE IMMEDIATE 'CREATE TABLE T0
                        AS
                        WITH D0
                        AS
                        (
                            SELECT B.SYMBOL, B.INTERVAL, MIN(B.TICK_TIMESTAMP) MIN_TICK_TIMESTAMP
                            FROM O_MKT_DATA B
                            JOIN T A
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND B.TICK_TIMESTAMP > A.FIRST_TICK_TIMESTAMP
                            GROUP BY B.SYMBOL, B.INTERVAL

                        ),
                        D1
                        AS
                        (
                            SELECT B.*, NVL(PREV_CALENDAR_WEEK, ''2015-01-01 00:00:00'') MIN_FILTER_TICK_TIMESTAMP_LOW
                            FROM D0 B
                            LEFT JOIN D_TRADING_CALENDAR C
                            ON B.MIN_TICK_TIMESTAMP = C.CALENDAR_DAY
                            WHERE B.INTERVAL = ''1W''
                            UNION ALL
                            SELECT B.*, NVL(PREV_CALENDAR_MONTH, ''2015-01-01 00:00:00'')
                            FROM D0 B
                            LEFT JOIN D_TRADING_CALENDAR C
                            ON B.MIN_TICK_TIMESTAMP = C.CALENDAR_DAY
                            WHERE B.INTERVAL = ''1M''
                            UNION ALL
                            SELECT B.*, NVL(PREV_CALENDAR_DAY, ''2015-01-01 00:00:00'')
                            FROM D0 B
                            LEFT JOIN D_TRADING_CALENDAR C
                            ON B.MIN_TICK_TIMESTAMP = C.CALENDAR_DAY
                            WHERE B.INTERVAL = ''1D''
                        ),
                        D2
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, B.TICK_TIMESTAMP, B.ATR,
                                            B.OPEN TICK_OPEN, B.CLOSE TICK_CLOSE, B.HIGH TICK_HIGH, B.LOW TICK_LOW
                            FROM D1 A
                            JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND B.INTERVAL = ''1D''
                            AND B.TICK_TIMESTAMP > A.MIN_FILTER_TICK_TIMESTAMP_LOW
                        ),
                        D3
                        AS
                        (
                            SELECT A.*, 
                                CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN PREV_CALENDAR_MONTH
                                END FILTER_TICK_TIMESTAMP_LOW
                            FROM D2 A
                            JOIN D_TRADING_CALENDAR B
                            ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                        )
                        SELECT *
                        FROM D3';


    EXECUTE IMMEDIATE 'CREATE TABLE T1
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.TICK_HIGH, A.TICK_LOW, A.TICK_OPEN, A.TICK_CLOSE, A.ATR,
                                B.ATR PREV_ATR, B.CLOSE PREV_CLOSE, 
                                MAX(A.TICK_HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FILTER_TICK_TIMESTAMP_LOW ORDER BY A.TICK_TIMESTAMP) INTERVAL_HIGH,
                                MIN(A.TICK_LOW) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FILTER_TICK_TIMESTAMP_LOW ORDER BY A.TICK_TIMESTAMP) INTERVAL_LOW,
                                A.TICK_CLOSE INTERVAL_CLOSE,
                                FIRST_VALUE (A.TICK_OPEN) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FILTER_TICK_TIMESTAMP_LOW ORDER BY A.TICK_TIMESTAMP) INTERVAL_OPEN 
                            FROM T0 A
                            LEFT JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.FILTER_TICK_TIMESTAMP_LOW = B.TICK_TIMESTAMP
                        ),
                        D1
                        AS
                        (
                            SELECT  A.*,
                                GREATEST ((INTERVAL_HIGH - INTERVAL_LOW), ABS(INTERVAL_HIGH - PREV_CLOSE), ABS(INTERVAL_LOW - PREV_CLOSE)) INTERVAL_TR,
                                CASE 
                                    WHEN (INTERVAL_HIGH - INTERVAL_LOW) >= ABS(INTERVAL_HIGH - PREV_CLOSE) 
                                     AND (INTERVAL_HIGH - INTERVAL_LOW) >= ABS(INTERVAL_LOW - PREV_CLOSE) THEN TICK_CLOSE - INTERVAL_LOW
                                    ELSE ABS(TICK_CLOSE - PREV_CLOSE)
                                END INTERVAL_TICK_TR,
                                ROUND((A.TICK_CLOSE - A.PREV_CLOSE)/A.PREV_CLOSE, 4) PREV_CLOSE_GAP,
                                ROUND((A.TICK_CLOSE - A.PREV_CLOSE)/A.PREV_ATR, 3) PREV_CLOSE_GAP_ATR,
                                ROUND((A.TICK_CLOSE - A.INTERVAL_OPEN)/A.INTERVAL_OPEN, 4) INTERVAL_OPEN_GAP,
                                ROUND((A.TICK_CLOSE - A.INTERVAL_OPEN)/A.PREV_ATR, 3) INTERVAL_OPEN_GAP_ATR
                            FROM D0 A
                        ),
                        D2
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN ROUND(INTERVAL_TR/NULLIF(PREV_ATR, 0), 3) END) MONTH_INTERVAL_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN ROUND(INTERVAL_TICK_TR/NULLIF(INTERVAL_TR, 0), 3) END) MONTH_TICK_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN ROUND(INTERVAL_TR/NULLIF(PREV_ATR, 0), 3) END) WEEK_INTERVAL_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN ROUND(INTERVAL_TICK_TR/NULLIF(INTERVAL_TR, 0), 3) END) WEEK_TICK_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PREV_CLOSE_GAP END) MONTH_PREV_CLOSE_GAP,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PREV_CLOSE_GAP END) WEEK_PREV_CLOSE_GAP,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN INTERVAL_OPEN_GAP END) MONTH_INTERVAL_OPEN_GAP,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN INTERVAL_OPEN_GAP END) WEEK_INTERVAL_OPEN_GAP,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PREV_CLOSE_GAP_ATR END) MONTH_PREV_CLOSE_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PREV_CLOSE_GAP_ATR END) WEEK_PREV_CLOSE_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN INTERVAL_OPEN_GAP_ATR END) MONTH_INTERVAL_OPEN_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN INTERVAL_OPEN_GAP_ATR END) WEEK_INTERVAL_OPEN_GAP_ATR
                            FROM D1
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )
                        SELECT A.*, 

                            ROUND(A.INTERVAL_TR/NULLIF(A.PREV_ATR, 0), 3) INTERVAL_TR_RATIO,
                            ROUND(A.INTERVAL_TICK_TR/NULLIF(A.INTERVAL_TR, 0), 3) INTERVAL_TICK_TR_RATIO,
                            B.MONTH_INTERVAL_TR_RATIO, B.MONTH_TICK_TR_RATIO, 
                            B.WEEK_INTERVAL_TR_RATIO, B.WEEK_TICK_TR_RATIO,
                            B.MONTH_PREV_CLOSE_GAP, B.MONTH_INTERVAL_OPEN_GAP, 
                            B.WEEK_PREV_CLOSE_GAP, B.WEEK_INTERVAL_OPEN_GAP,
                            B.MONTH_PREV_CLOSE_GAP_ATR, B.MONTH_INTERVAL_OPEN_GAP_ATR, 
                            B.WEEK_PREV_CLOSE_GAP_ATR, B.WEEK_INTERVAL_OPEN_GAP_ATR
                        FROM D1 A
                        JOIN T C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP > C.FIRST_TICK_TIMESTAMP
                        LEFT JOIN D2 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP';


    EXECUTE IMMEDIATE 'DELETE FROM D_MKT_DATA_STATS
                        WHERE (SYMBOL, INTERVAL, TICK_TIMESTAMP) IN (SELECT SYMBOL, INTERVAL, TICK_TIMESTAMP FROM T1)';
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_DATA_STATS (
                                    SYMBOL,
                                    INTERVAL,
                                    TICK_TIMESTAMP,
                                    TICK_HIGH,
                                    TICK_LOW,
                                    TICK_OPEN,
                                    TICK_CLOSE,
                                    ATR,
                                    PREV_ATR,
                                    PREV_CLOSE,
                                    INTERVAL_HIGH,
                                    INTERVAL_LOW,
                                    INTERVAL_CLOSE,
                                    INTERVAL_OPEN,
                                    INTERVAL_TR,
                                    INTERVAL_TICK_TR,
                                    PREV_CLOSE_GAP,
                                    PREV_CLOSE_GAP_ATR,
                                    INTERVAL_OPEN_GAP,
                                    INTERVAL_OPEN_GAP_ATR,
                                    INTERVAL_TR_RATIO,
                                    INTERVAL_TICK_TR_RATIO,
                                    MONTH_INTERVAL_TR_RATIO,
                                    MONTH_TICK_TR_RATIO,
                                    WEEK_INTERVAL_TR_RATIO,
                                    WEEK_TICK_TR_RATIO,
                                    MONTH_PREV_CLOSE_GAP,
                                    MONTH_INTERVAL_OPEN_GAP,
                                    WEEK_PREV_CLOSE_GAP,
                                    WEEK_INTERVAL_OPEN_GAP,
                                    MONTH_PREV_CLOSE_GAP_ATR,
                                    MONTH_INTERVAL_OPEN_GAP_ATR,
                                    WEEK_PREV_CLOSE_GAP_ATR,
                                    WEEK_INTERVAL_OPEN_GAP_ATR)
                        SELECT SYMBOL,
                                    INTERVAL,
                                    TICK_TIMESTAMP,
                                    TICK_HIGH,
                                    TICK_LOW,
                                    TICK_OPEN,
                                    TICK_CLOSE,
                                    ATR,
                                    PREV_ATR,
                                    PREV_CLOSE,
                                    INTERVAL_HIGH,
                                    INTERVAL_LOW,
                                    INTERVAL_CLOSE,
                                    INTERVAL_OPEN,
                                    INTERVAL_TR,
                                    INTERVAL_TICK_TR,
                                    PREV_CLOSE_GAP,
                                    PREV_CLOSE_GAP_ATR,
                                    INTERVAL_OPEN_GAP,
                                    INTERVAL_OPEN_GAP_ATR,
                                    INTERVAL_TR_RATIO,
                                    INTERVAL_TICK_TR_RATIO,
                                    MONTH_INTERVAL_TR_RATIO,
                                    MONTH_TICK_TR_RATIO,
                                    WEEK_INTERVAL_TR_RATIO,
                                    WEEK_TICK_TR_RATIO,
                                    MONTH_PREV_CLOSE_GAP,
                                    MONTH_INTERVAL_OPEN_GAP,
                                    WEEK_PREV_CLOSE_GAP,
                                    WEEK_INTERVAL_OPEN_GAP,
                                    MONTH_PREV_CLOSE_GAP_ATR,
                                    MONTH_INTERVAL_OPEN_GAP_ATR,
                                    WEEK_PREV_CLOSE_GAP_ATR,
                                    WEEK_INTERVAL_OPEN_GAP_ATR
                                FROM T1';


    EXECUTE IMMEDIATE 'DROP TABLE T PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';


    COMMIT;
    RETURN 'SUCCESS';
END;                            

/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_PIVOTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_PIVOTS" 
RETURN VARCHAR2
AS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_PIVOTS_t
                AS
                WITH D0 
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, A.PIVOT_TYPE, A.PIVOT_TIMESTAMP, A.PIVOT_STATUS,
                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP DESC) RN,
                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.PIVOT_TYPE ORDER BY A.PIVOT_TIMESTAMP DESC) RN_TYPE
                    FROM D_MKT_PIVOTS A
                    WHERE PIVOT_STATUS IN (''F'',''T'')
                )
                SELECT A.SYMBOL, A.INTERVAL, 
                    MAX(CASE WHEN RN = 1 THEN PIVOT_TIMESTAMP END) LAST_PIVOT_TIMESTAMP, 
                    MIN(CASE WHEN PIVOT_STATUS = ''T'' AND RN_TYPE <= 4 THEN PIVOT_TIMESTAMP END) PREV_LAST_PIVOT_TIMESTAMP
                FROM D0 A
                GROUP BY A.SYMBOL, A.INTERVAL';


    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_PIVOTS_t0 AS
                WITH
                D0
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.HIGH, A.LOW, A.CLOSE, A.OPEN,

                        LAG(HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_HIGH_1,
                        LAG(HIGH, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_HIGH_2,
                        LAG(HIGH, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_HIGH_3,
                        LAG(LOW) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_LOW_1,
                        LAG(LOW, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_LOW_2,
                        LAG(LOW, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) PREV_LOW_3,
                        LEAD(HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_HIGH_1,
                        LEAD(HIGH, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_HIGH_2,
                        LEAD(HIGH, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_HIGH_3,
                        LEAD(LOW) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_LOW_1,
                        LEAD(LOW, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_LOW_2,
                        LEAD(LOW, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_LOW_3,
                        LEAD(A.TICK_TIMESTAMP) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_TS_1,
                        LEAD(A.TICK_TIMESTAMP, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_TS_2,
                        LEAD(A.TICK_TIMESTAMP, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.TICK_TIMESTAMP) LEAD_TS_3
                    FROM O_MKT_DATA A
                    LEFT JOIN D_MKT_PIVOTS_t B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    WHERE A.CALENDAR_STATUS = ''T'' AND A.TICK_TIMESTAMP >= NVL(B.PREV_LAST_PIVOT_TIMESTAMP, ''2015-01-01 00:00:00'')

                ) ,
                D1
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, TICK_TIMESTAMP, HIGH, LOW, CLOSE, OPEN,
                            LEAD_HIGH_1, LEAD_HIGH_2, LEAD_HIGH_3,
                            LEAD_LOW_1, LEAD_LOW_2, LEAD_LOW_3,
                            LEAD_TS_1, LEAD_TS_2, LEAD_TS_3,
                        CASE WHEN HIGH >= PREV_HIGH_1 AND HIGH >= PREV_HIGH_2 AND HIGH >= PREV_HIGH_3 
                                AND HIGH > LEAD_HIGH_1 
                             THEN ''HIGH''

                             WHEN LOW <= PREV_LOW_1 AND LOW <= PREV_LOW_2 AND LOW <= PREV_LOW_3 
                                AND LOW < LEAD_LOW_1
                            THEN ''LOW''
                        END PIVOT_TYPE
                    FROM D0 A
                ) ,
                D2
                AS
                (
                    SELECT SYMBOL, INTERVAL, TICK_TIMESTAMP PIVOT_TIMESTAMP, PIVOT_TYPE, HIGH, LOW, CLOSE, OPEN,
                        CASE WHEN PIVOT_TYPE = ''HIGH'' THEN HIGH WHEN PIVOT_TYPE = ''LOW'' THEN LOW END PIVOT_VALUE,
                        CASE WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_1 THEN ''F''
                             WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_2 THEN ''F''
                             WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_3 THEN ''F''
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_1 THEN ''F''
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_2 THEN ''F''
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_3 THEN ''F''
                             WHEN LEAD_HIGH_1 IS NOT NULL AND LEAD_HIGH_2 IS NOT NULL AND LEAD_HIGH_3 IS NOT NULL THEN ''T''
                        ELSE ''P'' END PIVOT_STATUS,

                        CASE WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_1 THEN LEAD_TS_1
                             WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_2 THEN LEAD_TS_2
                             WHEN PIVOT_TYPE = ''HIGH'' AND HIGH <= LEAD_HIGH_3 THEN LEAD_TS_3
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_1 THEN LEAD_TS_1
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_2 THEN LEAD_TS_2
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW >= LEAD_LOW_3 THEN LEAD_TS_3
                             WHEN LEAD_HIGH_1 IS NOT NULL AND LEAD_HIGH_2 IS NOT NULL AND LEAD_HIGH_3 IS NOT NULL THEN LEAD_TS_3
                        END PIVOT_STATUS_TS
                    FROM D1
                    WHERE PIVOT_TYPE IS NOT NULL
                ) ,
                D3
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, A.PIVOT_TYPE, A.HIGH, A.LOW, A.CLOSE, A.OPEN, A.PIVOT_VALUE,
                            A.PIVOT_STATUS, A.PIVOT_STATUS_TS,
                            MAX(CASE WHEN B.PIVOT_STATUS = ''T'' THEN B.PIVOT_TIMESTAMP END) PREV_TRUE_PIVOT_TS
                    FROM D2 A
                    LEFT OUTER JOIN D2 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.PIVOT_TYPE = B.PIVOT_TYPE
                    --AND SUBSTR(A.PIVOT_TIMESTAMP, 1, 10) = SUBSTR(B.PIVOT_TIMESTAMP, 1, 10)
                    AND B.PIVOT_TIMESTAMP < A.PIVOT_TIMESTAMP
                    GROUP BY A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, A.PIVOT_TYPE, A.HIGH, A.LOW, A.CLOSE, A.OPEN, A.PIVOT_VALUE,
                            A.PIVOT_STATUS, A.PIVOT_STATUS_TS),
                D4
                AS
                (
                    SELECT A.* , B.PIVOT_VALUE PREV_PIVOT_VALUE

                    FROM D3 A
                    LEFT JOIN D3 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.PREV_TRUE_PIVOT_TS = B.PIVOT_TIMESTAMP
                )
                SELECT A.*,
                        CASE WHEN PIVOT_TYPE = ''HIGH'' AND HIGH > PREV_PIVOT_VALUE THEN ''HH''
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW < PREV_PIVOT_VALUE THEN ''LL''
                             WHEN PIVOT_TYPE  = ''HIGH'' AND HIGH < PREV_PIVOT_VALUE THEN ''LH''
                             WHEN PIVOT_TYPE = ''LOW'' AND LOW > PREV_PIVOT_VALUE THEN ''HL''
                        END PIVOT_SUB_TYPE
                FROM D4 A
                LEFT JOIN D_MKT_PIVOTS_t B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                WHERE A.PIVOT_TIMESTAMP > NVL(B.LAST_PIVOT_TIMESTAMP, ''2015-01-01 00:00:00'')';



        EXECUTE IMMEDIATE 'DELETE FROM D_MKT_PIVOTS WHERE NVL(PIVOT_STATUS, ''P'') = ''P''';
        EXECUTE IMMEDIATE 'INSERT INTO D_MKT_PIVOTS (
                                        SYMBOL,
                                        INTERVAL,
                                        PIVOT_TIMESTAMP,
                                        PIVOT_TYPE,
                                        HIGH,
                                        LOW,
                                        CLOSE,
                                        OPEN,
                                        PIVOT_VALUE,
                                        PIVOT_STATUS,
                                        PIVOT_STATUS_TS,
                                        PIVOT_SUB_TYPE)
                            SELECT SYMBOL,
                                        INTERVAL,
                                        PIVOT_TIMESTAMP,
                                        PIVOT_TYPE,
                                        HIGH,
                                        LOW,
                                        CLOSE,
                                        OPEN,
                                        PIVOT_VALUE,
                                        PIVOT_STATUS,
                                        PIVOT_STATUS_TS,
                                        PIVOT_SUB_TYPE
                            FROM D_MKT_PIVOTS_t0';


        EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_PIVOTS_t1
                            AS
                            WITH D0
                            AS
                            (
                                SELECT A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, A.HIGH, A.LOW,
                                        LAG(HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) PREV_HIGH_1,
                                        LAG(HIGH, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) PREV_HIGH_2,
                                        LEAD(HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) LEAD_HIGH_1,
                                        LEAD(HIGH, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) LEAD_HIGH_2,
                                        LEAD(PIVOT_STATUS_TS, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) SIG_PIVOT_STATUS_TS
                                FROM D_MKT_PIVOTS A
                                WHERE A.PIVOT_STATUS = ''T''
                                AND A.PIVOT_TYPE = ''HIGH''
                            ),
                            D01
                            AS
                            (
                                SELECT SYMBOL, INTERVAL, PIVOT_TIMESTAMP, ''HIGH'' PIVOT_TYPE, HIGH,
                                    CASE WHEN HIGH >= PREV_HIGH_1 AND HIGH >= PREV_HIGH_2 
                                          AND HIGH > LEAD_HIGH_1 AND HIGH > LEAD_HIGH_2 
                                         THEN SIG_PIVOT_STATUS_TS
                                    END SIG_PIVOT_STATUS_TS
                                FROM D0
                            ),
                            D1
                            AS
                            (
                                SELECT A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, LOW,
                                        LAG(LOW) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) PREV_LOW_1,
                                        LAG(LOW, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) PREV_LOW_2,
                                        LEAD(LOW) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) LEAD_LOW_1,
                                        LEAD(LOW, 2) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) LEAD_LOW_2,
                                        LEAD(PIVOT_STATUS_TS, 3) OVER (PARTITION BY A.SYMBOL, A.INTERVAL ORDER BY A.PIVOT_TIMESTAMP) SIG_PIVOT_STATUS_TS
                                FROM D_MKT_PIVOTS A
                                WHERE A.PIVOT_STATUS = ''T''
                                AND A.PIVOT_TYPE = ''LOW''
                            ),
                            D11
                            AS
                            (
                                SELECT SYMBOL, INTERVAL, PIVOT_TIMESTAMP, ''LOW'' PIVOT_TYPE, 
                                    CASE WHEN LOW <= PREV_LOW_1 AND LOW <= PREV_LOW_2 
                                          AND LOW < LEAD_LOW_1 AND LOW < LEAD_LOW_2 
                                         THEN SIG_PIVOT_STATUS_TS
                                    END SIG_PIVOT_STATUS_TS
                                FROM D1
                            ),
                            D2
                            AS
                            (
                                SELECT SYMBOL, INTERVAL, PIVOT_TYPE, PIVOT_TIMESTAMP, SIG_PIVOT_STATUS_TS
                                FROM D01
                                UNION ALL
                                SELECT SYMBOL, INTERVAL, PIVOT_TYPE, PIVOT_TIMESTAMP, SIG_PIVOT_STATUS_TS
                                FROM D11
                            )
                            SELECT A.* 
                            FROM D2 A
                            JOIN D_MKT_PIVOTS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.PIVOT_TYPE = B.PIVOT_TYPE
                            AND A.PIVOT_TIMESTAMP = B.PIVOT_TIMESTAMP
                            AND B.SIG_PIVOT_STATUS_TS IS NULL
                            AND A.SIG_PIVOT_STATUS_TS IS NOT NULL';

        EXECUTE IMMEDIATE 'UPDATE D_MKT_PIVOTS A
                            SET A.SIG_PIVOT_STATUS_TS = (SELECT B.SIG_PIVOT_STATUS_TS FROM D_MKT_PIVOTS_t1 B
                                                         WHERE B.SYMBOL = A.SYMBOL
                                                         AND B.INTERVAL = A.INTERVAL
                                                         AND B.PIVOT_TYPE = A.PIVOT_TYPE
                                                         AND B.PIVOT_TIMESTAMP = A.PIVOT_TIMESTAMP)
                        WHERE (SYMBOL, INTERVAL, PIVOT_TYPE, PIVOT_TIMESTAMP) IN (SELECT SYMBOL, INTERVAL, PIVOT_TYPE, PIVOT_TIMESTAMP FROM D_MKT_PIVOTS_t1)';



        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t PURGE';
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t0 PURGE';
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_t1 PURGE';

        COMMIT;
        RETURN 'SUCCESS';
END;


/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_TICK_EMA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_TICK_EMA" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);

    TYPE REC_TYPE IS RECORD 
        (
            SYMBOL VARCHAR2(100),
            INTERVAL VARCHAR2(100),
            TICK_TIMESTAMP VARCHAR2(100),
            PREV_TICK_TIMESTAMP VARCHAR2(100),
            CLOSE12 NUMBER,
            CLOSE30 NUMBER,
            CLOSE50 NUMBER,
            CLOSE200 NUMBER
        );
    TYPE TAB_TYPE IS TABLE OF REC_TYPE INDEX BY PLS_INTEGER;
    TAB_VAR TAB_TYPE;
    CUR  SYS_REFCURSOR;

    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE DELTA_TICKS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE INTERVAL_EMA PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE STATS_EMA PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_A PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_B PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_D PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_W PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_M PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_D PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_W PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_M PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_D PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_W PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_M PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;



    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_D PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_W PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_M PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE DELTA_TICKS
                        AS
                        WITH INTERVALS
                        AS
                        (
                            SELECT ''1D'' INTERVAL 
                            FROM DUAL
                            UNION ALL
                            SELECT ''1W'' INTERVAL 
                            FROM DUAL
                            UNION ALL
                            SELECT ''1M'' INTERVAL 
                            FROM DUAL
                        ),
                        D0
                        AS
                        (
                            SELECT A.SYMBOL, B.INTERVAL, 
                                CASE 
                                    WHEN B.INTERVAL = ''1D'' THEN NVL(MAX(D.PREV_CALENDAR_DAY), ''2015-01-01 00:00:00'') 
                                    WHEN B.INTERVAL = ''1W'' THEN NVL(MAX(D.PREV_CALENDAR_WEEK), ''2015-01-01 00:00:00'') 
                                    WHEN B.INTERVAL = ''1M'' THEN NVL(MAX(D.PREV_CALENDAR_MONTH), ''2015-01-01 00:00:00'') 
                                 END MAX_TICK_TIMESTAMP,
                                NVL(MAX(C.TICK_TIMESTAMP), ''2015-01-01 00:00:00'') FINAL_TICK_TIMESTAMP
                            FROM D_SYMBOL A
                            CROSS JOIN INTERVALS B
                            LEFT OUTER JOIN D_MKT_TICK_EMA C
                            ON A.SYMBOL = C.SYMBOL
                            AND B.INTERVAL = C.INTERVAL
                            LEFT JOIN  D_TRADING_CALENDAR D
                            ON C.TICK_TIMESTAMP = D.CALENDAR_DAY
                            GROUP BY A.SYMBOL, B.INTERVAL
                        ),
                        D1
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.FINAL_TICK_TIMESTAMP,
                                CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN NVL(B.PREV_CALENDAR_DAY, ''2015-01-01 00:00:00'') 
                                    WHEN A.INTERVAL = ''1W'' THEN NVL(B.PREV_CALENDAR_WEEK, ''2015-01-01 00:00:00'') 
                                    WHEN A.INTERVAL = ''1M'' THEN NVL(B.PREV_CALENDAR_MONTH, ''2015-01-01 00:00:00'') 
                                 END MAX_TICK_TIMESTAMP
                            FROM D0 A
                            LEFT JOIN D_TRADING_CALENDAR B
                            ON A.MAX_TICK_TIMESTAMP = B.CALENDAR_DAY
                        )
                        SELECT A.*, 
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN C.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN C.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN C.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_CLOSE12_CLOSE30_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN D.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN D.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN D.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_CLOSE30_CLOSE50_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN E.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN E.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN E.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_CLOSE50_CLOSE200_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN F.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN F.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN F.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_EMA12_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN G.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN G.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN G.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_EMA30_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN H.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN H.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN H.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_EMA50_T2_STATE_TS,
                            NVL(CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN I.PREV_CALENDAR_DAY
                                    WHEN A.INTERVAL = ''1W'' THEN I.PREV_CALENDAR_WEEK
                                    WHEN A.INTERVAL = ''1M'' THEN I.PREV_CALENDAR_MONTH
                                END,  ''2015-01-01 00:00:00'') PREV_EMA200_T2_STATE_TS,
                            NVL(B.CLOSE12_CLOSE30_T2_STATE_TS, ''2015-01-01 00:00:00'') CLOSE12_CLOSE30_T2_STATE_TS,
                            NVL(B.CLOSE30_CLOSE50_T2_STATE_TS, ''2015-01-01 00:00:00'') CLOSE30_CLOSE50_T2_STATE_TS,
                            NVL(B.CLOSE50_CLOSE200_T2_STATE_TS, ''2015-01-01 00:00:00'') CLOSE50_CLOSE200_T2_STATE_TS,
                            NVL(B.EMA12_T2_STATE_TS, ''2015-01-01 00:00:00'') EMA12_T2_STATE_TS,
                            NVL(B.EMA30_T2_STATE_TS, ''2015-01-01 00:00:00'') EMA30_T2_STATE_TS,
                            NVL(B.EMA50_T2_STATE_TS, ''2015-01-01 00:00:00'') EMA50_T2_STATE_TS,
                            NVL(B.EMA200_T2_STATE_TS, ''2015-01-01 00:00:00'') EMA200_T2_STATE_TS
                        FROM D1 A
                        LEFT JOIN D_MKT_TICK_EMA B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.MAX_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        LEFT JOIN D_TRADING_CALENDAR C
                        ON B.CLOSE12_CLOSE30_T2_STATE_TS = C.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR D
                        ON B.CLOSE30_CLOSE50_T2_STATE_TS = D.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR E
                        ON B.CLOSE50_CLOSE200_T2_STATE_TS = E.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR F
                        ON B.EMA12_T2_STATE_TS = F.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR G
                        ON B.EMA30_T2_STATE_TS = G.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR H
                        ON B.EMA50_T2_STATE_TS = H.CALENDAR_DAY
                        LEFT JOIN D_TRADING_CALENDAR I
                        ON B.EMA200_T2_STATE_TS = I.CALENDAR_DAY
                        ';

    EXECUTE IMMEDIATE 'CREATE TABLE INTERVAL_EMA 
                AS
                with D0
                as
                (
                    select C.SYMBOL, a.calendar_day tick_timestamp, ''1W'' interval, a.calendar_week_status calendar_status,  A.PREV_CALENDAR_WEEK prev_tick_timestamp
                    from d_trading_calendar a
                    JOIN DELTA_TICKS C
                    ON C.INTERVAL = ''1W''
                    AND A.CALENDAR_DAY >= C.MAX_TICK_TIMESTAMP
                    union all
                    select C.SYMBOL, a.calendar_day tick_timestamp, ''1M'' interval, a.calendar_month_status calendar_status,  A.PREV_CALENDAR_MONTH prev_tick_timestamp
                    from d_trading_calendar a
                    JOIN DELTA_TICKS C
                    ON C.INTERVAL = ''1M''
                    AND A.CALENDAR_DAY >= C.MAX_TICK_TIMESTAMP
                    UNION ALL
                    select C.SYMBOL, a.calendar_day tick_timestamp, ''1D'' interval, ''T'' calendar_status,  A.PREV_CALENDAR_day prev_tick_timestamp
                    from d_trading_calendar a
                    JOIN DELTA_TICKS C
                    ON C.INTERVAL = ''1D''
                    AND A.CALENDAR_DAY >= C.MAX_TICK_TIMESTAMP
                ),
                d1
                as
                (
                    select a.*, b.close, c.close12 , c.close30, c.close50, c.close200
                    from d0 a
                    join o_mkt_data b
                    on A.SYMBOL = B.SYMBOL
                    AND a.interval = b.interval
                    and a.tick_timestamp = b.tick_timestamp
                    join o_mkt_data c
                    on A.symbol = c.symbol
                    and A.interval = c.interval
                    and a.prev_tick_timestamp = c.tick_timestamp
                    -- FILTER TO THE DELTA TICKS ONLY
                    JOIN DELTA_TICKS D
                    ON A.SYMBOL = D.SYMBOL
                    AND A.INTERVAL = D.INTERVAL
                    AND A.TICK_TIMESTAMP >= D.MAX_TICK_TIMESTAMP
                ),
                d2
                as
                (
                    select a.symbol, a.interval, a.tick_timestamp, a.calendar_status, a.prev_tick_timestamp,
                        round((close * 2/(12+1)) + (close12*(1 - 2/(12+1))), 2) close12,
                        round((close * 2/(30+1)) + (close30*(1 - 2/(30+1))), 2) close30,
                        round((close * 2/(50+1)) + (close50*(1 - 2/(50+1))), 2) close50,
                        round((close * 2/(200+1)) + (close200*(1 - 2/(200+1))), 2) close200
                    from d1 a
                )
                select a.symbol, a.interval, a.tick_timestamp,  B.prev_tick_timestamp,
                    nvl(a.close12, b.close12) close12,
                    nvl(a.close30, b.close30) close30,
                    nvl(a.close50, b.close50) close50,
                    nvl(a.close200, b.close200) close200
                from o_mkt_data a
                -- FILTER TO THE DELTA TICKS ONLY
                JOIN DELTA_TICKS D
                ON A.SYMBOL = D.SYMBOL
                AND A.INTERVAL = D.INTERVAL
                AND A.TICK_TIMESTAMP >= D.MAX_TICK_TIMESTAMP
                join d2 b
                on a.symbol = b.symbol
                and a.interval = b.interval
                and a.tick_timestamp = b.tick_timestamp';


    OPEN CUR FOR 'SELECT * FROM INTERVAL_EMA';
    FETCH CUR BULK COLLECT INTO TAB_VAR;
    CLOSE CUR;  

    FORALL indx IN 1 .. TAB_VAR.COUNT
    UPDATE O_MKT_DATA A
    SET A.CLOSE12 = TAB_VAR(INDX).CLOSE12,
        A.CLOSE30 = TAB_VAR(INDX).CLOSE30,
        A.CLOSE50 = TAB_VAR(INDX).CLOSE50,
        A.CLOSE200 = TAB_VAR(INDX).CLOSE200
    WHERE A.SYMBOL = TAB_VAR(INDX).SYMBOL
    AND A.INTERVAL  = TAB_VAR(INDX).INTERVAL
    AND A.TICK_TIMESTAMP = TAB_VAR(INDX).TICK_TIMESTAMP;       


    EXECUTE IMMEDIATE 'CREATE TABLE STATS_EMA
                        AS
                        with 
                        PREV_EMA
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE, A.HIGH, A.LOW,
                                A.CLOSE12, A.CLOSE30, A.CLOSE50, A.CLOSE200,
                                B.PREV_CALENDAR_DAY PREV_TICK_TIMESTAMP,
                                B.NEXT_CALENDAR_DAY NEXT_TICK_TIMESTAMP
                            FROM O_MKT_DATA A
                            JOIN D_TRADING_CALENDAR B
                            ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            -- FILTER TO THE DELTA TICKS ONLY
                            JOIN DELTA_TICKS D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND A.TICK_TIMESTAMP >= D.MAX_TICK_TIMESTAMP
                            WHERE A.INTERVAL = ''1D''
                            UNION ALL
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE, A.HIGH, A.LOW,
                                A.CLOSE12, A.CLOSE30, A.CLOSE50, A.CLOSE200,
                                B.PREV_CALENDAR_WEEK PREV_TICK_TIMESTAMP,
                                B.NEXT_CALENDAR_WEEK NEXT_TICK_TIMESTAMP
                            FROM O_MKT_DATA A
                            JOIN D_TRADING_CALENDAR B
                            ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            -- FILTER TO THE DELTA TICKS ONLY
                            JOIN DELTA_TICKS D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND A.TICK_TIMESTAMP >= D.MAX_TICK_TIMESTAMP
                            WHERE A.INTERVAL = ''1W''
                            UNION ALL
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE, A.HIGH, A.LOW,
                                A.CLOSE12, A.CLOSE30, A.CLOSE50, A.CLOSE200,
                                B.PREV_CALENDAR_MONTH PREV_TICK_TIMESTAMP,
                                B.NEXT_CALENDAR_MONTH NEXT_TICK_TIMESTAMP
                            FROM O_MKT_DATA A
                            JOIN D_TRADING_CALENDAR B
                            ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            -- FILTER TO THE DELTA TICKS ONLY
                            JOIN DELTA_TICKS D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND A.TICK_TIMESTAMP >= D.MAX_TICK_TIMESTAMP
                            WHERE A.INTERVAL = ''1M''
                        ),
                        MAIN_DATA
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE, A.HIGH, A.LOW, A.PREV_TICK_TIMESTAMP, A.NEXT_TICK_TIMESTAMP,
                                A.CLOSE12, A.CLOSE30, A.CLOSE50, A.CLOSE200,
                                B.CLOSE12 PREV_CLOSE12,
                                B.CLOSE30 PREV_CLOSE30,
                                B.CLOSE50 PREV_CLOSE50,
                                B.CLOSE200 PREV_CLOSE200
                            FROM PREV_EMA A
                            JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        ),
                            d1
                            as
                            (
                                select symbol, interval, tick_timestamp, A.CLOSE, A.HIGH, A.LOW, A.PREV_TICK_TIMESTAMP, A.NEXT_TICK_TIMESTAMP,
                                    close12, close30, close50, close200,
                                    CASE WHEN CLOSE12 <= CLOSE30 THEN -1 WHEN CLOSE12 > CLOSE30 THEN 1 END EMA_12_30_POSITION,
                                    CASE WHEN CLOSE30 <= CLOSE50 THEN -1 WHEN CLOSE30 > CLOSE50 THEN 1 END EMA_30_50_POSITION,
                                    CASE WHEN CLOSE50 <= CLOSE200 THEN -1 WHEN CLOSE50 > CLOSE200 THEN 1 END EMA_50_200_POSITION,
                                    CASE 
                                        WHEN CLOSE12 <= CLOSE30 AND CLOSE30 <= CLOSE50 AND CLOSE50 <= CLOSE200 THEN -1 
                                        WHEN CLOSE12 >= CLOSE30 AND CLOSE30 >= CLOSE50 AND CLOSE50 >= CLOSE200 THEN 1 
                                    END EMA_TREND_POSITION,
                                    prev_close12 Intercept12,
                                    prev_close30 Intercept30,
                                    prev_close50 Intercept50,
                                    prev_close200 Intercept200,
                                    close12 - prev_close12 slope12,
                                    close30 - prev_close30 slope30,
                                    close50 - prev_close50 slope50,
                                    close200 - prev_close200 slope200
                                from main_data A
                            ),
                            d2
                            as
                            (
                                select  a.symbol, a.interval, a.tick_timestamp, A.CLOSE, A.HIGH, A.LOW, A.PREV_TICK_TIMESTAMP, A.NEXT_TICK_TIMESTAMP,
                                        EMA_12_30_POSITION, EMA_30_50_POSITION, EMA_50_200_POSITION, EMA_TREND_POSITION,

                                        ROUND(SLOPE12/NULLIF(INTERCEPT12, 0), 4) * 10000 SLOPE_EMA12,
                                        ROUND(SLOPE30/NULLIF(INTERCEPT30, 0), 4) * 10000 SLOPE_EMA30,
                                        ROUND(SLOPE50/NULLIF(INTERCEPT50, 0), 4) * 10000 SLOPE_EMA50,
                                        ROUND(SLOPE200/NULLIF(INTERCEPT200, 0), 4) * 10000 SLOPE_EMA200,

                                        round((intercept12 - intercept30) /NULLIF( (slope30 - slope12), 0), 1) -1 PROJ_INTER_CLOSE12_CLOSE30,
                                        round((intercept30 - intercept50) / NULLIF((slope50 - slope30), 0), 1) -1 PROJ_INTER_CLOSE30_CLOSE50,
                                        round((intercept50 - intercept200) / NULLIF((slope200 - slope50), 0), 1) -1 PROJ_INTER_CLOSE50_CLOSE200
                                from d1 a
                            )
                        SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE, A.HIGH, A.LOW, A.PREV_TICK_TIMESTAMP, A.NEXT_TICK_TIMESTAMP,
                            A.EMA_12_30_POSITION, A.EMA_30_50_POSITION, A.EMA_50_200_POSITION, A.EMA_TREND_POSITION,
                            A.SLOPE_EMA12, A.SLOPE_EMA30, A.SLOPE_EMA50, A.SLOPE_EMA200,
                            A.PROJ_INTER_CLOSE12_CLOSE30, A.PROJ_INTER_CLOSE30_CLOSE50,A.PROJ_INTER_CLOSE50_CLOSE200
                        FROM D2 A';

    --------------------------------------------------

    EXECUTE IMMEDIATE 'create table ema_states_0
                        as
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close50 >= A.close200 then 1
                                     when A.close50 < A.close200 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_CLOSE50_CLOSE200_T2_STATE_TS
                            where A.calendar_status = ''T''
                            ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_50_200'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN
                        ';

                        -----------------------------------
                        -----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close12 >= A.close30 then 1
                                     when A.close12 < A.close30 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_CLOSE12_CLOSE30_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                            --where a.tick_timestamp = ''2022-06-13 00:00:00''
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_12_30'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )

                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';


                        ----------------------------------
                        ----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close30 >= A.close50 then 1
                                     when A.close30 < A.close50 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_CLOSE30_CLOSE50_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                            --where a.tick_timestamp = ''2022-06-13 00:00:00''
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_30_50'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';


                        ----------------------------------
                        ----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close >= A.close12 * 1.001 then 1
                                     when A.close < A.close12 * 0.999 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_EMA12_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                            --where a.tick_timestamp = ''2022-06-13 00:00:00''
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_12'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';

                        ----------------------------------
                        ----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close >= A.close30 * 1.001 then 1
                                     when A.close < A.close30 * 0.999 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_EMA30_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                            --where a.tick_timestamp = ''2022-06-13 00:00:00''
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_30'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';

                        ----------------------------------
                        ----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close >= A.close50 * 1.001 then 1
                                     when A.close < A.close50 * 0.999 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_EMA50_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                            --where a.tick_timestamp = ''2022-06-13 00:00:00''
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_50'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';

                        ----------------------------------
                        ----------------------------------

        EXECUTE IMMEDIATE 'insert into ema_states_0
                        with d0
                        as
                        (
                            select A.symbol, A.interval, A.tick_timestamp, A.close, A.close12, A.close30, A.close50, A.close200,
                                case when A.close >= A.close200 * 1.001 then 1
                                     when A.close < A.close200 * 0.999 then -1
                                     else 0
                                end state
                            from o_mkt_data A
                            JOIN DELTA_TICKS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP >= B.PREV_EMA200_T2_STATE_TS
                            where A.calendar_status = ''T''
                        ),
                        d1
                        as
                        (
                            select a.symbol, interval, tick_timestamp, state,
                                case 
                                    when state = 1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> 1 then tick_timestamp
                                    when state = -1 and lag(state) over (partition by symbol, interval order by tick_timestamp) <> -1 then tick_timestamp
                                end state_ts
                            from d0 a
                        ),
                        d2
                        as
                        (
                            select distinct symbol, interval, state_ts, state
                            from d1
                            where state_ts is not null
                        ),
                        d3
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, b.state, b.state_ts,
                                row_number() over (partition by a.symbol, a.interval, a.tick_timestamp order by b.state_ts desc) state_rn
                            from d1 a
                            left join d2 b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp >= b.state_ts
                        ),
                        d4
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, ''ema_200'' dim_type, state_rn rn,
                                state,
                                state_ts
                            from d3 a
                            where state_rn in (1,2)
                        )
                        select A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, 
                            NVL(C.DIM_TYPE, B.DIM_TYPE) DIM_TYPE, 
                            NVL(C.RN, B.RN) RN, 
                            NVL(C.STATE, B.STATE) STATE, 
                            NVL(C.STATE_TS, B.STATE_TS) STATE_TS 
                        from INTERVAL_EMA A
                        JOIN O_MKT_DATA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        AND D.CALENDAR_STATUS = ''T''
                        LEFT JOIN d4 C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        LEFT JOIN d4 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PREV_TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        AND B.RN = C.RN';
    COMMIT;

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_0
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                max(case when rn = 1 then state end) t1_state,
                                max(case when rn = 1 then state_ts end) t1_state_ts,
                                max(case when rn = 2 then state end) t2_state,
                                max(case when rn = 2 then state_ts end) t2_state_ts
                            from ema_states_0 a
                            group by symbol, interval, tick_timestamp, dim_type
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_1_D
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            WHERE B.INTERVAL = ''1D''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t1_state
                        )
                        SELECT * FROM D0';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_1_W
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            WHERE B.INTERVAL = ''1W''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t1_state
                        )
                        SELECT * FROM D0';



    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_1_M
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            WHERE B.INTERVAL = ''1M''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t1_state
                        )
                        SELECT * FROM D0';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_1
                        AS
                        SELECT * FROM EMA_STATES_10_1_D
                        UNION ALL
                        SELECT * FROM EMA_STATES_10_1_W
                        UNION ALL
                        SELECT * FROM EMA_STATES_10_1_M
                        ';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_2_D
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*)  t2_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE B.INTERVAL = ''1D''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t2_state
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_2_W
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*)  t2_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE B.INTERVAL = ''1W''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t2_state
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_2_M
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*)  t2_state_ticks
                            from EMA_STATES_10_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE B.INTERVAL = ''1M''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, a.t2_state
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10_2
                        AS
                        SELECT * FROM EMA_STATES_10_2_D
                        UNION ALL
                        SELECT * FROM EMA_STATES_10_2_W
                        UNION ALL
                        SELECT * FROM EMA_STATES_10_2_M
                        ';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_10
                        AS
                        select a.* , t1_state_high, t1_state_low, t1_state_ticks, t2_state_high, t2_state_low, t2_state_ticks,
                                lag(a.t1_state_ts) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_ts,
                                lag(a.t2_state_ts) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_ts,
                                lag(a.t1_state) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state,
                                lag(a.t2_state) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state,
                                lag(t1_state_ticks) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_ticks,
                                lag(t1_state_high) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_high,
                                lag(t1_state_low) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_low,
                                lag(t2_state_ticks) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_ticks,
                                lag(t2_state_high) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_high,
                                lag(t2_state_low) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_low,

                                CASE 
                                  WHEN A.INTERVAL = ''1D'' THEN D.NEXT_CALENDAR_DAY
                                  WHEN A.INTERVAL = ''1W'' THEN D.NEXT_CALENDAR_WEEK
                                  WHEN A.INTERVAL = ''1M'' THEN D.NEXT_CALENDAR_MONTH
                                END NEXT_TICK_TIMESTAMP
                            from EMA_STATES_10_0 a
                            left join EMA_STATES_10_1 b
                            on a.symbol  = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp = b.tick_timestamp
                            and a.dim_type = b.dim_type
                            left join EMA_STATES_10_2 c
                            on a.symbol  = c.symbol
                            and a.interval = c.interval
                            and a.tick_timestamp = c.tick_timestamp
                            and a.dim_type = c.dim_type
                            JOIN D_TRADING_CALENDAR D
                            ON A.TICK_TIMESTAMP = D.CALENDAR_DAY';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_1_A
                        as
                        select a.symbol, a.interval, D.tick_timestamp, D.CLOSE,                             
                            max(case when dim_type like ''ema_12_30%'' then lag_t1_state_ts end) close12_close30_t1_state_ts,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state_ts end) close12_close30_t2_state_ts,
                            max(case when dim_type like ''ema_12_30%'' then t1_state end) close12_close30_t1_state,
                            max(case when dim_type like ''ema_12_30%'' then t1_state_ticks end) close12_close30_t1_state_ticks,
                            max(case when dim_type like ''ema_12_30%'' then greatest(t1_state_high, d.high) end) close12_close30_t1_state_high,
                            max(case when dim_type like ''ema_12_30%'' then least(t1_state_low, d.low) end) close12_close30_t1_state_low,
                            max(case when dim_type like ''ema_12_30%'' then t2_state end) close12_close30_t2_state,
                            max(case when dim_type like ''ema_12_30%'' then t2_state_ticks end) close12_close30_t2_state_ticks,
                            max(case when dim_type like ''ema_12_30%'' then t2_state_high end) close12_close30_t2_state_high,
                            max(case when dim_type like ''ema_12_30%'' then t2_state_low end) close12_close30_t2_state_low,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) close12_close30_state_high,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) close12_close30_state_low,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) close12_close30_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_12_30%'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) close12_close30_state_close_high_gap,
                            max(case 
                                    when dim_type like ''ema_12_30%'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) close12_close30_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) close12_close30_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12_30%'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close12_close30_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12_30%'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) close12_close30_state_close_low_gap_atr,
                            max(case when dim_type like ''ema_30_50%'' then lag_t1_state_ts end) close30_close50_t1_state_ts,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state_ts end) close30_close50_t2_state_ts,
                            max(case when dim_type like ''ema_30_50%'' then t1_state end) close30_close50_t1_state,
                            max(case when dim_type like ''ema_30_50%'' then t1_state_ticks end) close30_close50_t1_state_ticks,
                            max(case when dim_type like ''ema_30_50%'' then greatest(t1_state_high, d.high) end) close30_close50_t1_state_high,
                            max(case when dim_type like ''ema_30_50%'' then least(t1_state_low, d.low) end) close30_close50_t1_state_low,
                            max(case when dim_type like ''ema_30_50%'' then t2_state end) close30_close50_t2_state,
                            max(case when dim_type like ''ema_30_50%'' then t2_state_ticks end) close30_close50_t2_state_ticks,
                            max(case when dim_type like ''ema_30_50%'' then t2_state_high end) close30_close50_t2_state_high,
                            max(case when dim_type like ''ema_30_50%'' then t2_state_low end) close30_close50_t2_state_low,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) close30_close50_state_high,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) close30_close50_state_low,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) close30_close50_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_30_50%'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) close30_close50_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_30_50%'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) close30_close50_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) close30_close50_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30_50%'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close30_close50_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30_50%'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) close30_close50_state_close_low_gap_atr,
                            max(case when dim_type like ''ema_50_200%'' then lag_t1_state_ts end) close50_close200_t1_state_ts,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state_ts end) close50_close200_t2_state_ts,
                            max(case when dim_type like ''ema_50_200%'' then t1_state end) close50_close200_t1_state,
                            max(case when dim_type like ''ema_50_200%'' then t1_state_ticks end) close50_close200_t1_state_ticks,
                            max(case when dim_type like ''ema_50_200%'' then greatest(t1_state_high, d.high) end) close50_close200_t1_state_high,
                            max(case when dim_type like ''ema_50_200%'' then least(t1_state_low, d.low) end) close50_close200_t1_state_low,
                            max(case when dim_type like ''ema_50_200%'' then t2_state end) close50_close200_t2_state,
                            max(case when dim_type like ''ema_50_200%'' then t2_state_ticks end) close50_close200_t2_state_ticks,
                            max(case when dim_type like ''ema_50_200%'' then t2_state_high end) close50_close200_t2_state_high,
                            max(case when dim_type like ''ema_50_200%'' then t2_state_low end) close50_close200_t2_state_low,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) close50_close200_state_high,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) close50_close200_state_low,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) close50_close200_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_50_200%''  and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_50_200%''  and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) close50_close200_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_50_200%''  and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_50_200%''  and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) close50_close200_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) close50_close200_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50_200%'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50_200%'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close50_close200_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50_200%'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50_200%'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) close50_close200_state_close_low_gap_atr
                        from EMA_STATES_10 a
                        LEFT JOIN STATS_EMA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL 
                        AND D.NEXT_TICK_TIMESTAMP = A.NEXT_TICK_TIMESTAMP
                        join o_mkt_data b
                        on a.symbol = b.symbol
                        and a.interval = b.interval
                        and a.tick_timestamp = b.tick_timestamp
                        JOIN O_MKT_DATA C
                        ON B.SYMBOL = C.SYMBOL
                        AND B.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        AND C.INTERVAL = ''1D''
                        where a.t1_state_ticks > 1 or lag_t1_state is null
                        group by a.symbol, a.interval, D.tick_timestamp, D.close';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_1_B
                        as
                        select a.symbol, a.interval, D.tick_timestamp, D.CLOSE,                             
                            max(case when dim_type like ''ema_12'' then lag_t1_state_ts end) ema12_t1_state_ts,
                            max(case when dim_type like ''ema_12'' then lag_t2_state_ts end) ema12_t2_state_ts,
                            max(case when dim_type like ''ema_12'' then t1_state end) ema12_t1_state,
                            max(case when dim_type like ''ema_12'' then t1_state_ticks end) ema12_t1_state_ticks,
                            max(case when dim_type like ''ema_12'' then greatest(t1_state_high, d.high) end) ema12_t1_state_high,
                            max(case when dim_type like ''ema_12'' then least(t1_state_low, d.low) end) ema12_t1_state_low,
                            max(case when dim_type like ''ema_12'' then t2_state end) ema12_t2_state,
                            max(case when dim_type like ''ema_12'' then t2_state_ticks end) ema12_t2_state_ticks,
                            max(case when dim_type like ''ema_12'' then t2_state_high end) ema12_t2_state_high,
                            max(case when dim_type like ''ema_12'' then t2_state_low end) ema12_t2_state_low,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) ema12_state_high,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) ema12_state_low,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) ema12_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_12'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_12'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) ema12_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_12'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_12'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) ema12_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_12'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) ema12_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema12_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) ema12_state_close_low_gap_atr,   
                            max(case when dim_type like ''ema_30'' then lag_t1_state_ts end) ema30_t1_state_ts,
                            max(case when dim_type like ''ema_30'' then lag_t2_state_ts end) ema30_t2_state_ts,
                            max(case when dim_type like ''ema_30'' then t1_state end) ema30_t1_state,
                            max(case when dim_type like ''ema_30'' then t1_state_ticks end) ema30_t1_state_ticks,
                            max(case when dim_type like ''ema_30'' then greatest(t1_state_high, d.high) end) ema30_t1_state_high,
                            max(case when dim_type like ''ema_30'' then least(t1_state_low, d.low) end) ema30_t1_state_low,
                            max(case when dim_type like ''ema_30'' then t2_state end) ema30_t2_state,
                            max(case when dim_type like ''ema_30'' then t2_state_ticks end) ema30_t2_state_ticks,
                            max(case when dim_type like ''ema_30'' then t2_state_high end) ema30_t2_state_high,
                            max(case when dim_type like ''ema_30'' then t2_state_low end) ema30_t2_state_low,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) ema30_state_high,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) ema30_state_low,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) ema30_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_30'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_30'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) ema30_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_30'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_30'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) ema30_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_30'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) ema30_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema30_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) ema30_state_close_low_gap_atr,
                            max(case when dim_type like ''ema_50'' then lag_t1_state_ts end) ema50_t1_state_ts,
                            max(case when dim_type like ''ema_50'' then lag_t2_state_ts end) ema50_t2_state_ts,
                            max(case when dim_type like ''ema_50'' then t1_state end) ema50_t1_state,
                            max(case when dim_type like ''ema_50'' then t1_state_ticks end) ema50_t1_state_ticks,
                            max(case when dim_type like ''ema_50'' then greatest(t1_state_high, d.high) end) ema50_t1_state_high,
                            max(case when dim_type like ''ema_50'' then least(t1_state_low, d.low) end) ema50_t1_state_low,
                            max(case when dim_type like ''ema_50'' then t2_state end) ema50_t2_state,
                            max(case when dim_type like ''ema_50'' then t2_state_ticks end) ema50_t2_state_ticks,
                            max(case when dim_type like ''ema_50'' then t2_state_high end) ema50_t2_state_high,
                            max(case when dim_type like ''ema_50'' then t2_state_low end) ema50_t2_state_low,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) ema50_state_high,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) ema50_state_low,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) ema50_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_50'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_50'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) ema50_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_50'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_50'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) ema50_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_50'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) ema50_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema50_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) ema50_state_close_low_gap_atr,
                            max(case when dim_type like ''ema_200'' then lag_t1_state_ts end) ema200_t1_state_ts,
                            max(case when dim_type like ''ema_200'' then lag_t2_state_ts end) ema200_t2_state_ts,
                            max(case when dim_type like ''ema_200'' then t1_state end) ema200_t1_state,
                            max(case when dim_type like ''ema_200'' then t1_state_ticks end) ema200_t1_state_ticks,
                            max(case when dim_type like ''ema_200'' then greatest(t1_state_high, d.high) end) ema200_t1_state_high,
                            max(case when dim_type like ''ema_200'' then least(t1_state_low, d.low) end) ema200_t1_state_low,
                            max(case when dim_type like ''ema_200'' then t2_state end) ema200_t2_state,
                            max(case when dim_type like ''ema_200'' then t2_state_ticks end) ema200_t2_state_ticks,
                            max(case when dim_type like ''ema_200'' then t2_state_high end) ema200_t2_state_high,
                            max(case when dim_type like ''ema_200'' then t2_state_low end) ema200_t2_state_low,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when t1_state = 1 then greatest(t1_state_high, d.high)
                                        when t1_state = -1 then t2_state_high
                                    end
                                end) ema200_state_high,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when t1_state = 1 then t2_state_low
                                        when t1_state = -1 then least(t1_state_low, d.low)
                                    end
                                end) ema200_state_low,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(t2_state_low,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(t2_state_high,0), 3)
                                    end
                                end) ema200_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_200'' and t1_state = 1 then round((t1_state_high - D.CLOSE)/NULLIF(t1_state_high, 0), 3) 
                                    when dim_type like ''ema_200'' and t1_state = -1 then round((t2_state_high - D.CLOSE)/NULLIF(t2_state_high, 0), 3)
                                end) ema200_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_200'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(t2_state_low, 0), 3) 
                                    when dim_type like ''ema_200'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(t1_state_low, 0), 3) 
                                end) ema200_state_close_low_gap,
                           abs(max(case when dim_type like ''ema_200'' then
                                    case 
                                        when t1_state = 1 then round((t1_state_high - t2_state_low)/nullif(C.atr,0), 3)
                                        when t1_state = -1 then round((t2_state_high - least(t1_state_low, d.low))/nullif(C.atr,0), 3)
                                    end
                                end)) ema200_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_200'' and t1_state = 1 then round((D.CLOSE - greatest(t1_state_high, d.high))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_200'' and t1_state = -1 then round((D.CLOSE - t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema200_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_200'' and t1_state = 1 then round((D.CLOSE - t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_200'' and t1_state = -1 then round((D.CLOSE - least(t1_state_low, d.low))/NULLIF(C.atr, 0), 3) 
                                end)) ema200_state_close_low_gap_atr
                        from EMA_STATES_10 a
                        LEFT JOIN STATS_EMA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL 
                        AND D.NEXT_TICK_TIMESTAMP = A.NEXT_TICK_TIMESTAMP
                        join o_mkt_data b
                        on a.symbol = b.symbol
                        and a.interval = b.interval
                        and a.tick_timestamp = b.tick_timestamp
                        JOIN O_MKT_DATA C
                        ON B.SYMBOL = C.SYMBOL
                        AND B.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        AND C.INTERVAL = ''1D''
                        where a.t1_state_ticks > 1 or lag_t1_state is null
                        group by a.symbol, a.interval, D.tick_timestamp, D.close';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_1
                        as
                        select a.symbol, a.interval, a.tick_timestamp, a.CLOSE,                             
                            A.close12_close30_t1_state_ts, 
                            A.close12_close30_t2_state_ts, 
                            A.close12_close30_t1_state, 
                            A.close12_close30_t1_state_ticks, 
                            A.close12_close30_t1_state_high,
                            A.close12_close30_t1_state_low,
                            A.close12_close30_t2_state,
                            A.close12_close30_t2_state_ticks,
                            A.close12_close30_t2_state_high,
                            A.close12_close30_t2_state_low,
                            A.close12_close30_state_high,
                            A.close12_close30_state_low,
                            A.close12_close30_state_peak_gap,
                            A.close12_close30_state_close_high_gap,
                            A.close12_close30_state_close_low_gap,
                            A.close12_close30_state_peak_gap_atr,
                            A.close12_close30_state_close_high_gap_atr,
                            A.close12_close30_state_close_low_gap_atr,

                            A.close30_close50_t1_state_ts, 
                            A.close30_close50_t2_state_ts, 
                            A.close30_close50_t1_state, 
                            A.close30_close50_t1_state_ticks, 
                            A.close30_close50_t1_state_high,
                            A.close30_close50_t1_state_low,
                            A.close30_close50_t2_state,
                            A.close30_close50_t2_state_ticks,
                            A.close30_close50_t2_state_high,
                            A.close30_close50_t2_state_low,
                            A.close30_close50_state_high,
                            A.close30_close50_state_low,
                            A.close30_close50_state_peak_gap,
                            A.close30_close50_state_close_high_gap,
                            A.close30_close50_state_close_low_gap,
                            A.close30_close50_state_peak_gap_atr,
                            A.close30_close50_state_close_high_gap_atr,
                            A.close30_close50_state_close_low_gap_atr,

                            A.close50_close200_t1_state_ts, 
                            A.close50_close200_t2_state_ts, 
                            A.close50_close200_t1_state, 
                            A.close50_close200_t1_state_ticks, 
                            A.close50_close200_t1_state_high,
                            A.close50_close200_t1_state_low,
                            A.close50_close200_t2_state,
                            A.close50_close200_t2_state_ticks,
                            A.close50_close200_t2_state_high,
                            A.close50_close200_t2_state_low,
                            A.close50_close200_state_high,
                            A.close50_close200_state_low,
                            A.close50_close200_state_peak_gap,
                            A.close50_close200_state_close_high_gap,
                            A.close50_close200_state_close_low_gap,
                            A.close50_close200_state_peak_gap_atr,
                            A.close50_close200_state_close_high_gap_atr,
                            A.close50_close200_state_close_low_gap_atr,

                            B.ema12_t1_state_ts,
                            B.ema12_t2_state_ts,
                            B.ema12_t1_state,
                            B.ema12_t1_state_ticks,
                            B.ema12_t1_state_high,
                            B. ema12_t1_state_low,
                            B.ema12_t2_state,
                            B.ema12_t2_state_ticks,
                            B.ema12_t2_state_high,
                            B.ema12_t2_state_low,
                            B.ema12_state_high,
                            B.ema12_state_low,
                            B.ema12_state_peak_gap,
                            B.ema12_state_close_high_gap,
                            B.ema12_state_close_low_gap,
                            B.ema12_state_peak_gap_atr,
                            B.ema12_state_close_high_gap_atr,
                            B.ema12_state_close_low_gap_atr,   

                            B.ema30_t1_state_ts,
                            B.ema30_t2_state_ts,
                            B.ema30_t1_state,
                            B.ema30_t1_state_ticks,
                            B.ema30_t1_state_high,
                            B. ema30_t1_state_low,
                            B.ema30_t2_state,
                            B.ema30_t2_state_ticks,
                            B.ema30_t2_state_high,
                            B.ema30_t2_state_low,
                            B.ema30_state_high,
                            B.ema30_state_low,
                            B.ema30_state_peak_gap,
                            B.ema30_state_close_high_gap,
                            B.ema30_state_close_low_gap,
                            B.ema30_state_peak_gap_atr,
                            B.ema30_state_close_high_gap_atr,
                            B.ema30_state_close_low_gap_atr,   

                            B.ema50_t1_state_ts,
                            B.ema50_t2_state_ts,
                            B.ema50_t1_state,
                            B.ema50_t1_state_ticks,
                            B.ema50_t1_state_high,
                            B. ema50_t1_state_low,
                            B.ema50_t2_state,
                            B.ema50_t2_state_ticks,
                            B.ema50_t2_state_high,
                            B.ema50_t2_state_low,
                            B.ema50_state_high,
                            B.ema50_state_low,
                            B.ema50_state_peak_gap,
                            B.ema50_state_close_high_gap,
                            B.ema50_state_close_low_gap,
                            B.ema50_state_peak_gap_atr,
                            B.ema50_state_close_high_gap_atr,
                            B.ema50_state_close_low_gap_atr,   

                            B.ema200_t1_state_ts,
                            B.ema200_t2_state_ts,
                            B.ema200_t1_state,
                            B.ema200_t1_state_ticks,
                            B.ema200_t1_state_high,
                            B. ema200_t1_state_low,
                            B.ema200_t2_state,
                            B.ema200_t2_state_ticks,
                            B.ema200_t2_state_high,
                            B.ema200_t2_state_low,
                            B.ema200_state_high,
                            B.ema200_state_low,
                            B.ema200_state_peak_gap,
                            B.ema200_state_close_high_gap,
                            B.ema200_state_close_low_gap,
                            B.ema200_state_peak_gap_atr,
                            B.ema200_state_close_high_gap_atr,
                            B.ema200_state_close_low_gap_atr

                        FROM EMA_STATES_1_A A
                        JOIN EMA_STATES_1_B B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP';





    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_100_0
                        AS
                        with d0
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type,
                                max(case when rn = 1 then state end) t1_state,
                                max(case when rn = 1 then state_ts end) t1_state_ts,
                                max(case when rn = 2 then state end) t2_state,
                                max(case when rn = 2 then state_ts end) t2_state_ts
                            from ema_states_0 a
                            group by symbol, interval, tick_timestamp, dim_type
                        )
                        select * from d0';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_100_1_D
                        as
                        with
                        d1
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            WHERE A.INTERVAL = ''1D''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d1';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_100_1_W
                        as
                        with
                        d1
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            AND B.CALENDAR_STATUS = ''T''
                            WHERE A.INTERVAL = ''1W''

                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d1';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_100_1_M
                        as
                        with
                        d1
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts,
                                min(b.low) t1_state_low,
                                max(b.high) t1_state_high,
                                count(*) t1_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp between t1_state_ts and a.tick_timestamp
                            AND B.CALENDAR_STATUS = ''T''
                            WHERE A.INTERVAL = ''1M''

                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d1';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_100_1
                        as
                        SELECT * 
                        FROM EMA_STATES_100_1_D
                        UNION ALL
                        SELECT * 
                        FROM EMA_STATES_100_1_W
                        UNION ALL
                        SELECT * 
                        FROM EMA_STATES_100_1_M
                        ';
EXECUTE IMMEDIATE 'create table EMA_STATES_100_2_D
                        as 
                        with d2
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts, 
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*) t2_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE A.INTERVAL = ''1D''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d2';

    EXECUTE IMMEDIATE 'create table EMA_STATES_100_2_W
                        as 
                        with d2
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts, 
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*) t2_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE A.INTERVAL = ''1W''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d2';

    EXECUTE IMMEDIATE 'create table EMA_STATES_100_2_M
                        as 
                        with d2
                        as
                        (
                            select a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts, 
                                min(b.low) t2_state_low,
                                max(b.high) t2_state_high,
                                count(*) t2_state_ticks
                            from EMA_STATES_100_0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.interval = b.interval
                            and b.tick_timestamp >= t2_state_ts 
                            and b.tick_timestamp < t1_state_ts
                            WHERE A.INTERVAL = ''1M''
                            AND B.CALENDAR_STATUS = ''T''
                            group by a.symbol, a.interval, a.tick_timestamp, a.dim_type, t1_state_ts, t2_state_ts
                        )
                        select * from d2';


    EXECUTE IMMEDIATE 'create table EMA_STATES_100_2
                        as 
                        SELECT * 
                        FROM EMA_STATES_100_2_D
                        UNION ALL
                        SELECT * 
                        FROM EMA_STATES_100_2_W
                        UNION ALL
                        SELECT * 
                        FROM EMA_STATES_100_2_M';


    EXECUTE IMMEDIATE 'create table EMA_STATES_100
                        as
                        select a.* , t1_state_high, t1_state_low, t1_state_ticks, 
                                t2_state_high, t2_state_low, t2_state_ticks,
                                lag(a.t1_state_ts) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_ts,
                                lag(a.t2_state_ts) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_ts,
                                lag(a.t1_state) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state,
                                lag(a.t2_state) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state,
                                lag(t1_state_ticks) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_ticks,
                                lag(t1_state_high) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_high,
                                lag(t1_state_low) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t1_state_low,
                                lag(t2_state_ticks) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_ticks,
                                lag(t2_state_high) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_high,
                                lag(t2_state_low) over (partition by a.symbol, a.interval, a.dim_type order by a.tick_timestamp) lag_t2_state_low,

                                CASE 
                                  WHEN A.INTERVAL = ''1D'' THEN D.NEXT_CALENDAR_DAY
                                  WHEN A.INTERVAL = ''1W'' THEN D.NEXT_CALENDAR_WEEK
                                  WHEN A.INTERVAL = ''1M'' THEN D.NEXT_CALENDAR_MONTH
                                END NEXT_TICK_TIMESTAMP
                            from EMA_STATES_100_0 a
                            left join EMA_STATES_100_1 b
                            on a.symbol  = b.symbol
                            and a.interval = b.interval
                            and a.tick_timestamp = b.tick_timestamp
                            and a.dim_type = b.dim_type
                            left join EMA_STATES_100_2 c
                            on a.symbol  = c.symbol
                            and a.interval = c.interval
                            and a.tick_timestamp = c.tick_timestamp
                            and a.dim_type = c.dim_type
                            JOIN D_TRADING_CALENDAR D
                            ON A.TICK_TIMESTAMP = D.CALENDAR_DAY
                            ';

    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_1_0
                        AS
                        select a.symbol, a.interval, D.tick_timestamp, D.close,
                            max(case when dim_type like ''ema_12_30%'' then lag_t1_state_ts end) close12_close30_t1_state_ts,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state_ts end) close12_close30_t2_state_ts,
                            max(case when dim_type like ''ema_12_30%'' then lag_t1_state end) close12_close30_t1_state,
                            max(case when dim_type like ''ema_12_30%'' then lag_t1_state_ticks + 1 end) close12_close30_t1_state_ticks,
                            max(case when dim_type like ''ema_12_30%'' then GREATEST(lag_t1_state_high, D.HIGH) end) close12_close30_t1_state_high,
                            max(case when dim_type like ''ema_12_30%'' then LEAST(lag_t1_state_low, D.LOW) end) close12_close30_t1_state_low,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state end) close12_close30_t2_state,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state_ticks end) close12_close30_t2_state_ticks,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state_high end) close12_close30_t2_state_high,
                            max(case when dim_type like ''ema_12_30%'' then lag_t2_state_low end) close12_close30_t2_state_low,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) close12_close30_state_high,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) close12_close30_state_low,
                            max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) close12_close30_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) close12_close30_state_close_high_gap,
                            max(case 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) close12_close30_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_12_30%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) close12_close30_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close12_close30_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12_30%'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) close12_close30_state_close_low_gap_atr,

                            max(case when dim_type like ''ema_30_50%'' then lag_t1_state_ts end) close30_close50_t1_state_ts,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state_ts end) close30_close50_t2_state_ts,
                            max(case when dim_type like ''ema_30_50%'' then lag_t1_state end) close30_close50_t1_state,
                            max(case when dim_type like ''ema_30_50%'' then lag_t1_state_ticks + 1 end) close30_close50_t1_state_ticks,
                            max(case when dim_type like ''ema_30_50%'' then GREATEST(lag_t1_state_high, D.HIGH) end) close30_close50_t1_state_high,
                            max(case when dim_type like ''ema_30_50%'' then LEAST(lag_t1_state_low, D.LOW) end) close30_close50_t1_state_low,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state end) close30_close50_t2_state,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state_ticks end) close30_close50_t2_state_ticks,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state_high end) close30_close50_t2_state_high,
                            max(case when dim_type like ''ema_30_50%'' then lag_t2_state_low end) close30_close50_t2_state_low,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) close30_close50_state_high,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) close30_close50_state_low,
                            max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) close30_close50_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) close30_close50_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) close30_close50_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_30_50%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) close30_close50_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close30_close50_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30_50%'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) close30_close50_state_close_low_gap_atr,

                            max(case when dim_type like ''ema_50_200%'' then lag_t1_state_ts end) close50_close200_t1_state_ts,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state_ts end) close50_close200_t2_state_ts,
                            max(case when dim_type like ''ema_50_200%'' then lag_t1_state end) close50_close200_t1_state,
                            max(case when dim_type like ''ema_50_200%'' then lag_t1_state_ticks + 1 end) close50_close200_t1_state_ticks,
                            max(case when dim_type like ''ema_50_200%'' then GREATEST(lag_t1_state_high, D.HIGH) end) close50_close200_t1_state_high,
                            max(case when dim_type like ''ema_50_200%'' then LEAST(lag_t1_state_low, D.LOW) end) close50_close200_t1_state_low,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state end) close50_close200_t2_state,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state_ticks end) close50_close200_t2_state_ticks,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state_high end) close50_close200_t2_state_high,
                            max(case when dim_type like ''ema_50_200%'' then lag_t2_state_low end) close50_close200_t2_state_low,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) close50_close200_state_high,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) close50_close200_state_low,
                            max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) close50_close200_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_50_200%''  and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_50_200%''  and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) close50_close200_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_50_200%''  and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_50_200%''  and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) close50_close200_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_50_200%'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) close50_close200_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50_200%'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50_200%'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) close50_close200_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50_200%'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50_200%'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) close50_close200_state_close_low_gap_atr
                        from EMA_STATES_100 a
                        JOIN STATS_EMA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL 
                        AND D.NEXT_TICK_TIMESTAMP = A.NEXT_TICK_TIMESTAMP
                        join o_mkt_data b
                        on D.symbol = b.symbol
                        and D.interval = b.interval
                        and D.tick_timestamp = b.tick_timestamp
                        JOIN O_MKT_DATA C
                        ON B.SYMBOL = C.SYMBOL
                        AND B.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        AND C.INTERVAL = ''1D''
                        where a.t1_state_ticks = 1 AND lag_t1_state is not null
                        group by a.symbol, a.interval, D.tick_timestamp, D.CLOSE';



EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_1_1
                    AS
                        select a.symbol, a.interval, D.tick_timestamp, D.close,

                            max(case when dim_type like ''ema_12'' then lag_t1_state_ts end) ema12_t1_state_ts,
                            max(case when dim_type like ''ema_12'' then lag_t2_state_ts end) ema12_t2_state_ts,
                            max(case when dim_type like ''ema_12'' then lag_t1_state end) ema12_t1_state,
                            max(case when dim_type like ''ema_12'' then lag_t1_state_ticks +1 end) ema12_t1_state_ticks,
                            max(case when dim_type like ''ema_12'' then GREATEST(lag_t1_state_high, D.HIGH) end) ema12_t1_state_high,
                            max(case when dim_type like ''ema_12'' then LEAST(lag_t1_state_low, D.LOW) end) ema12_t1_state_low,
                            max(case when dim_type like ''ema_12'' then lag_t2_state end) ema12_t2_state,
                            max(case when dim_type like ''ema_12'' then lag_t2_state_ticks end) ema12_t2_state_ticks,
                            max(case when dim_type like ''ema_12'' then lag_t2_state_high end) ema12_t2_state_high,
                            max(case when dim_type like ''ema_12'' then lag_t2_state_low end) ema12_t2_state_low,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) ema12_state_high,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) ema12_state_low,
                            max(case when dim_type like ''ema_12'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) ema12_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_12'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_12'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) ema12_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_12'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_12'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) ema12_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_12'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) ema12_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema12_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_12'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_12'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) ema12_state_close_low_gap_atr,

                            max(case when dim_type like ''ema_30'' then lag_t1_state_ts end) ema30_t1_state_ts,
                            max(case when dim_type like ''ema_30'' then lag_t2_state_ts end) ema30_t2_state_ts,
                            max(case when dim_type like ''ema_30'' then lag_t1_state end) ema30_t1_state,
                            max(case when dim_type like ''ema_30'' then lag_t1_state_ticks  +1 end) ema30_t1_state_ticks,
                            max(case when dim_type like ''ema_30'' then GREATEST(lag_t1_state_high, D.HIGH) end) ema30_t1_state_high,
                            max(case when dim_type like ''ema_30'' then LEAST(lag_t1_state_low, D.LOW) end) ema30_t1_state_low,
                            max(case when dim_type like ''ema_30'' then lag_t2_state end) ema30_t2_state,
                            max(case when dim_type like ''ema_30'' then lag_t2_state_ticks end) ema30_t2_state_ticks,
                            max(case when dim_type like ''ema_30'' then lag_t2_state_high end) ema30_t2_state_high,
                            max(case when dim_type like ''ema_30'' then lag_t2_state_low end) ema30_t2_state_low,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) ema30_state_high,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) ema30_state_low,
                            max(case when dim_type like ''ema_30'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) ema30_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_30'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_30'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) ema30_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_30'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_30'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) ema30_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_30'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) ema30_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema30_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_30'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_30'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) ema30_state_close_low_gap_atr,

                            max(case when dim_type like ''ema_50'' then lag_t1_state_ts end) ema50_t1_state_ts,
                            max(case when dim_type like ''ema_50'' then lag_t2_state_ts end) ema50_t2_state_ts,
                            max(case when dim_type like ''ema_50'' then lag_t1_state end) ema50_t1_state,
                            max(case when dim_type like ''ema_50'' then lag_t1_state_ticks +1 end) ema50_t1_state_ticks,
                            max(case when dim_type like ''ema_50'' then GREATEST(lag_t1_state_high, D.HIGH) end) ema50_t1_state_high,
                            max(case when dim_type like ''ema_50'' then LEAST(lag_t1_state_low, D.LOW) end) ema50_t1_state_low,
                            max(case when dim_type like ''ema_50'' then lag_t2_state end) ema50_t2_state,
                            max(case when dim_type like ''ema_50'' then lag_t2_state_ticks end) ema50_t2_state_ticks,
                            max(case when dim_type like ''ema_50'' then lag_t2_state_high end) ema50_t2_state_high,
                            max(case when dim_type like ''ema_50'' then lag_t2_state_low end) ema50_t2_state_low,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) ema50_state_high,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) ema50_state_low,
                            max(case when dim_type like ''ema_50'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) ema50_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_50'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_50'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) ema50_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_50'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_50'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) ema50_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_50'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) ema50_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema50_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_50'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_50'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) ema50_state_close_low_gap_atr,

                            max(case when dim_type like ''ema_200'' then lag_t1_state_ts end) ema200_t1_state_ts,
                            max(case when dim_type like ''ema_200'' then lag_t2_state_ts end) ema200_t2_state_ts,
                            max(case when dim_type like ''ema_200'' then lag_t1_state end) ema200_t1_state,
                            max(case when dim_type like ''ema_200'' then lag_t1_state_ticks +1 end) ema200_t1_state_ticks,
                            max(case when dim_type like ''ema_200'' then GREATEST(lag_t1_state_high, D.HIGH) end) ema200_t1_state_high,
                            max(case when dim_type like ''ema_200'' then LEAST(lag_t1_state_low, D.LOW) end) ema200_t1_state_low,
                            max(case when dim_type like ''ema_200'' then lag_t2_state end) ema200_t2_state,
                            max(case when dim_type like ''ema_200'' then lag_t2_state_ticks end) ema200_t2_state_ticks,
                            max(case when dim_type like ''ema_200'' then lag_t2_state_high end) ema200_t2_state_high,
                            max(case when dim_type like ''ema_200'' then lag_t2_state_low end) ema200_t2_state_low,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when lag_t1_state = 1 then GREATEST(lag_t1_state_high, D.HIGH)
                                        when lag_t1_state = -1 then lag_t2_state_high
                                    end
                                end) ema200_state_high,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when lag_t1_state = 1 then lag_t2_state_low
                                        when lag_t1_state = -1 then LEAST(lag_t1_state_low, D.LOW)
                                    end
                                end) ema200_state_low,
                            max(case when dim_type like ''ema_200'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(lag_t2_state_low,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(lag_t2_state_high,0), 3)
                                    end
                                end) ema200_state_peak_gap,
                            max(case 
                                    when dim_type like ''ema_200'' and lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - D.CLOSE)/NULLIF(GREATEST(lag_t1_state_high, D.HIGH), 0), 3) 
                                    when dim_type like ''ema_200'' and lag_t1_state = -1 then round((lag_t2_state_high - D.CLOSE)/NULLIF(lag_t2_state_high, 0), 3)
                                end) ema200_state_close_high_gap,
                           max(case 
                                    when dim_type like ''ema_200'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(lag_t2_state_low, 0), 3) 
                                    when dim_type like ''ema_200'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(LEAST(lag_t1_state_low, D.LOW), 0), 3) 
                                end) ema200_state_close_low_gap,
                            abs(max(case when dim_type like ''ema_200'' then
                                    case 
                                        when lag_t1_state = 1 then round((GREATEST(lag_t1_state_high, D.HIGH) - lag_t2_state_low)/nullif(C.atr,0), 3)
                                        when lag_t1_state = -1 then round((lag_t2_state_high - LEAST(lag_t1_state_low, D.LOW))/nullif(C.atr,0), 3)
                                    end
                                end)) ema200_state_peak_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_200'' and lag_t1_state = 1 then round((D.CLOSE - GREATEST(lag_t1_state_high, D.HIGH))/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_200'' and lag_t1_state = -1 then round((D.CLOSE - lag_t2_state_high)/NULLIF(C.atr, 0), 3)
                                end)) ema200_state_close_high_gap_atr,
                            (max(case 
                                    when dim_type like ''ema_200'' and lag_t1_state = 1 then round((D.CLOSE - lag_t2_state_low)/NULLIF(C.atr, 0), 3) 
                                    when dim_type like ''ema_200'' and lag_t1_state = -1 then round((D.CLOSE - LEAST(lag_t1_state_low, D.LOW))/NULLIF(C.atr, 0), 3) 
                                end)) ema200_state_close_low_gap_atr
                        from EMA_STATES_100 a
                        LEFT JOIN STATS_EMA D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL 
                        AND D.NEXT_TICK_TIMESTAMP = A.NEXT_TICK_TIMESTAMP
                        join o_mkt_data b
                        on D.symbol = b.symbol
                        and D.interval = b.interval
                        and D.tick_timestamp = b.tick_timestamp
                        JOIN O_MKT_DATA C
                        ON B.SYMBOL = C.SYMBOL
                        AND B.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        AND C.INTERVAL = ''1D''
                        where a.t1_state_ticks = 1 AND lag_t1_state is not null
                        group by a.symbol, a.interval, D.tick_timestamp, D.close';


    EXECUTE IMMEDIATE 'INSERT INTO EMA_STATES_1
                        SELECT A.*,
                            B.EMA12_T1_STATE_TS,
                            B.EMA12_T2_STATE_TS,
                            B.EMA12_T1_STATE,
                            B.EMA12_T1_STATE_TICKS,
                            B.EMA12_T1_STATE_HIGH,
                            B.EMA12_T1_STATE_LOW,
                            B.EMA12_T2_STATE,
                            B.EMA12_T2_STATE_TICKS,
                            B.EMA12_T2_STATE_HIGH,
                            B.EMA12_T2_STATE_LOW,
                            B.EMA12_STATE_HIGH,
                            B.EMA12_STATE_LOW,
                            B.EMA12_STATE_PEAK_GAP,
                            B.EMA12_STATE_CLOSE_HIGH_GAP,
                            B.EMA12_STATE_CLOSE_LOW_GAP,
                            B.EMA12_STATE_PEAK_GAP_ATR,
                            B.EMA12_STATE_CLOSE_HIGH_GAP_ATR,
                            B.EMA12_STATE_CLOSE_LOW_GAP_ATR,
                            B.EMA30_T1_STATE_TS,
                            B.EMA30_T2_STATE_TS,
                            B.EMA30_T1_STATE,
                            B.EMA30_T1_STATE_TICKS,
                            B.EMA30_T1_STATE_HIGH,
                            B.EMA30_T1_STATE_LOW,
                            B.EMA30_T2_STATE,
                            B.EMA30_T2_STATE_TICKS,
                            B.EMA30_T2_STATE_HIGH,
                            B.EMA30_T2_STATE_LOW,
                            B.EMA30_STATE_HIGH,
                            B.EMA30_STATE_LOW,
                            B.EMA30_STATE_PEAK_GAP,
                            B.EMA30_STATE_CLOSE_HIGH_GAP,
                            B.EMA30_STATE_CLOSE_LOW_GAP,
                            B.EMA30_STATE_PEAK_GAP_ATR,
                            B.EMA30_STATE_CLOSE_HIGH_GAP_ATR,
                            B.EMA30_STATE_CLOSE_LOW_GAP_ATR,
                            B.EMA50_T1_STATE_TS,
                            B.EMA50_T2_STATE_TS,
                            B.EMA50_T1_STATE,
                            B.EMA50_T1_STATE_TICKS,
                            B.EMA50_T1_STATE_HIGH,
                            B.EMA50_T1_STATE_LOW,
                            B.EMA50_T2_STATE,
                            B.EMA50_T2_STATE_TICKS,
                            B.EMA50_T2_STATE_HIGH,
                            B.EMA50_T2_STATE_LOW,
                            B.EMA50_STATE_HIGH,
                            B.EMA50_STATE_LOW,
                            B.EMA50_STATE_PEAK_GAP,
                            B.EMA50_STATE_CLOSE_HIGH_GAP,
                            B.EMA50_STATE_CLOSE_LOW_GAP,
                            B.EMA50_STATE_PEAK_GAP_ATR,
                            B.EMA50_STATE_CLOSE_HIGH_GAP_ATR,
                            B.EMA50_STATE_CLOSE_LOW_GAP_ATR,
                            B.EMA200_T1_STATE_TS,
                            B.EMA200_T2_STATE_TS,
                            B.EMA200_T1_STATE,
                            B.EMA200_T1_STATE_TICKS,
                            B.EMA200_T1_STATE_HIGH,
                            B.EMA200_T1_STATE_LOW,
                            B.EMA200_T2_STATE,
                            B.EMA200_T2_STATE_TICKS,
                            B.EMA200_T2_STATE_HIGH,
                            B.EMA200_T2_STATE_LOW,
                            B.EMA200_STATE_HIGH,
                            B.EMA200_STATE_LOW,
                            B.EMA200_STATE_PEAK_GAP,
                            B.EMA200_STATE_CLOSE_HIGH_GAP,
                            B.EMA200_STATE_CLOSE_LOW_GAP,
                            B.EMA200_STATE_PEAK_GAP_ATR,
                            B.EMA200_STATE_CLOSE_HIGH_GAP_ATR,
                            B.EMA200_STATE_CLOSE_LOW_GAP_ATR
                    FROM EMA_STATES_1_0 A
                    JOIN EMA_STATES_1_1 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.tick_timestamp = B.TICK_TIMESTAMP';


    EXECUTE IMMEDIATE 'CREATE TABLE EMA_STATES_2
                        AS
                        SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, a.close,
                            MAX(A.EMA_12_30_POSITION) EMA_12_30_POSITION, 
                            MAX(A.EMA_30_50_POSITION) EMA_30_50_POSITION,
                            MAX(A.EMA_50_200_POSITION) EMA_50_200_POSITION, 
                            MAX(A.EMA_TREND_POSITION) EMA_TREND_POSITION,
                            MAX(A.SLOPE_EMA12) SLOPE_EMA12, 
                            MAX(A.SLOPE_EMA30) SLOPE_EMA30, 
                            MAX(A.SLOPE_EMA50) SLOPE_EMA50, 
                            MAX(A.SLOPE_EMA200) SLOPE_EMA200,
                            MAX(A.PROJ_INTER_CLOSE12_CLOSE30) PROJ_INTER_CLOSE12_CLOSE30, 
                            MAX(A.PROJ_INTER_CLOSE30_CLOSE50) PROJ_INTER_CLOSE30_CLOSE50,
                            MAX(A.PROJ_INTER_CLOSE50_CLOSE200) PROJ_INTER_CLOSE50_CLOSE200,


                            MAX(B.close12_close30_t1_state_ts) close12_close30_t1_state_ts,
                            MAX(B.close12_close30_t2_state_ts) close12_close30_t2_state_ts,
                            MAX(B.close12_close30_t1_state) close12_close30_t1_state,
                            MAX(B.close12_close30_t1_state_ticks) close12_close30_t1_state_ticks,
                            MAX(B.close12_close30_t1_state_high) close12_close30_t1_state_high,
                            MAX(B.close12_close30_t1_state_low) close12_close30_t1_state_low,
                            MAX(B.close12_close30_t2_state) close12_close30_t2_state,
                            MAX(B.close12_close30_t2_state_ticks) close12_close30_t2_state_ticks,
                            MAX(B.close12_close30_t2_state_high) close12_close30_t2_state_high,
                            MAX(B.close12_close30_t2_state_low) close12_close30_t2_state_low,
                            MAX(B.close12_close30_state_high) close12_close30_state_high,
                            MAX(B.close12_close30_state_low) close12_close30_state_low,
                            MAX(B.close12_close30_state_peak_gap) close12_close30_state_peak_gap,
                            MAX(B.close12_close30_state_close_high_gap) close12_close30_state_close_high_gap,
                            MAX(B.close12_close30_state_close_low_gap) close12_close30_state_close_low_gap,
                            MAX(B.close12_close30_state_peak_gap_atr) close12_close30_state_peak_gap_atr,
                            MAX(B.close12_close30_state_close_high_gap_atr) close12_close30_state_close_high_gap_atr,
                            MAX(B.close12_close30_state_close_low_gap_atr) close12_close30_state_close_low_gap_atr,

                            MAX(B.close30_close50_t1_state_ts) close30_close50_t1_state_ts,
                            MAX(B.close30_close50_t2_state_ts) close30_close50_t2_state_ts,
                            MAX(B.close30_close50_t1_state) close30_close50_t1_state,
                            MAX(B.close30_close50_t1_state_ticks)close30_close50_t1_state_ticks ,
                            MAX(B.close30_close50_t1_state_high) close30_close50_t1_state_high,
                            MAX(B.close30_close50_t1_state_low) close30_close50_t1_state_low,
                            MAX(B.close30_close50_t2_state) close30_close50_t2_state,
                            MAX(B.close30_close50_t2_state_ticks) close30_close50_t2_state_ticks,
                            MAX(B.close30_close50_t2_state_high) close30_close50_t2_state_high,
                            MAX(B.close30_close50_t2_state_low) close30_close50_t2_state_low,
                            MAX(B.close30_close50_state_high) close30_close50_state_high,
                            MAX(B.close30_close50_state_low) close30_close50_state_low,
                            MAX(B.close30_close50_state_peak_gap) close30_close50_state_peak_gap,
                            MAX(B.close30_close50_state_close_high_gap) close30_close50_state_close_high_gap,
                            MAX(B.close30_close50_state_close_low_gap) close30_close50_state_close_low_gap,
                            MAX(B.close30_close50_state_peak_gap_atr) close30_close50_state_peak_gap_atr,
                            MAX(B.close30_close50_state_close_high_gap_atr) close30_close50_state_close_high_gap_atr,
                            MAX(B.close30_close50_state_close_low_gap_atr) close30_close50_state_close_low_gap_atr,

                            MAX(B.close50_close200_t1_state_ts) close50_close200_t1_state_ts,
                            MAX(B.close50_close200_t2_state_ts) close50_close200_t2_state_ts,
                            MAX(B.close50_close200_t1_state) close50_close200_t1_state,
                            MAX(B.close50_close200_t1_state_ticks) close50_close200_t1_state_ticks,
                            MAX(B.close50_close200_t1_state_high) close50_close200_t1_state_high,
                            MAX(B.close50_close200_t1_state_low) close50_close200_t1_state_low,
                            MAX(B.close50_close200_t2_state) close50_close200_t2_state,
                            MAX(B.close50_close200_t2_state_ticks) close50_close200_t2_state_ticks,
                            MAX(B.close50_close200_t2_state_high) close50_close200_t2_state_high,
                            MAX(B.close50_close200_t2_state_low) close50_close200_t2_state_low,
                            MAX(B.close50_close200_state_high) close50_close200_state_high,
                            MAX(B.close50_close200_state_low) close50_close200_state_low,
                            MAX(B.close50_close200_state_peak_gap) close50_close200_state_peak_gap,
                            MAX(B.close50_close200_state_close_high_gap) close50_close200_state_close_high_gap,
                            MAX(B.close50_close200_state_close_low_gap) close50_close200_state_close_low_gap,
                            MAX(B.close50_close200_state_peak_gap_atr) close50_close200_state_peak_gap_atr,
                            MAX(B.close50_close200_state_close_high_gap_atr) close50_close200_state_close_high_gap_atr,
                            MAX(B.close50_close200_state_close_low_gap_atr) close50_close200_state_close_low_gap_atr,

                            MAX(B.ema12_t1_state_ts) ema12_t1_state_ts,
                            MAX(B.ema12_t2_state_ts) ema12_t2_state_ts,
                            MAX(B.ema12_t1_state) ema12_t1_state,
                            MAX(B.ema12_t1_state_ticks)ema12_t1_state_ticks ,
                            MAX(B.ema12_t1_state_high)ema12_t1_state_high ,
                            MAX(B.ema12_t1_state_low) ema12_t1_state_low,
                            MAX(B.ema12_t2_state)ema12_t2_state ,
                            MAX(B.ema12_t2_state_ticks) ema12_t2_state_ticks,
                            MAX(B.ema12_t2_state_high) ema12_t2_state_high,
                            MAX(B.ema12_t2_state_low)ema12_t2_state_low ,
                            MAX(B.ema12_state_high) ema12_state_high,
                            MAX(B.ema12_state_low) ema12_state_low,
                            MAX(B.ema12_state_peak_gap) ema12_state_peak_gap,
                            MAX(B.ema12_state_close_high_gap) ema12_state_close_high_gap,
                            MAX(B.ema12_state_close_low_gap) ema12_state_close_low_gap ,
                            MAX(B.ema12_state_peak_gap_atr) ema12_state_peak_gap_atr,
                            MAX(B.ema12_state_close_high_gap_atr) ema12_state_close_high_gap_atr,
                            MAX(B.ema12_state_close_low_gap_atr) ema12_state_close_low_gap_atr ,


                            MAX(B.ema30_t1_state_ts) ema30_t1_state_ts,
                            MAX(B.ema30_t2_state_ts) ema30_t2_state_ts,
                            MAX(B.ema30_t1_state) ema30_t1_state,
                            MAX(B.ema30_t1_state_ticks) ema30_t1_state_ticks,
                            MAX(B.ema30_t1_state_high) ema30_t1_state_high,
                            MAX(B.ema30_t1_state_low) ema30_t1_state_low,
                            MAX(B.ema30_t2_state) ema30_t2_state,
                            MAX(B.ema30_t2_state_ticks) ema30_t2_state_ticks,
                            MAX(B.ema30_t2_state_high) ema30_t2_state_high,
                            MAX(B.ema30_t2_state_low) ema30_t2_state_low,
                            MAX(B.ema30_state_high) ema30_state_high,
                            MAX(B.ema30_state_low) ema30_state_low,
                            MAX(B.ema30_state_peak_gap) ema30_state_peak_gap,
                            MAX(B.ema30_state_close_high_gap) ema30_state_close_high_gap,
                            MAX(B.ema30_state_close_low_gap) ema30_state_close_low_gap,
                            MAX(B.ema30_state_peak_gap_atr) ema30_state_peak_gap_atr,
                            MAX(B.ema30_state_close_high_gap_atr) ema30_state_close_high_gap_atr,
                            MAX(B.ema30_state_close_low_gap_atr) ema30_state_close_low_gap_atr,

                            MAX(B.ema50_t1_state_ts) ema50_t1_state_ts,
                            MAX(B.ema50_t2_state_ts) ema50_t2_state_ts,
                            MAX(B.ema50_t1_state) ema50_t1_state,
                            MAX(B.ema50_t1_state_ticks) ema50_t1_state_ticks,
                            MAX(B.ema50_t1_state_high) ema50_t1_state_high,
                            MAX(B.ema50_t1_state_low) ema50_t1_state_low,
                            MAX(B.ema50_t2_state) ema50_t2_state,
                            MAX(B.ema50_t2_state_ticks) ema50_t2_state_ticks,
                            MAX(B.ema50_t2_state_high) ema50_t2_state_high,
                            MAX(B.ema50_t2_state_low) ema50_t2_state_low,
                            MAX(B.ema50_state_high) ema50_state_high,
                            MAX(B.ema50_state_low) ema50_state_low,
                            MAX(B.ema50_state_peak_gap) ema50_state_peak_gap,
                            MAX(B.ema50_state_close_high_gap) ema50_state_close_high_gap,
                            MAX(B.ema50_state_close_low_gap) ema50_state_close_low_gap,
                            MAX(B.ema50_state_peak_gap_atr) ema50_state_peak_gap_atr,
                            MAX(B.ema50_state_close_high_gap_atr) ema50_state_close_high_gap_atr,
                            MAX(B.ema50_state_close_low_gap_atr) ema50_state_close_low_gap_atr,

                            MAX(B.ema200_t1_state_ts) ema200_t1_state_ts,
                            MAX(B.ema200_t2_state_ts) ema200_t2_state_ts,
                            MAX(B.ema200_t1_state)ema200_t1_state ,
                            MAX(B.ema200_t1_state_ticks) ema200_t1_state_ticks,
                            MAX(B.ema200_t1_state_high) ema200_t1_state_high,
                            MAX(B.ema200_t1_state_low) ema200_t1_state_low,
                            MAX(B.ema200_t2_state) ema200_t2_state,
                            MAX(B.ema200_t2_state_ticks) ema200_t2_state_ticks,
                            MAX(B.ema200_t2_state_high) ema200_t2_state_high,
                            MAX(B.ema200_t2_state_low) ema200_t2_state_low,
                            MAX(B.ema200_state_high) ema200_state_high,
                            MAX(B.ema200_state_low) ema200_state_low,
                            MAX(B.ema200_state_peak_gap) ema200_state_peak_gap,
                            MAX(B.ema200_state_close_high_gap) ema200_state_close_high_gap,
                            MAX(B.ema200_state_close_low_gap) ema200_state_close_low_gap,
                            MAX(B.ema200_state_peak_gap_atr) ema200_state_peak_gap_atr,
                            MAX(B.ema200_state_close_high_gap_atr) ema200_state_close_high_gap_atr,
                            MAX(B.ema200_state_close_low_gap_atr) ema200_state_close_low_gap_atr
                        FROM STATS_EMA A
                        -- FILTER TO THE DELTA TICKS ONLY
                        JOIN DELTA_TICKS D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.INTERVAL = D.INTERVAL
                        AND A.TICK_TIMESTAMP > D.FINAL_TICK_TIMESTAMP
                        LEFT JOIN EMA_STATES_1 B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        GROUP BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.CLOSE';

EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_EMA 
                    with d0
                    as
                    (
                        select a.symbol, a.tick_timestamp, a.atr
                        from o_mkt_data a
                        where interval = ''1D''
                    )

                    select a.*,
                        case
                            when c.interval_low <= b.close12 * 1.001 and least (c.interval_open, c.interval_close) >= b.close12 * .995  then 1
                            when c.interval_high >= b.close12 * 0.999 and greatest (c.interval_open, c.interval_close) <= b.close12 * 1.001 then -1
                        end ema12_reject,
                        case
                            when c.interval_low <= b.close30 * 1.001 and least (c.interval_open, c.interval_close) >= b.close30 * .999 then 1
                            when c.interval_high >= b.close30 * 0.999 and greatest (c.interval_open, c.interval_close) <= b.close30 * 1.001 then -1
                        end ema30_reject,
                        case
                            when c.interval_low <= b.close50 * 1.001 and least (c.interval_open, c.interval_close) >= b.close50 * .999 then 1
                            when c.interval_high >= b.close50 * 0.999 and greatest (c.interval_open, c.interval_close) <= b.close50 * 1.001 then -1
                        end ema50_reject,
                        case
                            when c.interval_low <= b.close200 * 1.001 and least (c.interval_open, c.interval_close) >= b.close200 * .999 then 1
                            when c.interval_high >= b.close200 * 0.999 and greatest (c.interval_open, c.interval_close) <= b.close200 * 1.001 then -1
                        end ema200_reject,

                        round((b.close - b.close12)/d.atr, 2) ema12_gap_atr,
                        round((b.close - b.close30)/d.atr, 2) ema30_gap_atr,
                        round((b.close - b.close50)/d.atr, 2) ema50_gap_atr,
                        round((b.close - b.close200)/d.atr, 2) ema200_gap_atr,

                        round((b.close12 - b.close30)/d.atr, 2) CLOSE12_CLOSE30_gap_atr,
                        round((b.close30 - b.close50)/d.atr, 2) CLOSE30_CLOSE50_gap_atr,
                        round((b.close50 - b.close200)/d.atr, 2) CLOSE50_CLOSE200_gap_atr

                    from EMA_STATES_2 a
                    join o_mkt_data b
                    on a.symbol = b.symbol
                    and a.tick_timestamp = b.tick_timestamp
                    and a.interval = b.interval
                    join d_mkt_data_stats c
                    on a.symbol = c.symbol
                    and a.tick_timestamp = c.tick_timestamp
                    and a.interval = c.interval 
                    join d0 d
                    on a.symbol = d.symbol
                    and a.tick_timestamp = d.tick_timestamp
                    ';


    EXECUTE IMMEDIATE 'DROP TABLE INTERVAL_EMA PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE DELTA_TICKS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE STATS_EMA PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_A PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_B PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_1_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_D PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_W PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_1_M PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_D PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_W PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_10_2_M PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_D PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_W PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_1_M PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_D PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_W PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100_2_M PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_100 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA_STATES_2 PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_TICK_SR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_TICK_SR" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_2_SIG PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_3 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_3_SIG PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN

    EXECUTE IMMEDIATE 'DROP TABLE SR_4 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR_5 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE T
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.SYMBOL, NVL(MAX(B.TICK_TIMESTAMP), ''2015-01-01 00:00:00'') FIRST_TICK_TIMESTAMP
                            FROM D_SYMBOL A
                            LEFT JOIN D_MKT_TICK_SR B
                            ON A.SYMBOL = B.SYMBOL
                            AND B.INTERVAL = ''1D''
                            GROUP BY A.SYMBOL
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE T0
                        AS
                        WITH MAIN_DATA
                        AS
                        (
                            SELECT SYMBOL, MAX(TICK_TIMESTAMP) MAX_TICK_TIMESTAMP 
                            FROM O_MKT_DATA 
                            GROUP BY SYMBOL
                        ),
                        SR_MAIN_DATA
                        AS
                        (
                            SELECT A.SYMBOL, NVL(MAX(TICK_TIMESTAMP), ''2015-01-01 00:00:00'') SR_MAX_TICK_TIMESTAMP 
                            FROM D_SYMBOL A
                            LEFT JOIN D_MKT_TICK_SR B
                            ON A.SYMBOL = B.SYMBOL
                            GROUP BY A.SYMBOL
                        ),
                        D0
                        AS
                        (
                            SELECT A.SYMBOL, ''1D'' INTERVAL, 
                                CALENDAR_DAY,
                                NEXT_CALENDAR_DAY HIGH_CALENDAR_TIMESTAMP_FILTER, 
                                PREV_CALENDAR_DAY PREV_CALENDAR_TIMESTAMP
                            FROM MAIN_DATA A
                            JOIN SR_MAIN_DATA C
                            ON A.SYMBOL = C.SYMBOL
                            JOIN D_TRADING_CALENDAR B
                            ON B.CALENDAR_DAY > C.SR_MAX_TICK_TIMESTAMP
                            AND B.CALENDAR_DAY <= A.MAX_TICK_TIMESTAMP
                            UNION ALL
                            SELECT A.SYMBOL, ''1W'' INTERVAL, 
                                CALENDAR_DAY,
                                NEXT_CALENDAR_WEEK HIGH_CALENDAR_TIMESTAMP_FILTER, 
                                PREV_CALENDAR_WEEK PREV_CALENDAR_TIMESTAMP
                            FROM MAIN_DATA A
                            JOIN SR_MAIN_DATA C
                            ON A.SYMBOL = C.SYMBOL
                            JOIN D_TRADING_CALENDAR B
                            ON B.CALENDAR_DAY > C.SR_MAX_TICK_TIMESTAMP
                            AND B.CALENDAR_DAY <= A.MAX_TICK_TIMESTAMP
                            UNION ALL
                            SELECT A.SYMBOL, ''1M'' INTERVAL, 
                                CALENDAR_DAY,
                                NEXT_CALENDAR_MONTH HIGH_CALENDAR_TIMESTAMP_FILTER, 
                                PREV_CALENDAR_MONTH PREV_CALENDAR_TIMESTAMP
                            FROM MAIN_DATA A
                            JOIN SR_MAIN_DATA C
                            ON A.SYMBOL = C.SYMBOL
                            JOIN D_TRADING_CALENDAR B
                            ON B.CALENDAR_DAY > C.SR_MAX_TICK_TIMESTAMP
                            AND B.CALENDAR_DAY <= A.MAX_TICK_TIMESTAMP
                        )
                        SELECT *
                        FROM D0';


----- TREND LOGIC
    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_0
                        AS
                        WITH D0
                        AS
                        (
                            SELECT SYMBOL, INTERVAL, TREND_START_TS PIVOT_TS, TREND_START_STATUS_TS_FILTER PIVOT_STATUS_TS
                            FROM D_MKT_TRENDS
                            WHERE TREND_START_STATUS_TS_FILTER IS NOT NULL
                            UNION
                            SELECT A.SYMBOL, A.INTERVAL, A.TREND_END_TS, GREATEST (A.TREND_START_STATUS_TS_FILTER, B.PIVOT_STATUS_TS) PIVOT_STATUS_TS
                            FROM D_MKT_TRENDS A
                            JOIN D_MKT_PIVOTS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TREND_END_TS = B.PIVOT_TIMESTAMP
                            AND B.PIVOT_STATUS = ''T''
                            WHERE A.TREND_TYPE  = ''SIDE''
                            AND A.TREND_START_STATUS_TS_FILTER IS NOT NULL
                            UNION 
                            SELECT SYMBOL, INTERVAL, PIVOT_TIMESTAMP, SIG_PIVOT_STATUS_TS
                            FROM D_MKT_PIVOTS 
                            WHERE SIG_PIVOT_STATUS_TS IS NOT NULL
                        ),
                        D1
                        AS
                        (
                            SELECT SYMBOL, INTERVAL, PIVOT_TS, MIN (PIVOT_STATUS_TS) PIVOT_STATUS_TS
                            FROM D0
                            GROUP BY SYMBOL, INTERVAL, PIVOT_TS
                        ),
                        D2
                        AS
                        (
                            SELECT DISTINCT A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP PIVOT_TS, A.PIVOT_VALUE,
                                A.OPEN PIVOT_OPEN, A.CLOSE PIVOT_CLOSE, A.LOW PIVOT_LOW, A.HIGH PIVOT_HIGH, A.PIVOT_TYPE, B.PIVOT_STATUS_TS
                            FROM D_MKT_PIVOTS A
                            JOIN D1 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.PIVOT_TIMESTAMP = B.PIVOT_TS
                            AND A.PIVOT_STATUS = ''T''
                        )
                        SELECT * FROM D2';

    -----------------------------------------------------------------
    -- 1D
    -----------------------------------------------------------------

    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1D_0
                        AS
                        WITH D2
                        AS
                        (
                            select A.*, d.calendar_day, d.prev_calendar_TIMESTAMP
                            FROM SR_1_0 A
                            JOIN T0 D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND D.CALENDAR_DAY >= A.PIVOT_STATUS_TS
                            AND A.PIVOT_TS BETWEEN TO_CHAR(TO_DATE(D.CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS'') - 360, ''YYYY-MM-DD HH24:MI:SS'') 
                                            AND D.CALENDAR_DAY
                            WHERE D.INTERVAL = ''1D''
                        )
                        select * from d2';



    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1D_1
                        AS
                        WITH D2
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.END_TS PIVOT_TS,
                                    D.PIVOT_VALUE, D.OPEN PIVOT_OPEN, D.CLOSE PIVOT_CLOSE, D.LOW PIVOT_LOW, D.HIGH PIVOT_HIGH, D.PIVOT_TYPE,
                                    B.CALENDAR_DAY, B.prev_calendar_TIMESTAMP
                            FROM D_MKT_TICK_TRENDS A
                            JOIN D_MKT_PIVOTS D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND A.END_TS = D.PIVOT_TIMESTAMP
                            AND D.PIVOT_STATUS = ''T''
                            JOIN T0 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            WHERE A.INTERVAL = ''1D''
                        )
                        select * from d2';


    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1D_2
                        AS
                        WITH D0
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM SR_1_1D_1 A
                            LEFT JOIN SR_1_1D_0 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.CALENDAR_DAY = B.CALENDAR_DAY
                            AND A.PIVOT_TS = B.PIVOT_TS
                            WHERE A.INTERVAL = ''1D''
                            AND B.CALENDAR_DAY IS NULL
                        ),
                        D1
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM D0 A
                            UNION 
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM SR_1_1D_0 A

                        )
                        select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                A.CALENDAR_DAY, A.PREV_CALENDAR_TIMESTAMP,
                                MAX(CASE WHEN B.SYMBOL IS NOT NULL THEN 1 END) IS_SIG_PIVOT
                        from d1 A
                        LEFT JOIN D_MKT_PIVOTS B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PIVOT_TS = B.PIVOT_TIMESTAMP
                        AND A.PIVOT_TYPE = B.PIVOT_TYPE
                        AND B.PIVOT_STATUS = ''T''
                        AND A.CALENDAR_DAY >= B.SIG_PIVOT_STATUS_TS
                        GROUP BY A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, A.CALENDAR_DAY, A.PREV_CALENDAR_TIMESTAMP';



    -----------------------------------------------------------------
    -- 1WM
    -----------------------------------------------------------------

    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1WM_0
                        AS
                        WITH D2
                        AS
                        (
                            select A.*, d.calendar_DAY, d.prev_calendar_TIMESTAMP
                            FROM SR_1_0 A
                            JOIN T0 D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND D.CALENDAR_DAY >= A.PIVOT_STATUS_TS
                            AND A.PIVOT_TS BETWEEN TO_CHAR(TO_DATE(D.CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS'') - 
                                                                case
                                                                    when D.interval = ''1W'' then 1000
                                                                    when D.interval = ''1M'' then 5000
                                                                END , ''YYYY-MM-DD HH24:MI:SS'') AND D.CALENDAR_DAY
                                                    WHERE D.INTERVAL IN (''1M'', ''1W'')
                        )
                        select * from d2';


    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1WM_1
                        AS
                        WITH D2
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.END_TS PIVOT_TS,
                                    D.PIVOT_VALUE, D.OPEN PIVOT_OPEN, D.CLOSE PIVOT_CLOSE, D.LOW PIVOT_LOW, D.HIGH PIVOT_HIGH, D.PIVOT_TYPE,
                                    B.CALENDAR_DAY, B.prev_calendar_TIMESTAMP
                            FROM D_MKT_TICK_TRENDS A
                            JOIN D_MKT_PIVOTS D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.INTERVAL = D.INTERVAL
                            AND A.END_TS = D.PIVOT_TIMESTAMP
                            AND D.PIVOT_STATUS = ''T''
                            JOIN T0 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            WHERE A.INTERVAL IN (''1W'', ''1M'')
                        )
                        select * from d2';

    EXECUTE IMMEDIATE 'CREATE TABLE SR_1_1WM_2
                        AS
                        WITH D0
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM SR_1_1WM_1 A
                            LEFT JOIN SR_1_1WM_0 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.CALENDAR_DAY = B.CALENDAR_DAY
                            AND A.PIVOT_TS = B.PIVOT_TS
                            WHERE A.INTERVAL IN (''1W'', ''1M'')
                            AND B.CALENDAR_DAY IS NULL
                        ),
                        D1
                        AS
                        (
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM D0 A
                            UNION 
                            select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                    A.CALENDAR_DAY, A.prev_calendar_TIMESTAMP
                            FROM SR_1_1WM_0 A

                        )
                        select A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                A.CALENDAR_DAY, A.PREV_CALENDAR_TIMESTAMP,
                                MAX(CASE WHEN B.SYMBOL IS NOT NULL THEN 1 END) IS_SIG_PIVOT
                        from d1 A
                        LEFT JOIN D_MKT_PIVOTS B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.PIVOT_TS = B.PIVOT_TIMESTAMP
                        AND A.PIVOT_TYPE = B.PIVOT_TYPE
                        AND B.PIVOT_STATUS = ''T''
                        AND A.CALENDAR_DAY >= B.SIG_PIVOT_STATUS_TS
                        GROUP BY A.SYMBOL, A.INTERVAL, A.PIVOT_TS, A.PIVOT_VALUE, A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, A.CALENDAR_DAY, A.PREV_CALENDAR_TIMESTAMP';

    ---------------------------------------------------------------------
    ---------------------------------------------------------------------

    EXECUTE IMMEDIATE 'CREATE TABLE SR_1
                        AS
                        WITH D0
                        AS
                        (
                            SELECT * FROM SR_1_1D_2
                            UNION 
                            SELECT * FROM SR_1_1WM_2
                        )
                        SELECT DISTINCT * FROM D0';


    EXECUTE IMMEDIATE 'CREATE TABLE SR_2
                        AS
                        with d0
                            as
                            (
                                select A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY TICK_TIMESTAMP, A.PIVOT_TS, A.PIVOT_VALUE,
                                        A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY ORDER BY A.PIVOT_VALUE DESC) PIVOT_VALUE_RN 
                                FROM SR_1 A
                                JOIN O_MKT_DATA B
                                ON A.SYMBOL = B.SYMBOL
                                AND B.INTERVAL = ''1D''
                                AND A.CALENDAR_DAY = B.TICK_TIMESTAMP 
                                AND B.CLOSE >= A.PIVOT_VALUE
                            )
                            SELECT SYMBOL, INTERVAL, ''TREND'' SR_TYPE, TICK_TIMESTAMP, ''LOW'' SR_LEVEL, PIVOT_TS, PIVOT_VALUE ,
                            PIVOT_OPEN, PIVOT_CLOSE, PIVOT_LOW, PIVOT_HIGH, PIVOT_TYPE
                        FROM D0
                        WHERE PIVOT_VALUE_RN = 1';

    EXECUTE IMMEDIATE 'CREATE TABLE SR_2_SIG
                        AS
                        with d0
                            as
                            (
                                select A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY TICK_TIMESTAMP, A.PIVOT_TS, A.PIVOT_VALUE,
                                        A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY ORDER BY A.PIVOT_VALUE DESC) PIVOT_VALUE_RN 
                                FROM SR_1 A
                                JOIN O_MKT_DATA B
                                ON A.SYMBOL = B.SYMBOL
                                AND B.INTERVAL = ''1D''
                                AND A.CALENDAR_DAY = B.TICK_TIMESTAMP 
                                AND B.CLOSE >= A.PIVOT_VALUE
                                AND A.IS_SIG_PIVOT IS NOT NULL
                            )
                            SELECT SYMBOL, INTERVAL, ''TREND'' SR_TYPE, TICK_TIMESTAMP, ''LOW'' SR_LEVEL, PIVOT_TS, PIVOT_VALUE ,
                            PIVOT_OPEN, PIVOT_CLOSE, PIVOT_LOW, PIVOT_HIGH, PIVOT_TYPE
                        FROM D0
                        WHERE PIVOT_VALUE_RN = 1';



    EXECUTE IMMEDIATE 'CREATE TABLE SR_3
                        AS
                        with d0
                            as
                            (
                                select A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY TICK_TIMESTAMP, A.PIVOT_TS, A.PIVOT_VALUE,
                                        A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY ORDER BY A.PIVOT_VALUE) PIVOT_VALUE_RN 
                                FROM SR_1 A
                                JOIN O_MKT_DATA B
                                ON A.SYMBOL = B.SYMBOL
                                AND B.INTERVAL = ''1D''
                                AND B.TICK_TIMESTAMP = A.CALENDAR_DAY
                                AND B.CLOSE <= A.PIVOT_VALUE
                            )
                            SELECT SYMBOL, INTERVAL, ''TREND'' SR_TYPE, TICK_TIMESTAMP, ''HIGH'' SR_LEVEL, PIVOT_TS, PIVOT_VALUE ,
                            PIVOT_OPEN, PIVOT_CLOSE, PIVOT_LOW, PIVOT_HIGH, PIVOT_TYPE
                        FROM D0
                        WHERE PIVOT_VALUE_RN = 1';

    EXECUTE IMMEDIATE 'CREATE TABLE SR_3_SIG
                        AS
                        with d0
                            as
                            (
                                select A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY TICK_TIMESTAMP, A.PIVOT_TS, A.PIVOT_VALUE,
                                        A.PIVOT_OPEN, A.PIVOT_CLOSE, A.PIVOT_LOW, A.PIVOT_HIGH, A.PIVOT_TYPE, 
                                        ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.CALENDAR_DAY ORDER BY A.PIVOT_VALUE) PIVOT_VALUE_RN 
                                FROM SR_1 A
                                JOIN O_MKT_DATA B
                                ON A.SYMBOL = B.SYMBOL
                                AND B.INTERVAL = ''1D''
                                AND B.TICK_TIMESTAMP = A.CALENDAR_DAY
                                AND B.CLOSE <= A.PIVOT_VALUE
                                AND A.IS_SIG_PIVOT IS NOT NULL
                            )
                            SELECT SYMBOL, INTERVAL, ''TREND'' SR_TYPE, TICK_TIMESTAMP, ''HIGH'' SR_LEVEL, PIVOT_TS, PIVOT_VALUE ,
                            PIVOT_OPEN, PIVOT_CLOSE, PIVOT_LOW, PIVOT_HIGH, PIVOT_TYPE
                        FROM D0
                        WHERE PIVOT_VALUE_RN = 1';



    EXECUTE IMMEDIATE 'CREATE TABLE SR_4
                        AS
                            SELECT A.SYMBOL, A.INTERVAL SR_INTERVAL, A.SR_TYPE, A.TICK_TIMESTAMP, A.SR_LEVEL, 
                                  A.PIVOT_TS SR_TIMESTAMP, A.PIVOT_VALUE SR_VALUE, A.PIVOT_TYPE,
                                  B.PIVOT_TS SR_TIMESTAMP_SIG, B.PIVOT_VALUE SR_VALUE_SIG, B.PIVOT_TYPE PIVOT_TYPE_SIG
                            FROM SR_2 A
                            LEFT JOIN SR_2_SIG B
                            ON A.SYMBOL = B.SYMBOL 
                              AND A.INTERVAL = B.INTERVAL
                              AND A.SR_TYPE = B.SR_TYPE
                              AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP 
                              AND A.SR_LEVEL = B.SR_LEVEL
                            UNION ALL
                            SELECT A.SYMBOL, A.INTERVAL, A.SR_TYPE, A.TICK_TIMESTAMP, A.SR_LEVEL, A.PIVOT_TS SR_TIMESTAMP, A.PIVOT_VALUE SR_VALUE, A.PIVOT_TYPE,
                                  B.PIVOT_TS SR_TIMESTAMP_SIG, B.PIVOT_VALUE SR_VALUE_SIG, B.PIVOT_TYPE PIVOT_TYPE_SIG
                            FROM SR_3 A
                            LEFT JOIN SR_3_SIG B
                            ON A.SYMBOL = B.SYMBOL 
                              AND A.INTERVAL = B.INTERVAL
                              AND A.SR_TYPE = B.SR_TYPE
                              AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP 
                              AND A.SR_LEVEL = B.SR_LEVEL';

    EXECUTE IMMEDIATE 'CREATE TABLE SR_5
                        AS
                        WITH D4
                            AS
                            (
                                SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.ATR, B.SR_INTERVAL, B.SR_TYPE, B.SR_LEVEL, 
                                    B.SR_TIMESTAMP, B.SR_VALUE, B.PIVOT_TYPE,
                                    B.SR_TIMESTAMP_SIG, B.SR_VALUE_SIG, B.PIVOT_TYPE_SIG,
                                    A.HIGH INTERVAL_HIGH, A.LOW INTERVAL_LOW, A.CLOSE INTERVAL_CLOSE, A.OPEN INTERVAL_OPEN
                                FROM O_MKT_DATA A
                                JOIN SR_4 B
                                ON A.SYMBOL = B.SYMBOL
                                AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                                AND CASE 
                                        WHEN A.INTERVAL = ''1D'' THEN 1
                                        WHEN A.INTERVAL = ''1W'' AND B.SR_INTERVAL IN (''1W'', ''1M'') THEN 1
                                        WHEN A.INTERVAL = ''1M'' AND B.SR_INTERVAL IN (''1M'') THEN 1
                                    END  = 1
                            ),
                            D5
                            AS
                            (
                                SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.ATR, A.SR_INTERVAL, A.SR_TYPE, A.SR_LEVEL, 
                                    A.SR_TIMESTAMP, A.SR_VALUE, A.PIVOT_TYPE,
                                    CASE
                                        WHEN PIVOT_TYPE = ''LOW'' AND SR_LEVEL = ''LOW''
                                            AND LEAST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) >= C.LOW AND A.INTERVAL_LOW <= C.LOW THEN 1
                                        WHEN PIVOT_TYPE = ''LOW'' AND SR_LEVEL = ''HIGH''
                                            AND GREATEST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) <= C.LOW AND A.INTERVAL_HIGH >= C.LOW THEN -1
                                        WHEN PIVOT_TYPE = ''HIGH'' AND SR_LEVEL = ''HIGH''
                                            AND GREATEST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) <= C.HIGH AND A.INTERVAL_HIGH >= C.HIGH THEN -1
                                        WHEN PIVOT_TYPE = ''HIGH'' AND SR_LEVEL = ''LOW''
                                            AND LEAST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) >= C.HIGH  AND A.INTERVAL_LOW <= C.HIGH THEN 1
                                    END SR_REJECT,
                                    ROUND((A.INTERVAL_CLOSE - SR_VALUE)/A.INTERVAL_CLOSE, 3) SR_GAP,
                                    ROUND((A.INTERVAL_CLOSE - SR_VALUE)/A.ATR, 2) SR_GAP_ATR,


                                    A.SR_TIMESTAMP_SIG, A.SR_VALUE_SIG, A.PIVOT_TYPE_SIG,
                                    CASE
                                        WHEN PIVOT_TYPE_SIG = ''LOW'' AND SR_LEVEL = ''LOW''
                                            AND LEAST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) >= B.LOW AND A.INTERVAL_LOW <= B.LOW THEN 1
                                        WHEN PIVOT_TYPE_SIG = ''LOW'' AND SR_LEVEL = ''HIGH''
                                            AND GREATEST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) <= B.LOW AND A.INTERVAL_HIGH >= B.LOW THEN -1
                                        WHEN PIVOT_TYPE_SIG = ''HIGH'' AND SR_LEVEL = ''HIGH''
                                            AND GREATEST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) <= B.HIGH AND A.INTERVAL_HIGH >= B.HIGH THEN -1
                                        WHEN PIVOT_TYPE_SIG = ''HIGH'' AND SR_LEVEL = ''LOW''
                                            AND LEAST(A.INTERVAL_CLOSE, A.INTERVAL_OPEN) >= B.HIGH  AND A.INTERVAL_LOW <= B.HIGH THEN 1
                                    END SR_REJECT_SIG,
                                    ROUND((A.INTERVAL_CLOSE - SR_VALUE_SIG)/A.INTERVAL_CLOSE, 3) SR_GAP_SIG,
                                    ROUND((A.INTERVAL_CLOSE - SR_VALUE_SIG)/A.ATR, 2) SR_GAP_ATR_SIG
                                FROM D4 A
                                JOIN O_MKT_DATA C
                                ON A.SYMBOL = C.SYMBOL
                                AND A.INTERVAL = C.INTERVAL
                                AND A.SR_TIMESTAMP = C.TICK_TIMESTAMP
                                LEFT JOIN O_MKT_DATA B
                                ON A.SYMBOL = B.SYMBOL
                                AND A.INTERVAL = B.INTERVAL
                                AND A.SR_TIMESTAMP_SIG = B.TICK_TIMESTAMP
                            )
                            SELECT * FROM D5';

    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_SR
                            (SYMBOL,
                            INTERVAL,
                            TICK_TIMESTAMP,
                            ATR,
                            SR_INTERVAL,
                            SR_TYPE,
                            SR_LEVEL,
                            SR_TIMESTAMP,
                            SR_VALUE,
                            PIVOT_TYPE,
                            SR_REJECT,
                            SR_GAP,
                            SR_GAP_ATR,
                            SR_TIMESTAMP_SIG,
                            SR_VALUE_SIG,
                            PIVOT_TYPE_SIG,
                            SR_REJECT_SIG,
                            SR_GAP_SIG,
                            SR_GAP_ATR_SIG)
                        SELECT SYMBOL,
                            INTERVAL,
                            TICK_TIMESTAMP,
                            ATR,
                            SR_INTERVAL,
                            SR_TYPE,
                            SR_LEVEL,
                            SR_TIMESTAMP,
                            SR_VALUE,
                            PIVOT_TYPE,
                            SR_REJECT,
                            SR_GAP,
                            SR_GAP_ATR,
                            SR_TIMESTAMP_SIG,
                            SR_VALUE_SIG,
                            PIVOT_TYPE_SIG,
                            SR_REJECT_SIG,
                            SR_GAP_SIG,
                            SR_GAP_ATR_SIG
                        FROM SR_5';

    EXECUTE IMMEDIATE 'DROP TABLE T PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1D_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1_1WM_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_3 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_2_SIG PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_3_SIG PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_4 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR_5 PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END; 


/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_TICK_TRENDS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_TICK_TRENDS" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE MAX_DATES PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_D PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_W PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_M PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_00 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_SIDE PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_UP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_DOWN PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

------------------------------------------------------------------------
------------------------------------------------------------------------
    EXECUTE IMMEDIATE 'CREATE TABLE MAX_DATES
        AS
        WITH D0
        AS
        (
            SELECT ''1D'' INTERVAL FROM DUAL
            UNION ALL
            SELECT ''1W'' INTERVAL FROM DUAL
            UNION ALL
            SELECT ''1M'' INTERVAL FROM DUAL
        )
        SELECT A.SYMBOL, C.INTERVAL, NVL(MAX(B.TICK_TIMESTAMP), ''2015-01-01 00:00:00'') TICK_TIMESTAMP
        FROM D_SYMBOL A
        CROSS JOIN D0 C
        LEFT JOIN D_MKT_TICK_TRENDS B
        ON A.SYMBOL = B.SYMBOL
        AND C.INTERVAL = C.INTERVAL
        GROUP BY A.SYMBOL, C.INTERVAL
        ';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_0_D
        AS
        WITH D0
        AS
        (
            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE,
                MAX (B.TREND_START_TS) START_TS
            FROM O_MKT_DATA A
            JOIN D_MKT_TRENDS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND A.TICK_TIMESTAMP >= B.TREND_START_STATUS_TS_FILTER
            JOIN MAX_DATES C
            ON A.SYMBOL = C.SYMBOL
            AND A.INTERVAL = C.INTERVAL
            AND A.TICK_TIMESTAMP > C.TICK_TIMESTAMP
            WHERE TREND_START_STATUS_TS_FILTER IS NOT NULL
            AND A.INTERVAL = ''1D''
            GROUP BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE
        )
        select * from D0';

    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_0_W
        AS
        WITH D0
        AS
        (
            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE,
                MAX (B.TREND_START_TS) START_TS
            FROM O_MKT_DATA A
            JOIN D_MKT_TRENDS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND A.TICK_TIMESTAMP >= B.TREND_START_STATUS_TS_FILTER
            JOIN MAX_DATES C
            ON A.SYMBOL = C.SYMBOL
            AND A.INTERVAL = C.INTERVAL
            AND A.TICK_TIMESTAMP > C.TICK_TIMESTAMP
            WHERE TREND_START_STATUS_TS_FILTER IS NOT NULL
            AND A.INTERVAL = ''1W''
            GROUP BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE
        )
        select * from D0';

    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_0_M
        AS
        WITH D0
        AS
        (
            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE,
                MAX (B.TREND_START_TS) START_TS
            FROM O_MKT_DATA A
            JOIN D_MKT_TRENDS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND A.TICK_TIMESTAMP >= B.TREND_START_STATUS_TS_FILTER
            JOIN MAX_DATES C
            ON A.SYMBOL = C.SYMBOL
            AND A.INTERVAL = C.INTERVAL
            AND A.TICK_TIMESTAMP > C.TICK_TIMESTAMP
            WHERE TREND_START_STATUS_TS_FILTER IS NOT NULL
            AND A.INTERVAL = ''1M''
            GROUP BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, TREND_TYPE
        )
        select * from D0';

    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_0
        AS
        SELECT * FROM TRENDS_0_D
        UNION ALL
        SELECT * FROM TRENDS_0_W
        UNION ALL
        SELECT * FROM TRENDS_0_M';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_SIDE
        AS
        WITH D0
        AS
        (
            SELECT *
            FROM TRENDS_0
            WHERE TREND_TYPE = ''SIDE''
        ),
        D1
        AS
        (
            SELECT A.*, TREND_START_NEXT_TS END_TS
            FROM D0 A
            JOIN D_MKT_TRENDS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND B.TREND_TYPE = ''SIDE''
            AND B.TREND_START_TS = A.START_TS
        )
        SELECT * FROM D1';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_UP
        AS
        WITH D0
        AS
        (
            SELECT *
            FROM TRENDS_0
            WHERE TREND_TYPE = ''UP''
        ),
        D1
        AS
        (
            SELECT DISTINCT A.*, 
                FIRST_VALUE (B.PIVOT_TIMESTAMP) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP ORDER BY B.HIGH DESC) END_TS
            FROM D0 A
            JOIN D_MKT_PIVOTS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND B.PIVOT_STATUS = ''T''
            AND B.PIVOT_TYPE = ''HIGH''
            AND A.TICK_TIMESTAMP >= B.PIVOT_STATUS_TS
            AND A.START_TS < B.PIVOT_TIMESTAMP
        )
        SELECT * FROM D1';

    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_DOWN
        AS
        WITH D0
        AS
        (
            SELECT *
            FROM TRENDS_0
            WHERE TREND_TYPE = ''DOWN''
        ),
        D1
        AS
        (
            SELECT DISTINCT A.*, 
                FIRST_VALUE (B.PIVOT_TIMESTAMP) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP ORDER BY B.LOW) END_TS
            FROM D0 A
            JOIN D_MKT_PIVOTS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND B.PIVOT_STATUS = ''T''
            AND B.PIVOT_TYPE = ''LOW''
            AND A.TICK_TIMESTAMP >= B.PIVOT_STATUS_TS
            AND A.START_TS < B.PIVOT_TIMESTAMP
        )
        SELECT * FROM D1';

    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_00
        AS
        (
            SELECT *
            FROM TRENDS_SIDE 
            UNION
            SELECT * 
            FROM TRENDS_UP 
            UNION 
            SELECT *
            FROM TRENDS_DOWN
        )';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_1
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.*, B.PIVOT_VALUE START_PIVOT_VALUE, C.PIVOT_VALUE END_PIVOT_VALUE, D.CLOSE, D.ATR

                            FROM TRENDS_00 A
                            JOIN O_MKT_DATA D
                            ON A.SYMBOL = D.SYMBOL
                            AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                            AND D.INTERVAL = ''1D''
                            JOIN D_MKT_PIVOTS B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.START_TS = B.PIVOT_TIMESTAMP
                            JOIN D_MKT_PIVOTS C
                            ON A.SYMBOL = C.SYMBOL
                            AND A.INTERVAL = C.INTERVAL
                            AND A.END_TS = C.PIVOT_TIMESTAMP
                        ),
                        D1
                        AS
                        (
                            SELECT A.*, 
                                ROUND((CLOSE - START_PIVOT_VALUE)/ATR, 2) START_TREND_GAP_ATR,
                                ROUND((CLOSE - END_PIVOT_VALUE)/ATR, 2) END_TREND_GAP_ATR
                            FROM D0 A
                        )
                        SELECT *
                        FROM D1';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_2
                        AS                        
                        WITH D0
                        AS
                        (
                            select A.*, 
                                CASE WHEN TREND_TYPE IN (''UP'', ''DOWN'') THEN ''TREND'' ELSE ''SIDE'' END TREND_CATEGORY
                            from TRENDS_1 A
                        ),
                        D1
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.TREND_TYPE, A.START_TS,
                                A.TREND_CATEGORY, 
                                CASE 
                                    WHEN A.TREND_TYPE = ''UP'' AND START_TREND_GAP_ATR > 0 THEN 1
                                    WHEN A.TREND_TYPE = ''DOWN'' AND START_TREND_GAP_ATR < 0 THEN 1
                                    WHEN A.TREND_TYPE = ''SIDE'' THEN 1
                                END IS_VALID_TREND
                            FROM D0 A
                        ),
                        D2
                        AS
                        (
                            SELECT A.SYMBOL, A.INTERVAL, A.TICK_TIMESTAMP, A.TREND_TYPE, A.START_TS,
                                MAX(START_TS) OVER (PARTITION BY SYMBOL, INTERVAL, TICK_TIMESTAMP, TREND_CATEGORY ORDER BY START_TS DESC) START_TS_CAT
                            FROM D1 A
                            WHERE IS_VALID_TREND = 1
                        ),
                        D3
                        AS
                        (
                            SELECT B.*
                            FROM D2 A
                            JOIN TRENDS_1 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                            AND A.TREND_TYPE = B.TREND_TYPE
                            AND A.START_TS = B.START_TS
                            WHERE A.START_TS = A.START_TS_CAT
                        )
                        SELECT * FROM D3';

    EXECUTE IMMEDIATE 'DELETE FROM D_MKT_TICK_TRENDS 
                        WHERE (SYMBOL, INTERVAL, TICK_TIMESTAMP) IN (SELECT SYMBOL, INTERVAL, TICK_TIMESTAMP FROM TRENDS_2)';
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_TRENDS
                        SELECT * FROM TRENDS_2';


--    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_TRENDS';
--    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_TRENDS AS
--                        SELECT * FROM TRENDS_2';



    EXECUTE IMMEDIATE 'DROP TABLE MAX_DATES PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_D PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_W PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0_M PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_00 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_SIDE PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_UP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_DOWN PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;    


/
--------------------------------------------------------
--  DDL for Function POP_D_MKT_TRENDS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_MKT_TRENDS" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE FILTERS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE FILTERS_AGG PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_3 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_4 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_5 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS_6 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE FILTERS 
            AS
            WITH INTERVALS
            AS
            (
                SELECT ''1D'' INTERVAL FROM DUAL
                UNION ALL
                SELECT ''1W'' INTERVAL FROM DUAL
                UNION ALL
                SELECT ''1M'' INTERVAL FROM DUAL
            ),
            TRENDS
            AS
            (
                SELECT ''UP'' TREND_TYPE FROM DUAL
                UNION ALL
                SELECT ''DOWN'' TREND_TYPE FROM DUAL
                UNION ALL
                SELECT ''SIDE'' TREND_TYPE FROM DUAL
            ),
            D0
            AS
            (
                SELECT A.SYMBOL, B.INTERVAL, C.TREND_TYPE, D.TREND_START_TS,
                    ROW_NUMBER() OVER (PARTITION BY A.SYMBOL, B.INTERVAL, C.TREND_TYPE ORDER BY D.TREND_START_TS DESC) RN
                FROM D_SYMBOL A
                CROSS JOIN INTERVALS B
                CROSS JOIN TRENDS C
                LEFT JOIN D_MKT_TRENDS D
                ON D.SYMBOL = A.SYMBOL
                AND D.INTERVAL = B.INTERVAL
                AND D.TREND_TYPE = C.TREND_TYPE
                AND D.TREND_START_TS IS NOT NULL
            ),
            D1
            AS
            (
                SELECT A.SYMBOL, A.INTERVAL, A.TREND_TYPE,
                    NVL(MIN(CASE WHEN RN = 2 THEN A.TREND_START_TS END), ''2015-01-01 00:00:00'') LAST_TREND_START_TS,
                    NVL(MIN(CASE WHEN RN = 4 THEN A.TREND_START_TS END), ''2015-01-01 00:00:00'') PREV_TREND_START_TS
                FROM D0 A
                GROUP BY A.SYMBOL, A.INTERVAL, A.TREND_TYPE
            )
            SELECT *
            FROM D1';


    EXECUTE IMMEDIATE 'CREATE TABLE FILTERS_AGG
            AS
            SELECT A.SYMBOL, A.INTERVAL,
                MIN (PREV_TREND_START_TS) PREV_TREND_START_TS
            FROM FILTERS A
            GROUP BY A.SYMBOL, A.INTERVAL';

    EXECUTE IMMEDIATE
        'CREATE TABLE TRENDS_0
                as
                with d0
                as
                (
                    select a.* , 
                        lag(A.pivot_type) over (partition by A.symbol, A.interval order by A.pivot_timestamp) prev_pivot_type
                    from d_mkt_pivots a
                    JOIN FILTERS_AGG B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.PIVOT_TIMESTAMP >= B.PREV_TREND_START_TS
                    WHERE A.pivot_status = ''T'' 
                ),
                d1
                as
                (
                    select a.*, 
                        case when pivot_type = prev_pivot_type then null else pivot_timestamp end pivot_seg_flag
                    from d0 a
                ),
                d2
                as
                (
                    select a.*,
                       case when pivot_seg_flag is null then lag(pivot_seg_flag) ignore nulls over (partition by symbol, interval order by pivot_timestamp) else pivot_timestamp  end pivot_seg_ts
                    from d1 a
                ),
                d3
                as
                (
                    select distinct a.symbol, a.interval, a.pivot_seg_ts , A.PIVOT_STATUS_TS,
                        first_value (a.pivot_timestamp) over (partition by a.symbol, a.interval, a.pivot_seg_ts order by a.high desc) pivot_ts_high,
                        first_value (a.pivot_timestamp) over (partition by a.symbol, a.interval, a.pivot_seg_ts order by a.low) pivot_ts_low
                    from d2 a
                ),
                d4
                as
                (
                    select distinct a.symbol, a.interval, a.pivot_timestamp, a.pivot_type, A.PIVOT_STATUS_TS, a.open, a.high, a.low, a.close,
                            case when a.pivot_type = ''HIGH'' then a.high when a.pivot_type = ''LOW'' then least (a.close, a.open) end high_value,
                            case when a.pivot_type = ''HIGH'' then greatest (a.close, a.open) when a.pivot_type = ''LOW'' then a.low end low_value 
                    from d2 a
                    join d3 b
                    on a.symbol = b.symbol
                    and a.interval = b.interval
                    and a.pivot_seg_ts = b.pivot_seg_ts
                    and case when a.pivot_type = ''HIGH'' then b.pivot_ts_high when a.pivot_type = ''LOW'' then b.pivot_ts_low end = a.pivot_timestamp
                ),
                d5
                as
                (
                    select a.*,         
                        lag (a.high_value) over (partition by a.symbol, a.interval, a.pivot_type order by a.pivot_timestamp) prev1_type_high_value,
                        lag (a.low_value) over (partition by a.symbol, a.interval, a.pivot_type order by a.pivot_timestamp) prev1_type_low_value,
                        lead (a.pivot_timestamp) over (partition by a.symbol, a.interval, a.pivot_type order by a.pivot_timestamp) next1_type_ts
                    from d4 a 
                ),
                d6
                as
                (
                    select a.*, 
                        case when a.pivot_type = ''HIGH'' and a.high_value >= a.prev1_type_high_value then ''HH''
                             when a.pivot_type = ''HIGH'' and a.high_value < a.prev1_type_high_value then ''LH''
                             when a.pivot_type = ''LOW'' and a.low_value >= a.prev1_type_low_value then ''HL''
                             when a.pivot_type = ''LOW'' and a.low_value < a.prev1_type_low_value then ''LL''
                        end pivot_move_type
                    from d5 a
                )
                select *
                from d6';


    --- TRENDS
    -----------
    EXECUTE IMMEDIATE
        'CREATE TABLE TRENDS_1
                as
                WITH D0
                AS
                (
                    SELECT SYMBOL, INTERVAL, PIVOT_TIMESTAMP, PIVOT_TYPE, PIVOT_MOVE_TYPE, 
                        LEAD(PIVOT_MOVE_TYPE) OVER (PARTITION BY SYMBOL, INTERVAL, PIVOT_TYPE ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_MOVE_TYPE,
                        LAG(PIVOT_TIMESTAMP) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) PREV_PIVOT_TS,
                        LEAD(PIVOT_TIMESTAMP) OVER (PARTITION BY SYMBOL, INTERVAL, PIVOT_TYPE ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_TYPE_TS,
                        LEAD(PIVOT_TIMESTAMP) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_TS,
                        LEAD(PIVOT_MOVE_TYPE) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_MOVE
                    FROM TRENDS_0
                ),
                D1
                AS
                (
                    SELECT A.*, 
                        CASE WHEN PIVOT_MOVE_TYPE = NEXT_PIVOT_MOVE_TYPE THEN NULL ELSE PIVOT_TIMESTAMP END PIVOT_MOVE_TYPE_SEG
                    FROM D0 A
                ),
                D2
                AS
                (
                    SELECT A.*, 
                        LAG(PIVOT_MOVE_TYPE_SEG) IGNORE NULLS OVER (PARTITION BY SYMBOL, INTERVAL, PIVOT_TYPE ORDER BY PIVOT_TIMESTAMP) TREND_START_TS
                    FROM D1 A
                ),
                D3
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, A.PIVOT_TYPE, A.PIVOT_MOVE_TYPE, B.NEXT_PIVOT_TS, B.NEXT_PIVOT_TYPE_TS,
                        CASE WHEN A.PIVOT_TYPE = ''LOW'' AND B.NEXT_PIVOT_MOVE = ''LH'' THEN B.PREV_PIVOT_TS
                             WHEN A.PIVOT_TYPE = ''LOW'' AND B.NEXT_PIVOT_MOVE = ''HH'' THEN B.NEXT_PIVOT_TS
                             WHEN A.PIVOT_TYPE = ''HIGH'' AND B.NEXT_PIVOT_MOVE = ''HL'' THEN B.PREV_PIVOT_TS
                             WHEN A.PIVOT_TYPE = ''HIGH'' AND B.NEXT_PIVOT_MOVE = ''LL'' THEN B.NEXT_PIVOT_TS
                        END TREND_START_TS 
                    FROM D2 A
                    LEFT OUTER JOIN D2 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND B.PIVOT_TIMESTAMP = A.TREND_START_TS
                ),
                D4
                AS
                (
                    SELECT SYMBOL, INTERVAL, 
                        CASE 
                            WHEN PIVOT_TYPE = ''LOW'' AND SUBSTR(PIVOT_MOVE_TYPE, 1, 1) = ''L'' THEN ''DOWN''
                            WHEN PIVOT_TYPE = ''HIGH'' AND SUBSTR(PIVOT_MOVE_TYPE, 1, 1) = ''H'' THEN ''UP''
                        END TREND_TYPE,
                        TREND_START_TS,
                        NEXT_PIVOT_TS TREND_START_NEXT_TS,
                        MAX(PIVOT_TIMESTAMP) TREND_END_TS,
                        --MIN(PIVOT_TIMESTAMP) TREND_START_STATUS_TS
                        NEXT_PIVOT_TYPE_TS TREND_START_STATUS_TS
                    FROM D3
                    GROUP BY SYMBOL, INTERVAL, TREND_START_TS, PIVOT_TYPE, PIVOT_MOVE_TYPE, NEXT_PIVOT_TS, NEXT_PIVOT_TYPE_TS
                ),
                D5
                AS
                (
                    SELECT A.*, B.NEXT1_TYPE_TS TREND_END_STATUS_TS
                    FROM D4 A
                    LEFT OUTER JOIN TRENDS_0 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.TREND_END_TS = B.PIVOT_TIMESTAMP
                    WHERE A.TREND_TYPE IS NOT NULL

                )
                SELECT * 
                FROM D5';


    EXECUTE IMMEDIATE
        'CREATE TABLE TRENDS_2
                as
                WITH D0
                AS
                (
                    SELECT DISTINCT A.*, 
                        CASE WHEN A.TREND_TYPE = ''UP'' THEN B.LOW_VALUE 
                             WHEN A.TREND_TYPE = ''DOWN'' THEN B.HIGH_VALUE
                        END TREND_START_VALUE,
                        CASE WHEN A.TREND_TYPE = ''UP'' THEN C.HIGH_VALUE 
                             WHEN A.TREND_TYPE = ''DOWN'' THEN C.LOW_VALUE
                        END TREND_END_VALUE
                    FROM TRENDS_1 A
                    JOIN TRENDS_0 B
                    ON A.SYMBOL = B.SYMBOL
                    AND A.INTERVAL = B.INTERVAL
                    AND A.TREND_START_TS = B.PIVOT_TIMESTAMP
                    JOIN TRENDS_0 C
                    ON A.SYMBOL = C.SYMBOL
                    AND A.INTERVAL = C.INTERVAL
                    AND A.TREND_END_TS = C.PIVOT_TIMESTAMP
                ),
                D1
                AS
                (
                    SELECT A.SYMBOL, A.INTERVAL, A.TREND_START_TS, A.TREND_START_NEXT_TS,
                        COUNT(DISTINCT CASE WHEN A.INTERVAL = ''1W'' THEN REPORTING_YEAR_ID||CALENDAR_WEEK_ID
                                            WHEN A.INTERVAL = ''1M'' THEN CALENDAR_YEAR_ID||CALENDAR_MONTH_ID
                                            ELSE CALENDAR_DAY END) - 1 TREND_DURATION
                    FROM D0 A
                    JOIN D_TRADING_CALENDAR B
                    ON B.CALENDAR_DAY BETWEEN A.TREND_START_TS AND A.TREND_END_TS
                    GROUP BY A.SYMBOL, A.INTERVAL, A.TREND_START_TS, A.TREND_START_NEXT_TS
                )
                SELECT A.* , 
                        TREND_DURATION, 
                        ROUND(ABS(TREND_END_VALUE - TREND_START_VALUE)/TREND_START_VALUE, 3) TREND_SIZE
                FROM D0 A
                JOIN D1 B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                AND A.TREND_START_TS = B.TREND_START_TS';



    --- RANGES
    -----------
    EXECUTE IMMEDIATE
        'CREATE TABLE TRENDS_3
            AS
            WITH D0
            AS
            (
                SELECT SYMBOL, INTERVAL, 
                    PIVOT_TIMESTAMP, 
                    LEAD (PIVOT_TIMESTAMP) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_TIMESTAMP
                FROM TRENDS_0
            ),
            D1
            AS
            (
                SELECT A.SYMBOL, A.INTERVAL,
                    A.TREND_END_TS TREND_START_TS,
                    A.TREND_END_STATUS_TS TREND_START_STATUS_TS,
                    A.TREND_TYPE,
                    B.NEXT_PIVOT_TIMESTAMP,
                    A.TREND_START_TS PREV_TREND_START_TS
                FROM TRENDS_2 A
                JOIN D0 B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                AND A.TREND_END_TS = B.PIVOT_TIMESTAMP
                WHERE TREND_TYPE IN (''UP'', ''DOWN'')
            ),
            D2
            AS
            (
                SELECT A.SYMBOL, A.INTERVAL, A.TREND_START_TS,  A.TREND_START_STATUS_TS,   
                    A.NEXT_PIVOT_TIMESTAMP TREND_START_NEXT_TS,
                    ''SIDE'' TREND_TYPE, 
                    CASE WHEN A.TREND_TYPE = ''UP'' THEN B.LOW_VALUE 
                         WHEN A.TREND_TYPE = ''DOWN'' THEN C.LOW_VALUE
                    END TREND_RESISTANCE_LOW_VALUE,
                    CASE WHEN A.TREND_TYPE = ''UP'' THEN B.HIGH_VALUE 
                         WHEN A.TREND_TYPE = ''DOWN'' THEN C.HIGH_VALUE
                    END TREND_RESISTANCE_HIGH_VALUE,

                    CASE WHEN A.TREND_TYPE = ''UP'' THEN C.LOW_VALUE 
                         WHEN A.TREND_TYPE = ''DOWN'' THEN B.LOW_VALUE
                    END TREND_SUPPORT_LOW_VALUE,
                    CASE WHEN A.TREND_TYPE = ''UP'' THEN C.HIGH_VALUE 
                         WHEN A.TREND_TYPE = ''DOWN'' THEN B.HIGH_VALUE
                    END TREND_SUPPORT_HIGH_VALUE,
                    A.PREV_TREND_START_TS
                FROM D1 A
                LEFT JOIN TRENDS_0 B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                AND A.TREND_START_TS = B.PIVOT_TIMESTAMP
                LEFT JOIN TRENDS_0 C
                ON A.SYMBOL = C.SYMBOL
                AND A.INTERVAL = C.INTERVAL
                AND A.NEXT_PIVOT_TIMESTAMP = C.PIVOT_TIMESTAMP
            )
            SELECT * 
            FROM D2';


    EXECUTE IMMEDIATE
        'CREATE TABLE TRENDS_4
            AS
            WITH D0
            AS
            (
                SELECT SYMBOL, INTERVAL, PIVOT_TIMESTAMP, PIVOT_TYPE, PIVOT_MOVE_TYPE, CLOSE, LOW, HIGH, OPEN,
                    LEAD(PIVOT_TIMESTAMP) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT_PIVOT_TS,
                    LEAD(PIVOT_TIMESTAMP, 2) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT1_PIVOT_TS,
                    LEAD(PIVOT_STATUS_TS, 2) OVER (PARTITION BY SYMBOL, INTERVAL ORDER BY PIVOT_TIMESTAMP) NEXT1_PIVOT_STATUS_TS
                FROM TRENDS_0
            ),
            D1
            AS
            (
                select A.SYMBOL, A.INTERVAL, A.PIVOT_TIMESTAMP, 
                    A.CLOSE, 
                    B.CLOSE NEXT_CLOSE, 
                    C.CLOSE NEXT1_CLOSE, 
                    A.NEXT1_PIVOT_TS,
                    A.NEXT1_PIVOT_STATUS_TS
                FROM D0 A
                LEFT JOIN D0 B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                AND A.NEXT_PIVOT_TS = B.PIVOT_TIMESTAMP
                LEFT JOIN D0 C
                ON A.SYMBOL = C.SYMBOL
                AND A.INTERVAL = C.INTERVAL
                AND A.NEXT1_PIVOT_TS = C.PIVOT_TIMESTAMP
            ),
            D2
            AS
            (
                SELECT A.SYMBOL, A.INTERVAL, A.TREND_TYPE, A.TREND_START_TS, A.TREND_START_STATUS_TS,
                        A.TREND_START_NEXT_TS,
                        A.TREND_RESISTANCE_LOW_VALUE,
                        A.TREND_RESISTANCE_HIGH_VALUE,
                        A.TREND_SUPPORT_LOW_VALUE,
                        A.TREND_SUPPORT_HIGH_VALUE,
                        A.PREV_TREND_START_TS,
                        MIN(CASE WHEN B.CLOSE >= A.TREND_RESISTANCE_HIGH_VALUE AND B.NEXT_CLOSE > A.TREND_RESISTANCE_HIGH_VALUE AND B.NEXT1_CLOSE > A.TREND_RESISTANCE_HIGH_VALUE 
                                    THEN B.NEXT1_PIVOT_TS
                                 WHEN B.CLOSE <= A.TREND_SUPPORT_LOW_VALUE AND B.NEXT_CLOSE < A.TREND_SUPPORT_LOW_VALUE AND B.NEXT1_CLOSE < A.TREND_SUPPORT_LOW_VALUE
                                    THEN B.NEXT1_PIVOT_TS
                            END) TREND_END_TS,
                        MIN(CASE WHEN B.CLOSE >= A.TREND_RESISTANCE_HIGH_VALUE AND B.NEXT_CLOSE > A.TREND_RESISTANCE_HIGH_VALUE AND B.NEXT1_CLOSE > A.TREND_RESISTANCE_HIGH_VALUE 
                                    THEN B.NEXT1_PIVOT_STATUS_TS
                                 WHEN B.CLOSE <= A.TREND_SUPPORT_LOW_VALUE AND B.NEXT_CLOSE < A.TREND_SUPPORT_LOW_VALUE AND B.NEXT1_CLOSE < A.TREND_SUPPORT_LOW_VALUE
                                    THEN B.NEXT1_PIVOT_STATUS_TS
                            END) TREND_END_STATUS_TS

                FROM TRENDS_3 A
                LEFT JOIN D1 B
                ON A.SYMBOL = B.SYMBOL
                AND A.INTERVAL = B.INTERVAL
                AND B.PIVOT_TIMESTAMP >= a.TREND_START_STATUS_TS
                GROUP BY A.SYMBOL, A.INTERVAL, A.TREND_TYPE, A.TREND_START_TS, A.TREND_START_NEXT_TS, A.TREND_START_STATUS_TS, A.TREND_RESISTANCE_LOW_VALUE, A.TREND_RESISTANCE_HIGH_VALUE, A.TREND_SUPPORT_LOW_VALUE, A.TREND_SUPPORT_HIGH_VALUE, A.PREV_TREND_START_TS
            )
            SELECT *
            FROM D2
            ';


    -- PUTTING DATA TOGETHER
    EXECUTE IMMEDIATE 
        'CREATE TABLE TRENDS_5
            AS
            WITH D0
            AS
            (
                SELECT SYMBOL, INTERVAL, TREND_TYPE, 
                       TREND_START_TS, TREND_START_NEXT_TS, TREND_END_TS, TREND_START_STATUS_TS, TREND_END_STATUS_TS,
                       NULL TREND_START_VALUE,
                       NULL TREND_END_VALUE,
                       NULL TREND_DURATION,
                       NULL TREND_SIZE,
                       TREND_RESISTANCE_LOW_VALUE,
                       TREND_RESISTANCE_HIGH_VALUE,
                       TREND_SUPPORT_LOW_VALUE,
                       TREND_SUPPORT_HIGH_VALUE, 
                       PREV_TREND_START_TS
                FROM TRENDS_4
                UNION ALL
                SELECT SYMBOL, INTERVAL, TREND_TYPE, 
                       TREND_START_TS, TREND_START_NEXT_TS, TREND_END_TS, TREND_START_STATUS_TS, TREND_END_STATUS_TS,
                       TREND_START_VALUE,
                       TREND_END_VALUE,
                       TREND_DURATION,
                       TREND_SIZE,
                       NULL TREND_RESISTANCE_LOW_VALUE,
                       NULL TREND_RESISTANCE_HIGH_VALUE,
                       NULL TREND_SUPPORT_LOW_VALUE,
                       NULL TREND_SUPPORT_HIGH_VALUE, 
                       NULL
                FROM TRENDS_2
            )
            SELECT A.* , 
                B.PIVOT_STATUS_TS TREND_START_STATUS_TS_FILTER,
                C.PIVOT_STATUS_TS TREND_END_STATUS_TS_FILTER
            FROM D0 A
            LEFT JOIN D_MKT_PIVOTS B
            ON A.SYMBOL = B.SYMBOL
            AND A.INTERVAL = B.INTERVAL
            AND A.TREND_START_STATUS_TS = B.PIVOT_TIMESTAMP
            LEFT JOIN D_MKT_PIVOTS C
            ON A.SYMBOL = C.SYMBOL
            AND A.INTERVAL = C.INTERVAL
            AND A.TREND_END_STATUS_TS = C.PIVOT_TIMESTAMP';


    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS_6
                        AS
                        SELECT A.SYMBOL,
                                A.INTERVAL,
                                A.TREND_TYPE,
                                A.TREND_START_TS,
                                A.TREND_START_NEXT_TS,
                                A.TREND_END_TS,
                                A.TREND_START_STATUS_TS,
                                A.TREND_END_STATUS_TS,
                                A.TREND_START_VALUE,
                                A.TREND_END_VALUE,
                                A.TREND_DURATION,
                                A.TREND_SIZE,
                                A.TREND_RESISTANCE_LOW_VALUE,
                                A.TREND_RESISTANCE_HIGH_VALUE,
                                A.TREND_SUPPORT_LOW_VALUE,
                                A.TREND_SUPPORT_HIGH_VALUE,
                                A.PREV_TREND_START_TS,
                                A.TREND_START_STATUS_TS_FILTER,
                                A.TREND_END_STATUS_TS_FILTER
                        FROM D_MKT_TRENDS A
                        JOIN FILTERS B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.TREND_TYPE = B.TREND_TYPE
                        AND A.TREND_START_TS < B.LAST_TREND_START_TS
                        UNION ALL
                        SELECT A.SYMBOL,
                                A.INTERVAL,
                                A.TREND_TYPE,
                                A.TREND_START_TS,
                                A.TREND_START_NEXT_TS,
                                A.TREND_END_TS,
                                A.TREND_START_STATUS_TS,
                                A.TREND_END_STATUS_TS,
                                A.TREND_START_VALUE,
                                A.TREND_END_VALUE,
                                A.TREND_DURATION,
                                A.TREND_SIZE,
                                A.TREND_RESISTANCE_LOW_VALUE,
                                A.TREND_RESISTANCE_HIGH_VALUE,
                                A.TREND_SUPPORT_LOW_VALUE,
                                A.TREND_SUPPORT_HIGH_VALUE,
                                A.PREV_TREND_START_TS,
                                A.TREND_START_STATUS_TS_FILTER,
                                A.TREND_END_STATUS_TS_FILTER
                        FROM TRENDS_5 A
                        JOIN FILTERS B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.INTERVAL = B.INTERVAL
                        AND A.TREND_TYPE = B.TREND_TYPE
                        AND A.TREND_START_TS >= B.LAST_TREND_START_TS';

    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TRENDS';
    EXECUTE IMMEDIATE 
        'INSERT INTO D_MKT_TRENDS  (SYMBOL,
                                    INTERVAL,
                                    TREND_TYPE,
                                    TREND_START_TS,
                                    TREND_START_NEXT_TS,
                                    TREND_END_TS,
                                    TREND_START_STATUS_TS,
                                    TREND_END_STATUS_TS,
                                    TREND_START_VALUE,
                                    TREND_END_VALUE,
                                    TREND_DURATION,
                                    TREND_SIZE,
                                    TREND_RESISTANCE_LOW_VALUE,
                                    TREND_RESISTANCE_HIGH_VALUE,
                                    TREND_SUPPORT_LOW_VALUE,
                                    TREND_SUPPORT_HIGH_VALUE,
                                    PREV_TREND_START_TS,
                                    TREND_START_STATUS_TS_FILTER,
                                    TREND_END_STATUS_TS_FILTER)
            SELECT SYMBOL,
                    INTERVAL,
                    TREND_TYPE,
                    TREND_START_TS,
                    TREND_START_NEXT_TS,
                    TREND_END_TS,
                    TREND_START_STATUS_TS,
                    TREND_END_STATUS_TS,
                    TREND_START_VALUE,
                    TREND_END_VALUE,
                    TREND_DURATION,
                    TREND_SIZE,
                    TREND_RESISTANCE_LOW_VALUE,
                    TREND_RESISTANCE_HIGH_VALUE,
                    TREND_SUPPORT_LOW_VALUE,
                    TREND_SUPPORT_HIGH_VALUE,
                    PREV_TREND_START_TS,
                    TREND_START_STATUS_TS_FILTER,
                    TREND_END_STATUS_TS_FILTER
             FROM TRENDS_6';

    EXECUTE IMMEDIATE 'DROP TABLE FILTERS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE FILTERS_AGG PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_3 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_4 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_5 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS_6 PURGE';



    COMMIT;
    RETURN 'SUCCESS';
END;


/
--------------------------------------------------------
--  DDL for Function POP_D_SYMBOL_INCLUDE_STEP_1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_SYMBOL_INCLUDE_STEP_1" (P_IS_BACKFILL VARCHAR2 DEFAULT 'N')
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN
    IF P_IS_BACKFILL = 'Y' 
    THEN
        DELETE FROM D_SYMBOL_INCLUDE;
        INSERT INTO D_SYMBOL_INCLUDE
            SELECT SYMBOL, SYSDATE
            FROM D_SYMBOL;
        DELETE FROM D_SYMBOL;
        COMMIT;

        SELECT DATA_CLEANUP('2015-01-01 00:00:00', P_IS_BACKFILL)
        INTO V_OUTPUT
        FROM DUAL;
    ELSE    
        FOR SYMBOL_REC IN (SELECT SYMBOL FROM D_SYMBOL_INCLUDE)
        LOOP
            SELECT POP_D_SYMBOL_REMOVE(SYMBOL_REC.SYMBOL) 
            INTO V_OUTPUT
            FROM DUAL;
        END LOOP;
    END IF;




    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_SYMBOL_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE O_MKT_DATA_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_EMA_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_SR_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_TRENDS_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TRENDS_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE D_MKT_DATA_STATS_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_DATA_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_SIGNALS_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_TRADE_TEMP PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    EXECUTE IMMEDIATE 'CREATE TABLE D_SYMBOL_TEMP
                        AS
                        SELECT * FROM D_SYMBOL';

    EXECUTE IMMEDIATE 'CREATE TABLE O_MKT_DATA_TEMP
                        AS
                        SELECT * FROM O_MKT_DATA';

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_PIVOTS_TEMP
                        AS
                        SELECT * FROM D_MKT_PIVOTS';                            

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_EMA_TEMP
                        AS
                        SELECT * FROM D_MKT_TICK_EMA';

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_SR_TEMP
                        AS
                        SELECT * FROM D_MKT_TICK_SR';                            

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_TRENDS_TEMP
                        AS
                        SELECT * FROM D_MKT_TICK_TRENDS';                            

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TRENDS_TEMP
                        AS
                        SELECT * FROM D_MKT_TRENDS';                            

    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_DATA_STATS_TEMP
                        AS
                        SELECT * FROM D_MKT_DATA_STATS';                            

    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_DATA_TEMP
                        AS
                        SELECT * FROM O_MODEL_DATA';                            

    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_SIGNALS_TEMP
                        AS
                        SELECT * FROM O_MODEL_SIGNALS';                            

    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_TRADE_TEMP
                        AS
                        SELECT * FROM O_MODEL_TRADE';                            


    ------------------------------------------------------------

    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_SYMBOL';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MKT_DATA';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_PIVOTS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_EMA';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_SR';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TRENDS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_TICK_TRENDS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE D_MKT_DATA_STATS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_DATA';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_SIGNALS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE O_MODEL_TRADE';

    INSERT INTO D_SYMBOL
            SELECT SYMBOL, 'Y' IS_ACTIVE, '2015-01-01 00:00:00' CREATION_DATE
            FROM D_SYMBOL_INCLUDE;

    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function POP_D_SYMBOL_INCLUDE_STEP_2
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_SYMBOL_INCLUDE_STEP_2" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN
    EXECUTE IMMEDIATE 'INSERT INTO D_SYMBOL
        SELECT * FROM D_SYMBOL_TEMP';
    COMMIT;
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO O_MKT_DATA_TEMP
        SELECT * FROM O_MKT_DATA';
    EXECUTE IMMEDIATE 'DROP TABLE O_MKT_DATA PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE O_MKT_DATA AS 
                        SELECT * FROM O_MKT_DATA_TEMP';
    EXECUTE IMMEDIATE 'ALTER TABLE O_MKT_DATA ADD PRIMARY KEY (SYMBOL, INTERVAL, TICK_TIMESTAMP)';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_PIVOTS_TEMP
        SELECT * FROM D_MKT_PIVOTS';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_PIVOTS AS 
                        SELECT * FROM D_MKT_PIVOTS_TEMP';
    EXECUTE IMMEDIATE 'ALTER TABLE D_MKT_PIVOTS ADD PRIMARY KEY (SYMBOL, INTERVAL, PIVOT_TIMESTAMP)';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_EMA_TEMP
        SELECT * FROM D_MKT_TICK_EMA';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_EMA PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_EMA AS 
                        SELECT * FROM D_MKT_TICK_EMA_TEMP';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_SR_TEMP
        SELECT * FROM D_MKT_TICK_SR';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_SR PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_SR AS 
                        SELECT * FROM D_MKT_TICK_SR_TEMP';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TRENDS_TEMP
        SELECT * FROM D_MKT_TRENDS';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TRENDS PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TRENDS AS 
                        SELECT * FROM D_MKT_TRENDS_TEMP';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_TICK_TRENDS_TEMP
        SELECT * FROM D_MKT_TICK_TRENDS';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_TRENDS PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_TICK_TRENDS AS 
                        SELECT * FROM D_MKT_TICK_TRENDS_TEMP';
    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO D_MKT_DATA_STATS_TEMP
        SELECT * FROM D_MKT_DATA_STATS';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_DATA_STATS PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE D_MKT_DATA_STATS AS 
                        SELECT * FROM D_MKT_DATA_STATS_TEMP';

    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO O_MODEL_DATA_TEMP
        SELECT * FROM O_MODEL_DATA';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_DATA PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_DATA AS 
                        SELECT * FROM O_MODEL_DATA_TEMP';

    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO O_MODEL_SIGNALS_TEMP
        SELECT * FROM O_MODEL_SIGNALS';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_SIGNALS PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_SIGNALS AS 
                        SELECT * FROM O_MODEL_SIGNALS_TEMP';


    -------------------
    EXECUTE IMMEDIATE 'INSERT INTO O_MODEL_TRADE_TEMP
        SELECT * FROM O_MODEL_TRADE';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_TRADE PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_TRADE AS 
                        SELECT * FROM O_MODEL_TRADE_TEMP';

    --------------------

    EXECUTE IMMEDIATE 'DROP TABLE D_SYMBOL_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE O_MKT_DATA_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_PIVOTS_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_EMA_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_SR_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TRENDS_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_TICK_TRENDS_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE D_MKT_DATA_STATS_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_DATA_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_SIGNALS_TEMP PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_TRADE_TEMP PURGE';

    DELETE FROM D_SYMBOL_INCLUDE;

    COMMIT;
    RETURN 'SUCCESS';
END;    

/
--------------------------------------------------------
--  DDL for Function POP_D_SYMBOL_NOTIFICATION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_SYMBOL_NOTIFICATION" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TEMP_SPLITS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TEMP_GAPS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    EXECUTE IMMEDIATE 'CREATE TABLE TEMP_SPLITS
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.OPEN, C.CLOSE, C.CLOSE/A.OPEN SPLIT_RATE
                            FROM O_MKT_DATA A
                            JOIN D_TRADING_CALENDAR B
                            ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                            JOIN O_MKT_DATA C
                            ON A.SYMBOL = C.SYMBOL
                            AND A.INTERVAL = C.INTERVAL
                            AND C.TICK_TIMESTAMP = B.PREV_CALENDAR_DAY
                            WHERE A.INTERVAL = ''1D''
                            AND C.CLOSE/A.OPEN >= 1.9
                        )
                        SELECT SYMBOL, TICK_TIMESTAMP, ''SPLIT'' NOTIFICATION_TYPE, SPLIT_RATE NOTIFICATION_VALUE FROM D0';



    EXECUTE IMMEDIATE 'MERGE INTO D_SYMBOL_NOTIFICATION A
                        USING TEMP_SPLITS B
                        ON (A.SYMBOL = B.SYMBOL 
                            AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                            AND A.NOTIFICATION_TYPE = B.NOTIFICATION_TYPE
                            )
                        WHEN NOT MATCHED THEN
                        INSERT (A.SYMBOL, A.TICK_TIMESTAMP, A.NOTIFICATION_TYPE, A.NOTIFICATION_VALUE)
                        VALUES (B.SYMBOL, B.TICK_TIMESTAMP, B.NOTIFICATION_TYPE, B.NOTIFICATION_VALUE)';


    EXECUTE IMMEDIATE 'CREATE TABLE TEMP_GAPS
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.SYMBOL, A.TICK_TIMESTAMP, LAG(A.TICK_TIMESTAMP) OVER (PARTITION BY A.SYMBOL ORDER BY A.TICK_TIMESTAMP) PREV_TICK_TIMESTAMP
                            FROM O_MKT_DATA A
                            WHERE INTERVAL = ''1D''
                        ),
                        D1
                        AS
                        (
                            SELECT A.SYMBOL, A.TICK_TIMESTAMP, COUNT(*) - 2 DAYS_GAP
                            FROM D0 A
                            JOIN D_TRADING_CALENDAR B
                            ON B.CALENDAR_DAY BETWEEN A.PREV_TICK_TIMESTAMP AND A.TICK_TIMESTAMP
                            GROUP BY A.SYMBOL, A.TICK_TIMESTAMP
                        )
                        SELECT SYMBOL, TICK_TIMESTAMP, ''GAP'' NOTIFICATION_TYPE, DAYS_GAP NOTIFICATION_VALUE
                        FROM D1
                        WHERE DAYS_GAP > 2';


    EXECUTE IMMEDIATE 'MERGE INTO D_SYMBOL_NOTIFICATION A
                        USING TEMP_GAPS B
                        ON (A.SYMBOL = B.SYMBOL 
                            AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                            AND A.NOTIFICATION_TYPE = B.NOTIFICATION_TYPE
                            )
                        WHEN NOT MATCHED THEN
                        INSERT (A.SYMBOL, A.TICK_TIMESTAMP, A.NOTIFICATION_TYPE, A.NOTIFICATION_VALUE)
                        VALUES (B.SYMBOL, B.TICK_TIMESTAMP, B.NOTIFICATION_TYPE, B.NOTIFICATION_VALUE)';                        


    EXECUTE IMMEDIATE 'DROP TABLE TEMP_SPLITS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TEMP_GAPS PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;    


/
--------------------------------------------------------
--  DDL for Function POP_D_SYMBOL_REMOVE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_SYMBOL_REMOVE" (P_SYMBOL VARCHAR2)
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

BEGIN

    DELETE FROM D_SYMBOL WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MKT_DATA WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_PIVOTS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_TICK_EMA WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_TICK_SR WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_TRENDS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_TICK_TRENDS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM D_MKT_DATA_STATS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_DATA WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_SIGNALS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_TRADE WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_PREDICT WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_SIGNALS WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_TRADE WHERE SYMBOL = P_SYMBOL;
    DELETE FROM O_MODEL_TRADE_CHANGE WHERE SYMBOL = P_SYMBOL;

    COMMIT;
    RETURN 'SUCCESS';
END;    

/
--------------------------------------------------------
--  DDL for Function POP_D_TRADE_PERFORMANCE
--------------------------------------------------------
  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_TRADE_PERFORMANCE" (P_END_RUN_DATE VARCHAR2, P_RUN_GROUP_NAME VARCHAR2 DEFAULT 'RunGroupLive')
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE ACCOUNT_CALENDAR PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_3 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_3_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_4 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_5 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_6 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_7 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_8 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_8_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_9 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_9_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_10 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE PNL_10_1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;



    EXECUTE IMMEDIATE 'CREATE TABLE ACCOUNT_CALENDAR
                    AS
                    WITH ACCOUNTS
                    AS
                    (
                    SELECT ACCOUNT_ID, RUN_GROUP_NAME, MIN(REPORT_DATE) FIRST_DEPOSIT_DAY
                    FROM D_ACCOUNT_PNL
                    WHERE CATEGORY_NAME = ''Deposit''
                    AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''
                    GROUP BY ACCOUNT_ID, RUN_GROUP_NAME
                    )
                    SELECT DISTINCT B.*, ''Day'' PERIOD_GROUP, SUBSTR(CALENDAR_DAY, 1, 10) PERIOD_ID, SUBSTR(CALENDAR_DAY, 1, 10) PERIOD_NAME, 
                                    CALENDAR_DAY FIRST_REPORTING_DAY, 
                                    CALENDAR_DAY LAST_REPORTING_DAY
                    FROM D_TRADING_CALENDAR A
                    JOIN ACCOUNTS B
                    ON A.CALENDAR_DAY BETWEEN B.FIRST_DEPOSIT_DAY AND TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'')
                    WHERE A.CALENDAR_DAY <= '''||P_END_RUN_DATE||'''
                    AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''
                    UNION ALL
                    SELECT DISTINCT B.*, ''Week'' PERIOD_GROUP, REPORTING_YEAR_ID ||''-'' ||CALENDAR_WEEK_ID PERIOD_ID, REPORTING_YEAR_ID ||''-'' ||CALENDAR_WEEK_ID PERIOD_NAME, 
                            MIN(CALENDAR_DAY) OVER (PARTITION BY REPORTING_YEAR_ID ||''-'' ||CALENDAR_WEEK_ID, ACCOUNT_ID) FIRST_REPORTING_DAY, 
                            MAX(CALENDAR_DAY) OVER (PARTITION BY REPORTING_YEAR_ID ||''-'' ||CALENDAR_WEEK_ID, ACCOUNT_ID) LAST_REPORTING_DAY
                    FROM D_TRADING_CALENDAR A
                    JOIN ACCOUNTS B
                    ON A.CALENDAR_DAY BETWEEN B.FIRST_DEPOSIT_DAY AND TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'')
                    WHERE A.CALENDAR_DAY <= '''||P_END_RUN_DATE||'''
                    AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''
                    UNION ALL
                    SELECT DISTINCT B.*, ''Month'' PERIOD_GROUP, CALENDAR_YEAR_ID ||''-'' ||CALENDAR_MONTH_ID PERIOD_ID, CALENDAR_YEAR_ID ||''-'' ||CALENDAR_MONTH_NAME PERIOD_NAME, 
                            MIN(CALENDAR_DAY) OVER (PARTITION BY CALENDAR_YEAR_ID ||''-'' ||CALENDAR_MONTH_NAME, ACCOUNT_ID) FIRST_REPORTING_DAY, 
                            MAX(CALENDAR_DAY) OVER (PARTITION BY CALENDAR_YEAR_ID ||''-'' ||CALENDAR_MONTH_NAME, ACCOUNT_ID) LAST_REPORTING_DAY
                    FROM D_TRADING_CALENDAR A
                    JOIN ACCOUNTS B
                    ON A.CALENDAR_DAY BETWEEN B.FIRST_DEPOSIT_DAY AND TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'')
                    WHERE A.CALENDAR_DAY <= '''||P_END_RUN_DATE||'''
                    UNION ALL
                    SELECT DISTINCT B.*, ''Year'' PERIOD_GROUP, TO_CHAR(CALENDAR_YEAR_ID) PERIOD_ID, TO_CHAR(CALENDAR_YEAR_ID) PERIOD_NAME, 
                            MIN(CALENDAR_DAY) OVER (PARTITION BY CALENDAR_YEAR_ID, ACCOUNT_ID ) FIRST_REPORTING_DAY, 
                            MAX(CALENDAR_DAY) OVER (PARTITION BY CALENDAR_YEAR_ID, ACCOUNT_ID ) LAST_REPORTING_DAY
                    FROM D_TRADING_CALENDAR A
                    JOIN ACCOUNTS B
                    ON A.CALENDAR_DAY BETWEEN B.FIRST_DEPOSIT_DAY AND TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'')
                    WHERE A.CALENDAR_DAY <= '''||P_END_RUN_DATE||'''
                    AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''
                    UNION ALL
                    SELECT DISTINCT B.*, ''All'' PERIOD_GROUP, ''All'' PERIOD_ID, ''All'' PERIOD_NAME, 
                            MIN(CALENDAR_DAY) OVER (PARTITION BY ACCOUNT_ID) FIRST_REPORTING_DAY, 
                            MAX(CALENDAR_DAY) OVER (PARTITION BY ACCOUNT_ID) LAST_REPORTING_DAY
                    FROM D_TRADING_CALENDAR A
                    JOIN ACCOUNTS B
                    ON A.CALENDAR_DAY BETWEEN B.FIRST_DEPOSIT_DAY AND TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'')
                    WHERE A.CALENDAR_DAY <= '''||P_END_RUN_DATE||'''
                    AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_0
                    AS
                    WITH D0
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                            ROUND(SUM(DAILY_PROFIT)) PROFIT,
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN POSITION_SIZE END)) UTILIZED_AMOUNT ,
                            COUNT(CASE WHEN REPORT_DATE = CREATE_TRADE_TIMESTAMP THEN 1 END) NEW_TRADES,
                            -- pending and canceled trades
                            --------------------------------------------------------------------------------------
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''PENDING'' THEN SYMBOL||C.REPORT_DATE END) PENDING_TRADES,
                            COUNT(CASE WHEN TRADE_STATUS = ''CANCELED'' THEN SYMBOL||C.REPORT_DATE END) CANCELED_TRADES,

                            -- open trades
                            --------------------------------------------------------------------------------------
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN SYMBOL||CREATE_TRADE_TIMESTAMP END) OPEN_TRADES,
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN CUM_DAILY_PROFIT END)) OPEN_PROFIT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') + 1 END)) OPEN_TRADES_HOLDING_TIME,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_WIN_TRADES,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_LOSS_TRADES,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 THEN 1 END) / NULLIF(COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN 1 END), 0) OPEN_WIN_RATIO,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN R_PERCENTAGE END), 3) OPEN_R_PERCENT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' THEN R_MULTIPLE END), 2) OPEN_R_MULTIPLE,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 THEN R_MULTIPLE END), 2) OPEN_WIN_R_MULTIPLE,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 THEN R_MULTIPLE END), 2) OPEN_LOSS_R_MULTIPLE,

                            -- closed trades
                            ------------------------------------------------------------
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN 1 END) CLOSED_TRADES,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN CUM_DAILY_PROFIT END)) CLOSED_PROFIT,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_PROFIT,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_PROFIT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') + 1 END)) CLOSED_TRADES_HOLDING_TIME,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN 1 END) CLOSED_WIN_TRADES,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 THEN 1 END) CLOSED_LOSS_TRADES,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN 1 END) / NULLIF(COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN 1 END),0) CLOSED_WIN_RATIO,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN R_PERCENTAGE END), 3) CLOSED_R_PERCENT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' THEN R_MULTIPLE END), 2) CLOSED_R_MULTIPLE,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN R_MULTIPLE END), 2) CLOSED_WIN_R_MULTIPLE,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 THEN R_MULTIPLE END), 2) CLOSED_LOSS_R_MULTIPLE,
                            MAX(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN CUM_DAILY_PROFIT END) CLOSED_WIN_MAX,
                            MIN(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 THEN CUM_DAILY_PROFIT END) CLOSED_LOSS_MAX,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_AVG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_AVG,
                            -- OPEN LONG
                            ------------------------------------------------------------
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN POSITION_SIZE END)) UTILIZED_AMOUNT_LONG ,
                            COUNT(CASE WHEN REPORT_DATE = CREATE_TRADE_TIMESTAMP AND TRADE_TYPE = ''BUY'' THEN 1 END) NEW_TRADES_LONG,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_TRADES_LONG,
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) OPEN_PROFIT_LONG,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') +1 END)) OPEN_TRADES_HOLDING_TIME_LONG,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_WIN_TRADES_LONG,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_LOSS_TRADES_LONG,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN 1 END) / NULLIF(COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN 1 END), 0) OPEN_WIN_RATIO_LONG,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN R_PERCENTAGE END), 3) OPEN_R_PERCENT_LONG,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) OPEN_R_MULTIPLE_LONG,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) OPEN_WIN_R_MULTIPLE_LONG,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) OPEN_LOSS_R_MULTIPLE_LONG,
                            -- OPEN SHORT
                            ------------------------------------------------------------
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN POSITION_SIZE END)) UTILIZED_AMOUNT_SHORT ,
                            COUNT(CASE WHEN REPORT_DATE = CREATE_TRADE_TIMESTAMP AND TRADE_TYPE = ''SELL'' THEN 1 END) NEW_TRADES_SHORT,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_TRADES_SHORT,
                            ROUND(SUM(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) OPEN_PROFIT_SHORT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') +1 END)) OPEN_TRADES_HOLDING_TIME_SHORT,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_WIN_TRADES_SHORT,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN SYMBOL||ENTER_TRADE_TIMESTAMP END) OPEN_LOSS_TRADES_SHORT,
                            COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN 1 END) / NULLIF(COUNT(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN 1 END), 0) OPEN_WIN_RATIO_SHORT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN R_PERCENTAGE END), 3) OPEN_R_PERCENT_SHORT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) OPEN_R_MULTIPLE_SHORT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) OPEN_WIN_R_MULTIPLE_SHORT,
                            ROUND(AVG(CASE WHEN C.REPORT_DATE = LAST_REPORTING_DAY AND TRADE_STATUS = ''OPEN'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) OPEN_LOSS_R_MULTIPLE_SHORT,
                            -- CLOSED LONG
                            ------------------------------------------------------------
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN 1 END) CLOSED_TRADES_LONG,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) CLOSED_PROFIT_LONG,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_PROFIT_LONG,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_PROFIT_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') +1 END)) CLOSED_TRADES_HOLDING_TIME_LONG,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN 1 END) CLOSED_WIN_TRADES_LONG,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN 1 END) CLOSED_LOSS_TRADES_LONG,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN 1 END) / NULLIF(COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN 1 END),0) CLOSED_WIN_RATIO_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN R_PERCENTAGE END), 3) CLOSED_R_PERCENT_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) CLOSED_R_MULTIPLE_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) CLOSED_WIN_R_MULTIPLE_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN R_MULTIPLE END), 2) CLOSED_LOSS_R_MULTIPLE_LONG,
                            MAX(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END) CLOSED_WIN_MAX_LONG,
                            MIN(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END) CLOSED_LOSS_MAX_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_AVG_LONG,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''BUY'' THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_AVG_LONG,


                            -- CLOSED SHORT
                            ------------------------------------------------------------
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN 1 END) CLOSED_TRADES_SHORT,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) CLOSED_PROFIT_SHORT,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_PROFIT_SHORT,
                            ROUND(SUM(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_PROFIT_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN TO_DATE(REPORT_DATE, ''YYYY-MM-DD HH24:MI:SS'') - TO_DATE(ENTER_TRADE_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') +1 END)) CLOSED_TRADES_HOLDING_TIME_SHORT,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN 1 END) CLOSED_WIN_TRADES_SHORT,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN 1 END) CLOSED_LOSS_TRADES_SHORT,
                            COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN 1 END) / NULLIF(COUNT(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN 1 END),0) CLOSED_WIN_RATIO_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN R_PERCENTAGE END), 3) CLOSED_R_PERCENT_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) CLOSED_R_MULTIPLE_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) CLOSED_WIN_R_MULTIPLE_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN R_MULTIPLE END), 2) CLOSED_LOSS_R_MULTIPLE_SHORT,
                            MAX(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END) CLOSED_WIN_MAX_SHORT,
                            MIN(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END) CLOSED_LOSS_MAX_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT > 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) CLOSED_WIN_AVG_SHORT,
                            ROUND(AVG(CASE WHEN TRADE_STATUS = ''CLOSED'' AND CUM_DAILY_PROFIT < 0 AND TRADE_TYPE = ''SELL'' THEN CUM_DAILY_PROFIT END)) CLOSED_LOSS_AVG_SHORT
                        FROM ACCOUNT_CALENDAR A
                        LEFT OUTER JOIN V_ACCOUNT_TRADES_DAILY_PNL C
                        ON C.REPORT_DATE BETWEEN FIRST_REPORTING_DAY AND LEAST(LAST_REPORTING_DAY, '''||P_END_RUN_DATE||''')
                        AND A.ACCOUNT_ID = C.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                    )
                    SELECT A.*, 
                            ROUND((NVL(NEW_TRADES, 0) - NVL(CANCELED_TRADES, 0) - NVL(PENDING_TRADES, 0))/NULLIF(NEW_TRADES, 0), 3) TRADES_FILL_RATE,
                            -- EXPECTED VALUE
                            ROUND(NVL(CLOSED_WIN_AVG * CLOSED_WIN_RATIO, 0) + NVL(CLOSED_LOSS_AVG * (1-CLOSED_WIN_RATIO), 0)) CLOSED_EV,
                            ROUND(NVL(CLOSED_WIN_AVG_LONG * CLOSED_WIN_RATIO_LONG, 0) + NVL(CLOSED_LOSS_AVG_LONG * (1-CLOSED_WIN_RATIO_LONG), 0)) CLOSED_EV_LONG,
                            ROUND(NVL(CLOSED_WIN_AVG_SHORT * CLOSED_WIN_RATIO_SHORT, 0) + NVL(CLOSED_LOSS_AVG_SHORT * (1-CLOSED_WIN_RATIO_SHORT), 0)) CLOSED_EV_SHORT,

                            -- EXPECTATION
                            ROUND((NVL(CLOSED_WIN_AVG * CLOSED_WIN_RATIO, 0) + NVL(CLOSED_LOSS_AVG * (1-NVL(CLOSED_WIN_RATIO,0)), 0))/ABS(NULLIF(CLOSED_LOSS_AVG, 0)), 2) CLOSED_EXPECTATION,
                            ROUND((NVL(CLOSED_WIN_AVG_LONG * CLOSED_WIN_RATIO_LONG, 0) + NVL(CLOSED_LOSS_AVG_LONG * (1-NVL(CLOSED_WIN_RATIO_LONG,0)), 0))/ABS(NULLIF(CLOSED_LOSS_AVG_LONG, 0)), 2) CLOSED_EXPECTATION_LONG,
                            ROUND((NVL(CLOSED_WIN_AVG_SHORT * CLOSED_WIN_RATIO_SHORT, 0) + NVL(CLOSED_LOSS_AVG_SHORT * (1-NVL(CLOSED_WIN_RATIO_SHORT,0)), 0))/ABS(NULLIF(CLOSED_LOSS_AVG_SHORT, 0)), 2) CLOSED_EXPECTATION_SHORT,

                            -- PROFIT_FACTOR
                            ROUND(CLOSED_WIN_PROFIT/ABS(NULLIF(CLOSED_LOSS_PROFIT, 0)), 2) CLOSED_PROFIT_FACTOR,
                            ROUND(CLOSED_WIN_PROFIT_LONG/ABS(NULLIF(CLOSED_LOSS_PROFIT_LONG, 0)), 2) CLOSED_PROFIT_FACTOR_LONG,
                            ROUND(CLOSED_WIN_PROFIT_SHORT/ABS(NULLIF(CLOSED_LOSS_PROFIT_SHORT, 0)), 2) CLOSED_PROFIT_FACTOR_SHORT
                    FROM D0 A'
                    ;

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_1
                    AS
                    WITH D0
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                SUM(DAILY_PROFIT) PROFIT_OVERALL,
                                SUM(COMMISSION) COMMISSION_OVERALL,
                                SUM(CASE WHEN REPORT_DATE BETWEEN FIRST_REPORTING_DAY AND LAST_REPORTING_DAY THEN DAILY_PROFIT END) PROFIT_PERIOD,
                                SUM(CASE WHEN REPORT_DATE BETWEEN FIRST_REPORTING_DAY AND LAST_REPORTING_DAY THEN COMMISSION END) COMMISSION_PERIOD
                        FROM ACCOUNT_CALENDAR A
                        LEFT OUTER JOIN V_ACCOUNT_TRADES_DAILY_PNL C
                        ON REPORT_DATE <= LEAST(LAST_REPORTING_DAY, '''||P_END_RUN_DATE||''')
                        AND A.ACCOUNT_ID = C.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                    ),
                    D2
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                            SUM(CASE WHEN C.CATEGORY_NAME IN (''Deposit'', ''Withdraw'') AND C.REPORT_DATE BETWEEN FIRST_REPORTING_DAY AND LAST_REPORTING_DAY THEN C.AMOUNT END) CASH_PERIOD,
                            SUM(CASE WHEN C.CATEGORY_NAME IN (''Deposit'', ''Withdraw'') THEN C.AMOUNT END) CASH_OVERALL
                        FROM ACCOUNT_CALENDAR A
                        LEFT OUTER JOIN D_ACCOUNT_PNL C
                        ON A.LAST_REPORTING_DAY >= C.REPORT_DATE
                        AND A.ACCOUNT_ID = C.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                        AND C.CATEGORY_NAME NOT IN (''PROFIT'', ''COMM_IN'', ''COMM_OUT'')
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.FIRST_DEPOSIT_DAY, A.PERIOD_GROUP, A.PERIOD_ID, A.PERIOD_NAME, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                    ),
                    D3
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                            A.CASH_PERIOD, A.CASH_OVERALL, B.PROFIT_PERIOD, B.PROFIT_OVERALL, B.COMMISSION_PERIOD, B.COMMISSION_OVERALL,
                            NVL(B.PROFIT_OVERALL, 0) + NVL(B.COMMISSION_OVERALL, 0) + NVL(A.CASH_OVERALL, 0) CAPITAL_OVERALL,
                            LAG(NVL(B.PROFIT_OVERALL, 0) + NVL(B.COMMISSION_OVERALL, 0) + NVL(A.CASH_OVERALL, 0)) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP ORDER BY A.PERIOD_ID) PREV_CAPITAL_OVERALL
                        FROM D2 A
                        LEFT JOIN D0 B
                        ON A.ACCOUNT_ID = B.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                        AND A.PERIOD_GROUP = B.PERIOD_GROUP
                        AND A.PERIOD_ID = B.PERIOD_ID 
                    )
                    SELECT A.*, 
                        (NVL(CAPITAL_OVERALL, 0) - COALESCE(NULLIF(PREV_CAPITAL_OVERALL, 0),CASH_PERIOD, 0)) CAPITAL_INCREMENT,
                        (NVL(CAPITAL_OVERALL, 0) - COALESCE(NULLIF(PREV_CAPITAL_OVERALL, 0),CASH_PERIOD, 0))/ NULLIF(NVL(NULLIF(PREV_CAPITAL_OVERALL,0),CASH_PERIOD), 0) RETURN_RATE
                    FROM D3 A
                    order by 4 desc'
                    ;

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_2
                    AS
                    WITH D0
                    AS
                    (
                        SELECT ACCOUNT_ID, RUN_GROUP_NAME, REPORT_DATE, SUM(CUM_DAILY_PROFIT) DAILY_PROFIT
                        FROM V_ACCOUNT_TRADES_DAILY_PNL
                        WHERE EXIT_TRADE_TIMESTAMP = REPORT_DATE
                        AND RUN_GROUP_NAME = '''||P_RUN_GROUP_NAME||'''
                        GROUP BY ACCOUNT_ID, RUN_GROUP_NAME, REPORT_DATE
                    ),
                    D1
                    AS
                    (
                        SELECT A.*,
                            CASE WHEN DAILY_PROFIT >= 0 THEN 1 ELSE -1 END PROFIT_FLAG
                        FROM D0 A
                    ),
                    D2
                    AS
                    (
                        SELECT A.*,
                            CASE WHEN PROFIT_FLAG = LAG(PROFIT_FLAG) OVER (PARTITION BY ACCOUNT_ID, RUN_GROUP_NAME ORDER BY REPORT_DATE) THEN NULL ELSE REPORT_DATE END ADJ_PROFIT_FLAG
                        FROM D1 A
                    ),
                    D3
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.REPORT_DATE, PROFIT_FLAG, 
                            NVL(ADJ_PROFIT_FLAG, LAG(ADJ_PROFIT_FLAG) IGNORE NULLS OVER (PARTITION BY ACCOUNT_ID, RUN_GROUP_NAME ORDER BY REPORT_DATE)) RUNNING_PROFIT_DATE
                        FROM D2 A
                    ),
                    D4
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.REPORT_DATE, A.PROFIT_FLAG, 
                            COUNT(*) CONSEQ_PROFIT_DAYS
                        FROM D3 A 
                        LEFT JOIN D3 B
                        ON A.ACCOUNT_ID = B.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                        AND B.REPORT_DATE BETWEEN A.RUNNING_PROFIT_DATE AND A.REPORT_DATE
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.REPORT_DATE, A.PROFIT_FLAG
                    ),
                    D5
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                            MAX(CASE WHEN PROFIT_FLAG = 1 THEN CONSEQ_PROFIT_DAYS END) WIN_STREAK_TRADES,
                            MAX(CASE WHEN PROFIT_FLAG = -1 THEN CONSEQ_PROFIT_DAYS END) LOSS_STREAK_TRADES
                        FROM ACCOUNT_CALENDAR A
                        JOIN D4 B
                        ON A.ACCOUNT_ID = B.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                        AND B.REPORT_DATE BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID
                    )
                    SELECT * 
                    FROM D5';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_3
                    AS
                    WITH D0
                    AS
                    (
                        SELECT C.ACCOUNT_ID, C.RUN_GROUP_NAME, C.PERIOD_GROUP, C.PERIOD_ID, B.PERIOD_ID CHANGE_REPORTING_DAY, A.PERIOD_ID RUNNING_REPORTING_DAY,
                            ROUND((NVL(A.PROFIT_OVERALL, 0) + NVL(A.COMMISSION_OVERALL, 0) - NVL(B.PROFIT_OVERALL, 0) - NVL(B.COMMISSION_OVERALL, 0))/NULLIF(B.CAPITAL_OVERALL, 0), 4) CHANGE_RATIO
                        FROM PNL_1 A
                        JOIN PNL_1 B
                        ON A.ACCOUNT_ID = B.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                        AND A.PERIOD_GROUP = B.PERIOD_GROUP
                        AND B.PERIOD_ID < A.PERIOD_ID
                        JOIN ACCOUNT_CALENDAR C
                        ON A.ACCOUNT_ID = C.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                        AND A.PERIOD_ID || '' 00:00:00'' BETWEEN C.FIRST_REPORTING_DAY AND C.LAST_REPORTING_DAY
                        AND B.PERIOD_ID || '' 00:00:00'' BETWEEN C.FIRST_REPORTING_DAY AND C.LAST_REPORTING_DAY
                        WHERE A.PERIOD_GROUP = ''Day''
                    ),
                    D1
                    AS
                    (
                        SELECT DISTINCT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,
                            FIRST_VALUE (CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO) MAX_DRAWDOWN,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO) MAX_DRAWDOWN_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO) MAX_DRAWDOWN_LAST_DAY,
                            FIRST_VALUE (CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO DESC NULLS LAST) MAX_MARKUP,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO DESC NULLS LAST) MAX_MARKUP_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY CHANGE_RATIO DESC NULLS LAST) MAX_MARKUP_LAST_DAY
                        FROM D0 A
                    )
                    SELECT * FROM D1';


    EXECUTE IMMEDIATE 'CREATE TABLE PNL_3_1
                    AS
                    WITH MAIN_DATA
                    AS
                    (
                        SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                            MAX(CASE WHEN D.SYMBOL = ''QQQ'' THEN D.CLOSE END) QQQ_PRICE,
                            MAX(CASE WHEN D.SYMBOL = ''SPY'' THEN D.CLOSE END) SPY_PRICE,
                            MAX(CASE WHEN D.SYMBOL = ''BRK.B'' THEN D.CLOSE END) BRK_PRICE
                        FROM PNL_1 A
                        JOIN O_MKT_DATA D
                        ON D.INTERVAL = ''1D''
                        AND D.TICK_TIMESTAMP = A.LAST_REPORTING_DAY
                        AND D.SYMBOL IN (''QQQ'', ''SPY'', ''BRK.B'')
                        GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                    ),                    
                    D0
                    AS
                    (
                        SELECT C.ACCOUNT_ID, C.RUN_GROUP_NAME, C.PERIOD_GROUP, C.PERIOD_ID, B.PERIOD_ID CHANGE_REPORTING_DAY, A.PERIOD_ID RUNNING_REPORTING_DAY,
                            ROUND((A.QQQ_PRICE - B.QQQ_PRICE)/NULLIF(B.QQQ_PRICE, 0), 4) QQQ_CHANGE_RATIO,
                            ROUND((A.BRK_PRICE - B.BRK_PRICE)/NULLIF(B.BRK_PRICE, 0), 4) BRK_CHANGE_RATIO,
                            ROUND((A.SPY_PRICE - B.SPY_PRICE)/NULLIF(B.SPY_PRICE, 0), 4) SPY_CHANGE_RATIO
                        FROM MAIN_DATA A
                        JOIN MAIN_DATA B
                        ON A.ACCOUNT_ID = B.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                        AND A.PERIOD_GROUP = B.PERIOD_GROUP
                        AND B.PERIOD_ID < A.PERIOD_ID
                        JOIN ACCOUNT_CALENDAR C
                        ON A.ACCOUNT_ID = C.ACCOUNT_ID
                        AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                        AND A.PERIOD_ID || '' 00:00:00'' BETWEEN C.FIRST_REPORTING_DAY AND C.LAST_REPORTING_DAY
                        AND B.PERIOD_ID || '' 00:00:00'' BETWEEN C.FIRST_REPORTING_DAY AND C.LAST_REPORTING_DAY
                        WHERE A.PERIOD_GROUP = ''Day''
                    ),
                    D1
                    AS
                    (
                        SELECT DISTINCT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,
                            FIRST_VALUE (QQQ_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO) QQQ_MAX_DRAWDOWN,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO) QQQ_MAX_DRAWDOWN_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO) QQQ_MAX_DRAWDOWN_LAST_DAY,
                            FIRST_VALUE (QQQ_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO DESC NULLS LAST) QQQ_MAX_MARKUP,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO DESC NULLS LAST) QQQ_MAX_MARKUP_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY QQQ_CHANGE_RATIO DESC NULLS LAST) QQQ_MAX_MARKUP_LAST_DAY,

                            FIRST_VALUE (BRK_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO) BRK_MAX_DRAWDOWN,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO) BRK_MAX_DRAWDOWN_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO) BRK_MAX_DRAWDOWN_LAST_DAY,
                            FIRST_VALUE (BRK_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO DESC NULLS LAST) BRK_MAX_MARKUP,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO DESC NULLS LAST) BRK_MAX_MARKUP_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY BRK_CHANGE_RATIO DESC NULLS LAST) BRK_MAX_MARKUP_LAST_DAY,
                            ---------------
                            FIRST_VALUE (SPY_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO) SPY_MAX_DRAWDOWN,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO) SPY_MAX_DRAWDOWN_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO) SPY_MAX_DRAWDOWN_LAST_DAY,
                            FIRST_VALUE (SPY_CHANGE_RATIO) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO DESC NULLS LAST) SPY_MAX_MARKUP,
                            FIRST_VALUE (CHANGE_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO DESC NULLS LAST) SPY_MAX_MARKUP_FIRST_DAY,
                            FIRST_VALUE (RUNNING_REPORTING_DAY || '' 00:00:00'') OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY SPY_CHANGE_RATIO DESC NULLS LAST) SPY_MAX_MARKUP_LAST_DAY
                        FROM D0 A
                    )
                    SELECT * FROM D1';






    EXECUTE IMMEDIATE 'CREATE TABLE PNL_4
                    AS
                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                        COUNT(*) POSSIBLE_TRADES
                    FROM PNL_0 A
                    LEFT JOIN O_MODEL_TRADE B
                    ON B.ENTER_MODEL_TIMESTAMP BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                    GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY';



    EXECUTE IMMEDIATE 'CREATE TABLE PNL_5
                    AS
                    SELECT C.ACCOUNT_ID, C.RUN_GROUP_NAME, C.PERIOD_GROUP, C.PERIOD_ID, C.FIRST_REPORTING_DAY, C.LAST_REPORTING_DAY,
                        ROUND(SUM (A.UTILIZED_AMOUNT) / SUM(B.CAPITAL_OVERALL), 2) UTILIZED_RATIO
                    FROM PNL_0 A
                    JOIN PNL_1 B
                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                    AND A.PERIOD_ID = B.PERIOD_ID
                    AND A.PERIOD_GROUP = ''Day''
                    JOIN PNL_0 C
                    ON A.ACCOUNT_ID = C.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                    AND A.FIRST_REPORTING_DAY BETWEEN C.FIRST_REPORTING_DAY AND C.LAST_REPORTING_DAY
                    GROUP BY C.ACCOUNT_ID, C.RUN_GROUP_NAME, C.PERIOD_GROUP, C.PERIOD_ID, C.FIRST_REPORTING_DAY, C.LAST_REPORTING_DAY';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_6
                    AS
                    with d0
                    as
                    (
                        select a.account_id, a.period_group, a.period_id, a.run_group_name,
                            count(case when b.period_group = ''Day'' then 1 end ) days,
                            count(case when b.period_group = ''Week'' then 1 end ) weeks,
                            count(case when b.period_group = ''Month'' then 1 end ) months,
                            count(case when b.period_group = ''Year'' then 1 end ) years
                        from PNL_0 a
                        join PNL_0 b
                        on  a.account_id = b.account_id
                        and b.first_reporting_day between a.first_reporting_day and a.last_reporting_day
                        and a.run_group_name  = b.run_group_name
                        group by a.account_id, a.period_group, a.period_id, a.run_group_name
                    )
                    SELECT a.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,
                            case when a.period_group in (''Week'', ''Month'', ''Year'', ''All'') 
                                THEN round(power(1 + a.return_rate, 1/nullif(b.days, 0)) - 1, 4) 
                            END avg_day_return_rate,
                            case when a.period_group in (''Month'', ''Year'', ''All'') 
                                THEN round(power(1 + a.return_rate, 1/nullif(b.weeks, 0)) - 1, 4) 
                            END avg_week_return_rate,
                            case when a.period_group in (''Year'', ''All'') 
                                THEN round(power(1 + a.return_rate, 1/nullif(b.months, 0)) - 1, 4) 
                            END avg_month_return_rate,
                            case when a.period_group in (''All'') 
                                THEN round(power(1 + a.return_rate, 1/nullif(b.years, 0)) - 1, 4) 
                            END avg_year_return_rate
                    FROM PNL_1 A
                    join d0 b
                    on a.run_group_name = b.run_group_name
                    and a.period_group = b.period_group
                    and a.account_id = b.account_id
                    and a.period_id = b.period_id';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_7
                    AS
                    WITH D0
                    AS
                    (
                        SELECT A.SYMBOL, A.TICK_TIMESTAMP, NVL(C.CLOSE, A.OPEN) PREV_PRICE, A.CLOSE PRICE
                        FROM O_MKT_DATA A
                        JOIN D_TRADING_CALENDAR B
                        ON A.TICK_TIMESTAMP = B.CALENDAR_DAY
                        LEFT JOIN O_MKT_DATA C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.INTERVAL = C.INTERVAL
                        AND B.PREV_CALENDAR_DAY = C.TICK_TIMESTAMP
                        WHERE A.INTERVAL = ''1D''
                        AND A.SYMBOL IN (''QQQ'', ''SPY'', ''BRK.B'')
                    ),
                    D1
                    AS
                    (
                        SELECT DISTINCT A.ACCOUNT_ID, B.SYMBOL, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                            FIRST_VALUE (B.PREV_PRICE) OVER (PARTITION BY A.ACCOUNT_ID, B.SYMBOL, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.TICK_TIMESTAMP) START_PRICE,
                            FIRST_VALUE (B.PRICE) OVER (PARTITION BY A.ACCOUNT_ID, B.SYMBOL, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.TICK_TIMESTAMP DESC) END_PRICE
                        FROM PNL_0 A
                        LEFT JOIN D0 B
                        ON B.TICK_TIMESTAMP BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                    )
                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                        MAX(CASE WHEN A.SYMBOL = ''SPY'' THEN ROUND((END_PRICE - START_PRICE)/START_PRICE, 4) END) SPY_RETURN_RATE,
                        MAX(CASE WHEN A.SYMBOL = ''QQQ'' THEN ROUND((END_PRICE - START_PRICE)/START_PRICE, 4) END) QQQ_RETURN_RATE,
                        MAX(CASE WHEN A.SYMBOL = ''BRK.B'' THEN ROUND((END_PRICE - START_PRICE)/START_PRICE, 4) END) BRK_RETURN_RATE
                    FROM D1 A
                    GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY';

-----------------------------------------------------------------------------------------------------------------
---------- ULCER INDEX
-----------------------------------------------------------------------------------------------------------------

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_8
                                AS
                                WITH D0
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.PERIOD_ID WINDOW_PERIOD_ID,  
                                                NVL(B.PROFIT_OVERALL, 0) + NVL(B.COMMISSION_OVERALL, 0)  WINDOW_PROFIT_OVERALL,
                                                B.CAPITAL_OVERALL WINDOW_CAPITAL_OVERALL,
                                                ROW_NUMBER () OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.PERIOD_ID DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN PNL_1 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.FIRST_REPORTING_DAY >= B.FIRST_REPORTING_DAY
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.WINDOW_PROFIT_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_PROFIT,
                                        FIRST_VALUE (B.WINDOW_CAPITAL_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_CAPITAL
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 5
                                    AND B.PERIOD_RN <= 5
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((MAX_PREV_WINDOW_PROFIT - WINDOW_PROFIT_OVERALL)/MAX_PREV_WINDOW_CAPITAL*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(ROUND(ULCER_INDEX, 2)) ULCER_5_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 5
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_8_1
                                AS                                
                                WITH D0
                                AS
                                (
                                    SELECT B.SYMBOL,  A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.TICK_TIMESTAMP WINDOW_PERIOD_ID,  
                                                CLOSE PRICE,
                                                ROW_NUMBER () OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.TICK_TIMESTAMP DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN O_MKT_DATA B
                                    ON A.FIRST_REPORTING_DAY >= B.TICK_TIMESTAMP
                                    AND B.INTERVAL = ''1D''
                                    AND B.SYMBOL IN (''SPY'', ''QQQ'', ''BRK.B'')
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.PRICE) OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.PRICE DESC) PREV_PRICE
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.SYMBOL = B.SYMBOL
                                    AND A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 5
                                    AND B.PERIOD_RN <= 5
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((PREV_PRICE - PRICE)/PREV_PRICE*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(CASE WHEN B.SYMBOL = ''SPY'' THEN ROUND(ULCER_INDEX, 2) END) SPY_ULCER_5_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''QQQ'' THEN ROUND(ULCER_INDEX, 2) END) QQQ_ULCER_5_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''BRK.B'' THEN ROUND(ULCER_INDEX, 2) END) BRK_ULCER_5_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 5
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';


    EXECUTE IMMEDIATE 'CREATE TABLE PNL_9
                                AS
                                WITH D0
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.PERIOD_ID WINDOW_PERIOD_ID,  
                                                NVL(B.PROFIT_OVERALL, 0) + NVL(B.COMMISSION_OVERALL, 0)  WINDOW_PROFIT_OVERALL,
                                                B.CAPITAL_OVERALL WINDOW_CAPITAL_OVERALL,
                                                ROW_NUMBER () OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.PERIOD_ID DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN PNL_1 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.FIRST_REPORTING_DAY >= B.FIRST_REPORTING_DAY
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.WINDOW_PROFIT_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_PROFIT,
                                        FIRST_VALUE (B.WINDOW_CAPITAL_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_CAPITAL
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 10
                                    AND B.PERIOD_RN <= 10
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((MAX_PREV_WINDOW_PROFIT - WINDOW_PROFIT_OVERALL)/MAX_PREV_WINDOW_CAPITAL*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(ROUND(ULCER_INDEX, 2)) ULCER_10_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 10
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_9_1
                                AS                                
                                WITH D0
                                AS
                                (
                                    SELECT B.SYMBOL,  A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.TICK_TIMESTAMP WINDOW_PERIOD_ID,  
                                                CLOSE PRICE,
                                                ROW_NUMBER () OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.TICK_TIMESTAMP DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN O_MKT_DATA B
                                    ON A.FIRST_REPORTING_DAY >= B.TICK_TIMESTAMP
                                    AND B.INTERVAL = ''1D''
                                    AND B.SYMBOL IN (''SPY'', ''QQQ'', ''BRK.B'')
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.PRICE) OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.PRICE DESC) PREV_PRICE
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.SYMBOL = B.SYMBOL
                                    AND A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 10
                                    AND B.PERIOD_RN <= 10
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((PREV_PRICE - PRICE)/PREV_PRICE*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(CASE WHEN B.SYMBOL = ''SPY'' THEN ROUND(ULCER_INDEX, 2) END) SPY_ULCER_10_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''QQQ'' THEN ROUND(ULCER_INDEX, 2) END) QQQ_ULCER_10_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''BRK.B'' THEN ROUND(ULCER_INDEX, 2) END) BRK_ULCER_10_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 10
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';


    EXECUTE IMMEDIATE 'CREATE TABLE PNL_10
                                AS
                                WITH D0
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.PERIOD_ID WINDOW_PERIOD_ID,  
                                                NVL(B.PROFIT_OVERALL, 0) + NVL(B.COMMISSION_OVERALL, 0)  WINDOW_PROFIT_OVERALL,
                                                B.CAPITAL_OVERALL WINDOW_CAPITAL_OVERALL,
                                                ROW_NUMBER () OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.PERIOD_ID DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN PNL_1 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.FIRST_REPORTING_DAY >= B.FIRST_REPORTING_DAY
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.WINDOW_PROFIT_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_PROFIT,
                                        FIRST_VALUE (B.WINDOW_CAPITAL_OVERALL) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.WINDOW_PROFIT_OVERALL DESC) MAX_PREV_WINDOW_CAPITAL
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 20
                                    AND B.PERIOD_RN <= 20
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((MAX_PREV_WINDOW_PROFIT - WINDOW_PROFIT_OVERALL)/MAX_PREV_WINDOW_CAPITAL*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(ROUND(ULCER_INDEX, 2)) ULCER_20_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 20
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';

    EXECUTE IMMEDIATE 'CREATE TABLE PNL_10_1
                                AS                                
                                WITH D0
                                AS
                                (
                                    SELECT B.SYMBOL,  A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID,  A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                                B.TICK_TIMESTAMP WINDOW_PERIOD_ID,  
                                                CLOSE PRICE,
                                                ROW_NUMBER () OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID ORDER BY B.TICK_TIMESTAMP DESC ) PERIOD_RN
                                    FROM PNL_1 A
                                    JOIN O_MKT_DATA B
                                    ON A.FIRST_REPORTING_DAY >= B.TICK_TIMESTAMP
                                    AND B.INTERVAL = ''1D''
                                    AND B.SYMBOL IN (''SPY'', ''QQQ'', ''BRK.B'')
                                    WHERE A.PERIOD_GROUP = ''Day''
                                ),
                                D1
                                AS
                                (
                                    SELECT DISTINCT A.*,
                                        FIRST_VALUE (B.PRICE) OVER (PARTITION BY B.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, A.WINDOW_PERIOD_ID ORDER BY B.PRICE DESC) PREV_PRICE
                                    FROM D0 A
                                    JOIN D0 B
                                    ON A.SYMBOL = B.SYMBOL
                                    AND A.ACCOUNT_ID = B.ACCOUNT_ID
                                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                                    AND A.PERIOD_ID = B.PERIOD_ID
                                    AND B.WINDOW_PERIOD_ID <= A.WINDOW_PERIOD_ID
                                    WHERE A.PERIOD_RN <= 20
                                    AND B.PERIOD_RN <= 20
                                ),
                                D2
                                AS
                                (
                                    SELECT A.*, 
                                        ROUND((PREV_PRICE - PRICE)/PREV_PRICE*100, 3) WINDOW_DRAWDOWN,
                                        COUNT(*) OVER (PARTITION BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID) COUNT_WINDOW_PERIODS
                                    FROM D1 A                            
                                ),
                                D3
                                AS
                                (
                                    SELECT A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY,
                                            SQRT(AVG(POWER(WINDOW_DRAWDOWN, 2))) ULCER_INDEX
                                    FROM D2 A
                                    GROUP BY A.SYMBOL, A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, COUNT_WINDOW_PERIODS, A.FIRST_REPORTING_DAY, A.LAST_REPORTING_DAY
                                )
                                SELECT A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID, 
                                            MAX(CASE WHEN B.SYMBOL = ''SPY'' THEN ROUND(ULCER_INDEX, 2) END) SPY_ULCER_20_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''QQQ'' THEN ROUND(ULCER_INDEX, 2) END) QQQ_ULCER_20_INDEX,
                                            MAX(CASE WHEN B.SYMBOL = ''BRK.B'' THEN ROUND(ULCER_INDEX, 2) END) BRK_ULCER_20_INDEX
                                FROM PNL_1 A
                                JOIN D3 B
                                ON A.ACCOUNT_ID = B.ACCOUNT_ID
                                AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                                AND B.FIRST_REPORTING_DAY BETWEEN A.FIRST_REPORTING_DAY AND A.LAST_REPORTING_DAY
                                WHERE B.COUNT_WINDOW_PERIODS >= 20
                                GROUP BY A.ACCOUNT_ID, A.RUN_GROUP_NAME, A.PERIOD_GROUP, A.PERIOD_ID';



    EXECUTE IMMEDIATE 'DELETE D_TRADE_PERFORMANCE WHERE RUN_GROUP_NAME = '''|| P_RUN_GROUP_NAME||'''';
    EXECUTE IMMEDIATE 'INSERT INTO D_TRADE_PERFORMANCE
                    SELECT A.ACCOUNT_ID,
                            A.RUN_GROUP_NAME,
                            A.PERIOD_GROUP,
                            A.PERIOD_ID,
                            A.PERIOD_NAME,
                            A.FIRST_REPORTING_DAY,
                            A.LAST_REPORTING_DAY,
                            --------------------------
                            NVL(B.CASH_PERIOD, 0) CASH_PERIOD,
                            NVL(B.CASH_OVERALL, 0) CASH_OVERALL,
                            NVL(A.UTILIZED_AMOUNT, 0) UTILIZED_AMOUNT,
                            NVL(F.UTILIZED_RATIO, 0) UTILIZED_RATIO,
                            NVL(A.UTILIZED_AMOUNT_LONG, 0) UTILIZED_AMOUNT_LONG,
                            NVL(A.UTILIZED_AMOUNT_SHORT, 0) UTILIZED_AMOUNT_SHORT,
                            ROUND(NVL(B.PROFIT_PERIOD, 0)) PROFIT_PERIOD,
                            ROUND(NVL(B.PROFIT_OVERALL, 0)) PROFIT_OVERALL,
                            NVL(B.COMMISSION_PERIOD, 0) COMMISSION_PERIOD,
                            NVL(B.COMMISSION_OVERALL, 0) COMMISSION_OVERALL,
                            NVL(ROUND(B.CAPITAL_OVERALL), 0) CAPITAL,
                            NVL(ROUND(B.CAPITAL_INCREMENT), 0) CAPITAL_INCREMENT,
                            ROUND(NVL(B.RETURN_RATE, 0), 4) RETURN_RATE,
                            ROUND(NVL(H.SPY_RETURN_RATE, 0), 4) SPY_RETURN_RATE,
                            ROUND(NVL(H.QQQ_RETURN_RATE, 0), 4) QQQ_RETURN_RATE,
                            ROUND(NVL(H.BRK_RETURN_RATE, 0), 4) BRK_RETURN_RATE,
                            AVG_DAY_RETURN_RATE,
                            AVG_WEEK_RETURN_RATE,
                            AVG_MONTH_RETURN_RATE,
                            AVG_YEAR_RETURN_RATE,

                            ULCER_5_INDEX,
                            SPY_ULCER_5_INDEX,
                            QQQ_ULCER_5_INDEX,
                            BRK_ULCER_5_INDEX,
                            ULCER_10_INDEX,
                            SPY_ULCER_10_INDEX,
                            QQQ_ULCER_10_INDEX,
                            BRK_ULCER_10_INDEX,
                            ULCER_20_INDEX,
                            SPY_ULCER_20_INDEX,
                            QQQ_ULCER_20_INDEX,
                            BRK_ULCER_20_INDEX,

                            NVL(D.MAX_DRAWDOWN, 0) MAX_DRAWDOWN,
                            D.MAX_DRAWDOWN_FIRST_DAY,
                            D.MAX_DRAWDOWN_LAST_DAY,
                            NVL(D.MAX_MARKUP, 0) MAX_MARKUP,
                            D.MAX_MARKUP_FIRST_DAY,
                            D.MAX_MARKUP_LAST_DAY,

                            NVL(I.SPY_MAX_DRAWDOWN, 0) SPY_MAX_DRAWDOWN,
                            I.SPY_MAX_DRAWDOWN_FIRST_DAY,
                            I.SPY_MAX_DRAWDOWN_LAST_DAY,
                            NVL(I.SPY_MAX_MARKUP, 0) SPY_MAX_MARKUP,
                            I.SPY_MAX_MARKUP_FIRST_DAY,
                            I.SPY_MAX_MARKUP_LAST_DAY,

                            NVL(I.QQQ_MAX_DRAWDOWN, 0) QQQ_MAX_DRAWDOWN,
                            I.QQQ_MAX_DRAWDOWN_FIRST_DAY,
                            I.QQQ_MAX_DRAWDOWN_LAST_DAY,
                            NVL(I.QQQ_MAX_MARKUP, 0) QQQ_MAX_MARKUP,
                            I.QQQ_MAX_MARKUP_FIRST_DAY,
                            I.QQQ_MAX_MARKUP_LAST_DAY,

                            NVL(I.BRK_MAX_DRAWDOWN, 0) BRK_MAX_DRAWDOWN,
                            I.BRK_MAX_DRAWDOWN_FIRST_DAY,
                            I.BRK_MAX_DRAWDOWN_LAST_DAY,
                            NVL(I.BRK_MAX_MARKUP, 0) BRK_MAX_MARKUP,
                            I.BRK_MAX_MARKUP_FIRST_DAY,
                            I.BRK_MAX_MARKUP_LAST_DAY,

                            ---------------------------

                            NVL(E.POSSIBLE_TRADES, 0) POSSIBLE_TRADES,
                            NVL(E.POSSIBLE_TRADES, 0) - NVL(A.NEW_TRADES, 0) EXCLUDE_TRADES,
                            ROUND((NVL(E.POSSIBLE_TRADES, 0) - NVL(A.NEW_TRADES, 0))/NULLIF(E.POSSIBLE_TRADES, 0), 3) TRADES_EXCLUDE_RATE,
                            NVL(A.PENDING_TRADES, 0) PENDING_TRADES,
                            NVL(A.CANCELED_TRADES, 0) CANCELED_TRADES,
                            NVL(A.NEW_TRADES, 0) NEW_TRADES,
                            NVL(A.TRADES_FILL_RATE, 0) TRADES_FILL_RATE,
                            NVL(A.OPEN_TRADES, 0) OPEN_TRADES,
                            NVL(A.OPEN_PROFIT, 0) OPEN_PROFIT,
                            NVL(A.OPEN_TRADES_HOLDING_TIME, 0) OPEN_TRADES_HOLDING_TIME,
                            NVL(A.OPEN_WIN_TRADES, 0) OPEN_WIN_TRADES,
                            NVL(A.OPEN_LOSS_TRADES, 0) OPEN_LOSS_TRADES,
                            NVL(ROUND(A.OPEN_WIN_RATIO, 3), 0) OPEN_WIN_RATIO,
                            NVL(A.OPEN_R_PERCENT, 0) OPEN_R_PERCENT,
                            NVL(A.OPEN_R_MULTIPLE, 0) OPEN_R_MULTIPLE,
                            NVL(A.OPEN_WIN_R_MULTIPLE, 0) OPEN_WIN_R_MULTIPLE,
                            NVL(A.OPEN_LOSS_R_MULTIPLE, 0) OPEN_LOSS_R_MULTIPLE,
                            NVL(A.NEW_TRADES_LONG, 0) NEW_TRADES_LONG,
                            NVL(A.OPEN_TRADES_LONG, 0) OPEN_TRADES_LONG,
                            NVL(A.OPEN_PROFIT_LONG, 0) OPEN_PROFIT_LONG,
                            NVL(A.OPEN_TRADES_HOLDING_TIME_LONG, 0) OPEN_TRADES_HOLDING_TIME_LONG,
                            NVL(A.OPEN_WIN_TRADES_LONG, 0) OPEN_WIN_TRADES_LONG,
                            NVL(A.OPEN_LOSS_TRADES_LONG, 0) OPEN_LOSS_TRADES_LONG,
                            NVL(ROUND(A.OPEN_WIN_RATIO_LONG, 3), 0) OPEN_WIN_RATIO_LONG,
                            NVL(A.OPEN_R_PERCENT_LONG, 0) OPEN_R_PERCENT_LONG,
                            NVL(A.OPEN_R_MULTIPLE_LONG, 0) OPEN_R_MULTIPLE_LONG,
                            NVL(A.OPEN_WIN_R_MULTIPLE_LONG, 0) OPEN_WIN_R_MULTIPLE_LONG,
                            NVL(A.OPEN_LOSS_R_MULTIPLE_LONG, 0) OPEN_LOSS_R_MULTIPLE_LONG,
                            NVL(A.NEW_TRADES_SHORT, 0) NEW_TRADES_SHORT,
                            NVL(A.OPEN_TRADES_SHORT, 0) OPEN_TRADES_SHORT,
                            NVL(A.OPEN_PROFIT_SHORT, 0) OPEN_PROFIT_SHORT,
                            NVL(A.OPEN_TRADES_HOLDING_TIME_SHORT, 0) OPEN_TRADES_HOLDING_TIME_SHORT,
                            NVL(A.OPEN_WIN_TRADES_SHORT, 0) OPEN_WIN_TRADES_SHORT,
                            NVL(A.OPEN_LOSS_TRADES_SHORT, 0) OPEN_LOSS_TRADES_SHORT,
                            NVL(ROUND(A.OPEN_WIN_RATIO_SHORT), 0) OPEN_WIN_RATIO_SHORT,
                            NVL(A.OPEN_R_PERCENT_SHORT, 0) OPEN_R_PERCENT_SHORT,
                            NVL(A.OPEN_R_MULTIPLE_SHORT, 0) OPEN_R_MULTIPLE_SHORT,
                            NVL(A.OPEN_WIN_R_MULTIPLE_SHORT, 0) OPEN_WIN_R_MULTIPLE_SHORT,
                            NVL(A.OPEN_LOSS_R_MULTIPLE_SHORT, 0) OPEN_LOSS_R_MULTIPLE_SHORT,

                            NVL(A.CLOSED_TRADES, 0) CLOSED_TRADES,
                            NVL(A.CLOSED_PROFIT, 0) CLOSED_PROFIT,
                            NVL(A.CLOSED_WIN_PROFIT, 0) CLOSED_WIN_PROFIT,
                            NVL(A.CLOSED_LOSS_PROFIT, 0) CLOSED_LOSS_PROFIT,
                            NVL(A.CLOSED_TRADES_HOLDING_TIME, 0) CLOSED_TRADES_HOLDING_TIME,
                            NVL(A.CLOSED_WIN_TRADES, 0) CLOSED_WIN_TRADES,
                            NVL(A.CLOSED_LOSS_TRADES, 0) CLOSED_LOSS_TRADES,
                            NVL(ROUND(A.CLOSED_WIN_RATIO, 3), 0) CLOSED_WIN_RATIO,
                            NVL(A.CLOSED_R_PERCENT, 0) CLOSED_R_PERCENT,
                            NVL(A.CLOSED_R_MULTIPLE, 0) CLOSED_R_MULTIPLE,
                            NVL(A.CLOSED_WIN_R_MULTIPLE, 0) CLOSED_WIN_R_MULTIPLE,
                            NVL(A.CLOSED_LOSS_R_MULTIPLE, 0) CLOSED_LOSS_R_MULTIPLE,
                            NVL(A.CLOSED_WIN_MAX, 0) CLOSED_WIN_MAX,
                            NVL(A.CLOSED_LOSS_MAX, 0) CLOSED_LOSS_MAX,
                            NVL(ROUND(A.CLOSED_WIN_AVG), 0) CLOSED_WIN_AVG,
                            NVL(ROUND(A.CLOSED_LOSS_AVG), 0) CLOSED_LOSS_AVG,
                            NVL(A.CLOSED_TRADES_LONG, 0) CLOSED_TRADES_LONG,
                            NVL(A.CLOSED_PROFIT_LONG, 0) CLOSED_PROFIT_LONG,
                            NVL(A.CLOSED_WIN_PROFIT_LONG, 0) CLOSED_WIN_PROFIT_LONG,
                            NVL(A.CLOSED_LOSS_PROFIT_LONG, 0) CLOSED_LOSS_PROFIT_LONG,
                            NVL(A.CLOSED_TRADES_HOLDING_TIME_LONG, 0) CLOSED_TRADES_HOLDING_TIME_LONG,
                            NVL(A.CLOSED_WIN_TRADES_LONG, 0) CLOSED_WIN_TRADES_LONG,
                            NVL(A.CLOSED_LOSS_TRADES_LONG, 0) CLOSED_LOSS_TRADES_LONG,
                            NVL(ROUND(A.CLOSED_WIN_RATIO_LONG, 3), 0) CLOSED_WIN_RATIO_LONG,
                            NVL(A.CLOSED_R_PERCENT_LONG, 0) CLOSED_R_PERCENT_LONG,
                            NVL(A.CLOSED_R_MULTIPLE_LONG, 0) CLOSED_R_MULTIPLE_LONG,
                            NVL(A.CLOSED_WIN_R_MULTIPLE_LONG, 0) CLOSED_WIN_R_MULTIPLE_LONG,
                            NVL(A.CLOSED_LOSS_R_MULTIPLE_LONG, 0) CLOSED_LOSS_R_MULTIPLE_LONG,
                            NVL(A.CLOSED_WIN_MAX_LONG, 0) CLOSED_WIN_MAX_LONG,
                            NVL(A.CLOSED_LOSS_MAX_LONG, 0) CLOSED_LOSS_MAX_LONG,
                            NVL(A.CLOSED_WIN_AVG_LONG, 0) CLOSED_WIN_AVG_LONG,
                            NVL(A.CLOSED_LOSS_AVG_LONG, 0) CLOSED_LOSS_AVG_LONG,
                            NVL(A.CLOSED_TRADES_SHORT, 0) CLOSED_TRADES_SHORT,
                            NVL(A.CLOSED_PROFIT_SHORT, 0) CLOSED_PROFIT_SHORT,
                            NVL(ROUND(A.CLOSED_WIN_PROFIT_SHORT), 0) CLOSED_WIN_PROFIT_SHORT,
                            NVL(A.CLOSED_LOSS_PROFIT_SHORT, 0) CLOSED_LOSS_PROFIT_SHORT,
                            NVL(A.CLOSED_TRADES_HOLDING_TIME_SHORT, 0) CLOSED_TRADES_HOLDING_TIME_SHORT,
                            NVL(A.CLOSED_WIN_TRADES_SHORT, 0) CLOSED_WIN_TRADES_SHORT,
                            NVL(A.CLOSED_LOSS_TRADES_SHORT, 0) CLOSED_LOSS_TRADES_SHORT,
                            NVL(ROUND(A.CLOSED_WIN_RATIO_SHORT), 0) CLOSED_WIN_RATIO_SHORT,
                            NVL(A.CLOSED_R_PERCENT_SHORT, 0) CLOSED_R_PERCENT_SHORT,
                            NVL(A.CLOSED_R_MULTIPLE_SHORT, 0) CLOSED_R_MULTIPLE_SHORT,
                            NVL(A.CLOSED_WIN_R_MULTIPLE_SHORT, 0) CLOSED_WIN_R_MULTIPLE_SHORT,
                            NVL(A.CLOSED_LOSS_R_MULTIPLE_SHORT, 0) CLOSED_LOSS_R_MULTIPLE_SHORT,
                            NVL(A.CLOSED_WIN_MAX_SHORT, 0) CLOSED_WIN_MAX_SHORT,
                            NVL(A.CLOSED_LOSS_MAX_SHORT, 0) CLOSED_LOSS_MAX_SHORT,
                            NVL(A.CLOSED_WIN_AVG_SHORT, 0) CLOSED_WIN_AVG_SHORT,
                            NVL(A.CLOSED_LOSS_AVG_SHORT, 0) CLOSED_LOSS_AVG_SHORT,
                            NVL(ROUND(A.CLOSED_EV), 0) CLOSED_EV,
                            NVL(ROUND(A.CLOSED_EV_LONG), 0) CLOSED_EV_LONG,
                            NVL(ROUND(A.CLOSED_EV_SHORT), 0) CLOSED_EV_SHORT,
                            NVL(ROUND(A.CLOSED_EXPECTATION, 3), 0) CLOSED_EXPECTATION,
                            NVL(ROUND(A.CLOSED_EXPECTATION_LONG, 3), 0) CLOSED_EXPECTATION_LONG,
                            NVL(ROUND(A.CLOSED_EXPECTATION_SHORT, 3), 0) CLOSED_EXPECTATION_SHORT,
                            NVL(A.CLOSED_PROFIT_FACTOR, 0) CLOSED_PROFIT_FACTOR,
                            NVL(A.CLOSED_PROFIT_FACTOR_LONG, 0) CLOSED_PROFIT_FACTOR_LONG,
                            NVL(A.CLOSED_PROFIT_FACTOR_SHORT, 0) CLOSED_PROFIT_FACTOR_SHORT, 
                            ------------------------
                            NVL(C.WIN_STREAK_TRADES, 0) WIN_STREAK_TRADES,
                            NVL(C.LOSS_STREAK_TRADES, 0) LOSS_STREAK_TRADES
                            ------------------------
                    FROM PNL_0 A
                    LEFT JOIN PNL_1 B
                    ON A.ACCOUNT_ID = B.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = B.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = B.PERIOD_GROUP
                    AND A.PERIOD_ID = B.PERIOD_ID
                    LEFT JOIN PNL_2 C
                    ON A.ACCOUNT_ID = C.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = C.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = C.PERIOD_GROUP
                    AND A.PERIOD_ID = C.PERIOD_ID
                    LEFT JOIN PNL_3 D
                    ON A.ACCOUNT_ID = D.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = D.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = D.PERIOD_GROUP
                    AND A.PERIOD_ID = D.PERIOD_ID
                    LEFT JOIN PNL_4 E
                    ON A.ACCOUNT_ID = E.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = E.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = E.PERIOD_GROUP
                    AND A.PERIOD_ID = E.PERIOD_ID
                    LEFT JOIN PNL_5 F
                    ON A.ACCOUNT_ID = F.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = F.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = F.PERIOD_GROUP
                    AND A.PERIOD_ID = F.PERIOD_ID
                    LEFT JOIN PNL_6 G
                    ON A.ACCOUNT_ID = G.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = G.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = G.PERIOD_GROUP
                    AND A.PERIOD_ID = G.PERIOD_ID
                    LEFT JOIN PNL_7 H
                    ON A.ACCOUNT_ID = H.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = H.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = H.PERIOD_GROUP
                    AND A.PERIOD_ID = H.PERIOD_ID
                    LEFT JOIN PNL_3_1 I
                    ON A.ACCOUNT_ID = I.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = I.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = I.PERIOD_GROUP
                    AND A.PERIOD_ID = I.PERIOD_ID
                    LEFT JOIN PNL_8 J
                    ON A.ACCOUNT_ID = J.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = J.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = J.PERIOD_GROUP
                    AND A.PERIOD_ID = J.PERIOD_ID
                    LEFT JOIN PNL_8_1 K
                    ON A.ACCOUNT_ID = K.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = K.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = K.PERIOD_GROUP
                    AND A.PERIOD_ID = K.PERIOD_ID
                    LEFT JOIN PNL_9 L
                    ON A.ACCOUNT_ID = L.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = L.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = L.PERIOD_GROUP
                    AND A.PERIOD_ID = L.PERIOD_ID
                    LEFT JOIN PNL_9_1 M
                    ON A.ACCOUNT_ID = M.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = M.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = M.PERIOD_GROUP
                    AND A.PERIOD_ID = M.PERIOD_ID
                    LEFT JOIN PNL_10 N
                    ON A.ACCOUNT_ID = N.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = N.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = N.PERIOD_GROUP
                    AND A.PERIOD_ID = N.PERIOD_ID
                    LEFT JOIN PNL_10_1 O
                    ON A.ACCOUNT_ID = O.ACCOUNT_ID
                    AND A.RUN_GROUP_NAME = O.RUN_GROUP_NAME
                    AND A.PERIOD_GROUP = O.PERIOD_GROUP
                    AND A.PERIOD_ID = O.PERIOD_ID
                    ORDER BY 1, 2, 3, 4 DESC';

    EXECUTE IMMEDIATE 'DROP TABLE ACCOUNT_CALENDAR PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_3 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_3_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_4 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_5 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_6 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_7 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_8 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_8_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_9 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_9_1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_10 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE PNL_10_1 PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;    
/
--------------------------------------------------------
--  DDL for Function POP_D_TRADING_CALENDAR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_D_TRADING_CALENDAR" 
RETURN VARCHAR2
IS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'create table t0
            as
            WITH D0
            AS
            (
            SELECT a.CALENDAR_DAY, A.PREV_CALENDAR_DAY,
                TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'') CREATION_DATE ,
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''MON'') CALENDAR_MONTH_NAME, 
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''YYYY'') CALENDAR_YEAR_ID, 
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''IYYY'') REPORTING_YEAR_ID,
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''MM'') CALENDAR_MONTH_ID,
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') CALENDAR_DAY_NAME,
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''IW'') CALENDAR_WEEK_ID,
                TO_CHAR(TO_DATE(CALENDAR_DAY, ''YYYY-MM-DD HH24:MI:SS''), ''IW'') WEEK_NO
            FROM D_TRADING_CALENDAR a
            ),
            D1
            AS
            (
            SELECT A.*,
                CASE WHEN LAG(WEEK_NO) OVER (ORDER BY CALENDAR_DAY) = WEEK_NO THEN NULL ELSE CALENDAR_DAY END WEEK_STARTING_DAY,
                ROW_NUMBER () OVER (PARTITION BY CALENDAR_YEAR_ID, CALENDAR_MONTH_ID ORDER BY CALENDAR_DAY) MONTH_RN,
                COUNT(*) OVER (PARTITION BY CALENDAR_YEAR_ID, CALENDAR_MONTH_ID) MONTH_NUM
            FROM D0 A
            ),
            D2
            AS
            (
            SELECT A.*, NVL(WEEK_STARTING_DAY, LAG (WEEK_STARTING_DAY) IGNORE NULLS OVER (ORDER BY CALENDAR_DAY)) WEEK_CALENDAR_DAY
            FROM D1 A    
            ),
            D3
            AS
            (
            SELECT A.*, 
                ROW_NUMBER() OVER (PARTITION BY WEEK_CALENDAR_DAY ORDER BY CALENDAR_DAY) WEEK_RN,
                COUNT(*) OVER (PARTITION BY WEEK_CALENDAR_DAY) WEEK_NUM
            FROM D2 A
            )
            SELECT CALENDAR_DAY, CALENDAR_MONTH_NAME, CALENDAR_YEAR_ID, REPORTING_YEAR_ID, CALENDAR_MONTH_ID, CALENDAR_DAY_NAME, CALENDAR_WEEK_ID, 
                CASE WHEN WEEK_RN = WEEK_NUM THEN ''T'' ELSE ''P'' END CALENDAR_WEEK_STATUS,
                CASE WHEN MONTH_RN = MONTH_NUM THEN ''T'' ELSE ''P'' END CALENDAR_MONTH_STATUS
            FROM D3
            order by 1';

    EXECUTE IMMEDIATE 'create table t1
                    as
                    with d0
                    as
                    (
                        select a.calendar_day, max(b.calendar_day) prev_calendar_week
                        from t0 a
                        left join t0 b
                        on a.calendar_day > b.calendar_day
                        and b.calendar_week_status = ''T''
                        group by a.calendar_day
                    ),
                    d1
                    as
                    (
                        select a.calendar_day, min(b.calendar_day) next_calendar_week
                        from t0 a
                        left join t0 b
                        on a.calendar_day < b.calendar_day
                        and b.calendar_week_status = ''T''
                        group by a.calendar_day
                    ),
                    d2
                    as
                    (
                        select a.calendar_day, max(b.calendar_day) prev_calendar_month
                        from t0 a
                        left join t0 b
                        on a.calendar_day > b.calendar_day
                        and b.calendar_month_status = ''T''
                        group by a.calendar_day
                    ),
                    d3
                    as
                    (
                        select a.calendar_day, min(b.calendar_day) next_calendar_month
                        from t0 a
                        left join t0 b
                        on a.calendar_day < b.calendar_day
                        and b.calendar_month_status = ''T''
                        group by a.calendar_day
                    )
                    select a.calendar_day, next_calendar_week, prev_calendar_week, next_calendar_month, prev_calendar_month
                    from d1 a
                    left join d0 b
                    on a.calendar_day = b.calendar_day
                    left join d2 c
                    on a.calendar_day = c.calendar_day
                    left join d3 d
                    on a.calendar_day = d.calendar_day
                    order by 1';

    EXECUTE IMMEDIATE 'CREATE TABLE T2
                        AS
                        SELECT A.CALENDAR_DAY,  
                            B.CALENDAR_MONTH_NAME, B.CALENDAR_YEAR_ID, B.REPORTING_YEAR_ID, B.CALENDAR_MONTH_ID, B.CALENDAR_DAY_NAME, B.CALENDAR_WEEK_ID, 
                            B.CALENDAR_WEEK_STATUS, B.CALENDAR_MONTH_STATUS,
                            A.PREV_CALENDAR_DAY,
                            A.NEXT_CALENDAR_DAY,
                            C.PREV_CALENDAR_WEEK,
                            C.NEXT_CALENDAR_WEEK,
                            C.PREV_CALENDAR_MONTH,
                            C.NEXT_CALENDAR_MONTH
                        FROM D_TRADING_CALENDAR A
                        LEFT JOIN T0 B
                        ON A.CALENDAR_DAY = B.CALENDAR_DAY
                        LEFT JOIN T1 C
                        ON A.CALENDAR_DAY = C.CALENDAR_DAY';



    EXECUTE IMMEDIATE 'MERGE INTO D_TRADING_CALENDAR A
    USING T2 B
        ON (A.CALENDAR_DAY = B.CALENDAR_DAY)
        WHEN MATCHED THEN UPDATE set
        A.CALENDAR_MONTH_NAME = B.CALENDAR_MONTH_NAME, 
        A.CALENDAR_YEAR_ID = B.CALENDAR_YEAR_ID,
        A.REPORTING_YEAR_ID = B.REPORTING_YEAR_ID,
        A.CALENDAR_MONTH_ID = B.CALENDAR_MONTH_ID, 
        A.CALENDAR_DAY_NAME = B.CALENDAR_DAY_NAME,
        A.CALENDAR_WEEK_ID = B.CALENDAR_WEEK_ID,
        A.CALENDAR_WEEK_STATUS = B.CALENDAR_WEEK_STATUS,
        A.CALENDAR_MONTH_STATUS = B.CALENDAR_MONTH_STATUS,
        A.PREV_CALENDAR_WEEK = B.PREV_CALENDAR_WEEK,
        A.NEXT_CALENDAR_WEEK = B.NEXT_CALENDAR_WEEK,
        A.PREV_CALENDAR_MONTH = B.PREV_CALENDAR_MONTH,
        A.NEXT_CALENDAR_MONTH = B.NEXT_CALENDAR_MONTH'
        ;

        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
        EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';
        EXECUTE IMMEDIATE 'DROP TABLE T2 PURGE';

        COMMIT;
        RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function POP_O_MKT_DATA_INTERVAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_O_MKT_DATA_INTERVAL" (RUN_DATE VARCHAR2, is_backfill varchar2)
RETURN VARCHAR2
IS
    V_WHERE_CLAUSE VARCHAR2(100);
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TEMP_INTERVALS PURGE';
    EXCEPTION 
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TEMP_INTERVALS_1 PURGE';
    EXCEPTION 
        WHEN OTHERS THEN
            NULL;
    END;
    EXECUTE IMMEDIATE 'CREATE TABLE TEMP_INTERVALS
                        AS
                        WITH INTERVALS 
                                AS
                                ( 
                                SELECT ''1W'' INTERVAL FROM DUAL
                                UNION 
                                SELECT ''1M'' FROM DUAL
                                ),
                                D0
                                AS
                                (SELECT A.SYMBOL, B.INTERVAL
                                FROM D_SYMBOL A CROSS JOIN INTERVALS B
                                WHERE IS_ACTIVE = ''Y''
                                GROUP BY A.SYMBOL, B.INTERVAL
                                )
                                SELECT A.*, TO_CHAR(SYSDATE, ''YYYY-MM-DD HH24:MI:SS'') CREATION_DATE FROM D0 A';

        EXECUTE IMMEDIATE 'CREATE TABLE TEMP_INTERVALS_1
                            AS
                            WITH D0
                            AS
                            (
                            SELECT A.*, 
                                CASE 
                                    WHEN A.INTERVAL = ''1D'' THEN TO_CHAR(TO_DATE(MAX(TICK_TIMESTAMP), ''YYYY-MM-DD HH24:MI:SS'') - 7, ''YYYY-MM-DD HH24:MI:SS'') 
                                    WHEN A.INTERVAL = ''1W'' THEN TO_CHAR(TO_DATE(MAX(TICK_TIMESTAMP), ''YYYY-MM-DD HH24:MI:SS'') - 22, ''YYYY-MM-DD HH24:MI:SS'') 
                                    WHEN A.INTERVAL = ''1M'' THEN TO_CHAR(TO_DATE(MAX(TICK_TIMESTAMP), ''YYYY-MM-DD HH24:MI:SS'') - 32, ''YYYY-MM-DD HH24:MI:SS'') 
                                END MAX_TICK_TIMESTAMP
                            FROM TEMP_INTERVALS A
                            LEFT OUTER JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            GROUP BY A.SYMBOL, A.INTERVAL, A.CREATION_DATE
                            ),
                            D1
                            AS
                            (
                            SELECT DISTINCT A.SYMBOL, B.INTERVAL, B.CREATION_DATE,
                                CASE 
                                    WHEN B.INTERVAL = ''1D'' THEN A.TICK_TIMESTAMP
                                    WHEN B.INTERVAL = ''1W'' THEN TO_CHAR(TRUNC(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''IW''), ''YYYY-MM-DD'')||'' 00:00:00'' 
                                    WHEN B.INTERVAL = ''1M'' THEN TO_CHAR(TRUNC(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''MM''), ''YYYY-MM-DD'')||'' 00:00:00'' 
                                END FIRST_TICK_TIMESTAMP,
                                CASE 
                                    WHEN B.INTERVAL = ''1D'' THEN A.TICK_TIMESTAMP
                                    WHEN B.INTERVAL = ''1W'' THEN TO_CHAR(TRUNC(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''IW'')+6, ''YYYY-MM-DD'')||'' 00:00:00'' 
                                    WHEN B.INTERVAL = ''1M'' THEN TO_CHAR(LAST_DAY(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'')), ''YYYY-MM-DD'')||'' 00:00:00'' 
                                END LAST_TICK_TIMESTAMP
                            FROM O_MKT_DATA A
                            JOIN D0 B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.TICK_TIMESTAMP >= NVL(B.MAX_TICK_TIMESTAMP, A.TICK_TIMESTAMP)
                            WHERE A.INTERVAL = ''1D''
                            ),
                            D2
                            AS
                            (
                            SELECT DISTINCT A.SYMBOL, A.INTERVAL, B.TICK_TIMESTAMP,
                                FIRST_VALUE (OPEN) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FIRST_TICK_TIMESTAMP ORDER BY B.TICK_TIMESTAMP) OPEN,
                                LAST_VALUE (CLOSE) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FIRST_TICK_TIMESTAMP ORDER BY B.TICK_TIMESTAMP ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) CLOSE,
                                MAX(HIGH) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FIRST_TICK_TIMESTAMP ORDER BY B.TICK_TIMESTAMP  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) HIGH,
                                MIN(LOW)  OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FIRST_TICK_TIMESTAMP  ORDER BY B.TICK_TIMESTAMP  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) LOW,
                                SUM(VOLUME) OVER (PARTITION BY A.SYMBOL, A.INTERVAL, A.FIRST_TICK_TIMESTAMP ORDER BY B.TICK_TIMESTAMP  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) VOLUME,
                                A.CREATION_DATE,
                                CASE 
                                    WHEN A.INTERVAL = ''1W'' THEN C.CALENDAR_WEEK_STATUS
                                    WHEN A.INTERVAL = ''1M'' THEN C.CALENDAR_MONTH_STATUS
                                END CALENDAR_STATUS
                            FROM D1 A
                            JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND B.TICK_TIMESTAMP BETWEEN A.FIRST_TICK_TIMESTAMP AND A.LAST_TICK_TIMESTAMP
                            AND B.INTERVAL = ''1D''
                            JOIN D_TRADING_CALENDAR C
                            ON B.TICK_TIMESTAMP = C.CALENDAR_DAY
                            )
                            SELECT * FROM D2';

        V_WHERE_CLAUSE := CASE WHEN is_backfill = 'Y' THEN '1 = 1' ELSE 'TICK_TIMESTAMP = ''' || RUN_DATE || '''' END;

        EXECUTE IMMEDIATE 'DELETE FROM O_MKT_DATA 
                                WHERE (SYMBOL, INTERVAL, TICK_TIMESTAMP) IN (SELECT SYMBOL, INTERVAL, TICK_TIMESTAMP FROM TEMP_INTERVALS_1) 
                                AND INTERVAL <> ''1D''
                                AND ' || V_WHERE_CLAUSE;
        EXECUTE IMMEDIATE 'INSERT INTO O_MKT_DATA (SYMBOL, INTERVAL, TICK_TIMESTAMP, OPEN, CLOSE, HIGH, LOW, VOLUME, CALENDAR_STATUS, CREATION_DATE) 
                            SELECT SYMBOL, INTERVAL, TICK_TIMESTAMP, OPEN, CLOSE, HIGH, LOW, VOLUME, CALENDAR_STATUS, CREATION_DATE FROM TEMP_INTERVALS_1
                            WHERE ' || V_WHERE_CLAUSE;

        EXECUTE IMMEDIATE 'DROP TABLE TEMP_INTERVALS PURGE';
        EXECUTE IMMEDIATE 'DROP TABLE TEMP_INTERVALS_1 PURGE';


        COMMIT;
        RETURN 'SUCCESS';
END;


/
--------------------------------------------------------
--  DDL for Function POP_O_MODEL_1_SIGNALS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_O_MODEL_1_SIGNALS" (P_RUN_DATE VARCHAR2)
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin
    DELETE FROM O_MODEL_SIGNALS
    WHERE TICK_TIMESTAMP = P_RUN_DATE;

    EXECUTE IMMEDIATE 'INSERT INTO O_MODEL_SIGNALS
                        WITH D0
                        AS
                        (
                            select a.symbol, a.tick_timestamp, TRADE_SIGNAL, tp, sl, 
                                row_number() over (partition by a.symbol, a.tick_timestamp order by sl, tp desc) rn
                            from o_model_predict a
                            join o_model_data b
                            on a.symbol = b.symbol
                            and a.tick_timestamp = b.tick_timestamp
                            where SL = 1
                            AND TP = 2
                            and pred_value = 1
                            and modeling_level = ''L2''
                            and model_name = ''ADABOOST''
                            AND TRADE_SIGNAL = ''BUY''
                            AND A.TICK_TIMESTAMP = '''||P_RUN_DATE||'''
                        ),
                        d1
                        as
                        (
                            select a.symbol, a.tick_timestamp, A.TRADE_SIGNAL, a.tp, a.sl, B.CLOSE ENTRY_PRICE, b.close, round(b.atr, 2) atr, 
                                    round(b.close+a.tp*b.atr, 2) tp_price, 
                                    round(B.CLOSE - SL*b.atr, 2) sl_price,
                                    ''MODEL-1'' MODEL_NAME
                            from d0 a
                            join o_mkt_data b
                            on a.symbol = b.symbol
                            and a.tick_timestamp = b.tick_timestamp
                            and b.interval = ''1D''
                            where rn = 1 
                        )
                        SELECT * FROM D1';

    COMMIT;
    RETURN 'SUCCESS';
END;        


/
--------------------------------------------------------
--  DDL for Function POP_O_MODEL_DATA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_O_MODEL_DATA" (P_RUN_DATE VARCHAR2 DEFAULT '2015-01-01 00:00:00')
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE DATA_STATS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE TRENDS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE EMA PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE STATS PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE SR PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE MAIN_DATA PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    EXECUTE IMMEDIATE 'CREATE TABLE DATA_STATS
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN PREV_CLOSE_GAP_ATR END) DAY_PREV_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PREV_CLOSE_GAP_ATR END) WEEK_PREV_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PREV_CLOSE_GAP_ATR END) MONTH_PREV_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN INTERVAL_TR_RATIO END) WEEK_INTERVAL_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN INTERVAL_TICK_TR_RATIO END) WEEK_INTERVAL_TICK_TR_RATIO,        
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN INTERVAL_TR_RATIO END) MONTH_INTERVAL_TR_RATIO,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN INTERVAL_TICK_TR_RATIO END) MONTH_INTERVAL_TICK_TR_RATIO
                            FROM D_MKT_DATA_STATS
                            WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )';
    EXECUTE IMMEDIATE 'CREATE TABLE TRENDS
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND TREND_TYPE = ''SIDE'' THEN START_TREND_GAP_ATR END) DAY_SIDE_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND TREND_TYPE = ''SIDE'' THEN END_TREND_GAP_ATR END) DAY_SIDE_END_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND TREND_TYPE = ''UP'' THEN 1 
                                         WHEN INTERVAL = ''1D'' AND TREND_TYPE = ''DOWN'' THEN -1
                                         WHEN INTERVAL = ''1D'' THEN 0
                                    END) DAY_TREND_TYPE,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN START_TREND_GAP_ATR END) DAY_TREND_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN END_TREND_GAP_ATR END) DAY_TREND_END_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND TREND_TYPE = ''SIDE'' THEN START_TREND_GAP_ATR END) WEEK_SIDE_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND TREND_TYPE = ''SIDE'' THEN END_TREND_GAP_ATR END) WEEK_SIDE_END_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND TREND_TYPE = ''UP'' THEN 1 
                                         WHEN INTERVAL = ''1W'' AND TREND_TYPE = ''DOWN'' THEN -1
                                         WHEN INTERVAL = ''1W'' THEN 0
                                    END) WEEK_TREND_TYPE,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN START_TREND_GAP_ATR END) WEEK_TREND_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN END_TREND_GAP_ATR END) WEEK_TREND_END_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND TREND_TYPE = ''SIDE'' THEN START_TREND_GAP_ATR END) MONTH_SIDE_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND TREND_TYPE = ''SIDE'' THEN END_TREND_GAP_ATR END) MONTH_SIDE_END_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND TREND_TYPE = ''UP'' THEN 1 
                                         WHEN INTERVAL = ''1M'' AND TREND_TYPE = ''DOWN'' THEN -1
                                         WHEN INTERVAL = ''1M'' THEN 0
                                    END) MONTH_TREND_TYPE,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN START_TREND_GAP_ATR END) MONTH_TREND_START_TREND_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND TREND_TYPE IN (''UP'', ''DOWN'') THEN END_TREND_GAP_ATR END) MONTH_TREND_END_TREND_GAP_ATR
                            FROM D_MKT_TICK_TRENDS
                            WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )';
    EXECUTE IMMEDIATE 'CREATE TABLE SR
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) DAY_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) DAY_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) DAY_LOW_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) DAY_WEEK_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) DAY_WEEK_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) DAY_WEEK_LOW_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) DAY_MONTH_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) DAY_MONTH_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) DAY_MONTH_LOW_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) WEEK_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) WEEK_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) WEEK_LOW_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) WEEK_MONTH_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) WEEK_MONTH_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) WEEK_MONTH_LOW_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_VALUE END) MONTH_LOW_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_GAP_ATR END) MONTH_LOW_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''LOW'' THEN SR_REJECT END) MONTH_LOW_SR_REJECT,


                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) DAY_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) DAY_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1D'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) DAY_HIGH_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) DAY_WEEK_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) DAY_WEEK_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) DAY_WEEK_HIGH_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) DAY_MONTH_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) DAY_MONTH_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1D'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) DAY_MONTH_HIGH_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) WEEK_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) WEEK_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1W'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) WEEK_HIGH_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) WEEK_MONTH_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) WEEK_MONTH_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1W'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) WEEK_MONTH_HIGH_SR_REJECT,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_VALUE END) MONTH_HIGH_SR_VALUE,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_GAP_ATR END) MONTH_HIGH_SR_GAP,
                                MIN(CASE WHEN INTERVAL = ''1M'' AND SR_INTERVAL = ''1M'' AND SR_LEVEL = ''HIGH'' THEN SR_REJECT END) MONTH_HIGH_SR_REJECT
                            FROM D_MKT_TICK_SR
                            WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )';
    EXECUTE IMMEDIATE 'CREATE TABLE EMA
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA_TREND_POSITION END) DAY_EMA_TREND_POSITION,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN SLOPE_EMA12 END) DAY_SLOPE_EMA12,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN SLOPE_EMA30 END) DAY_SLOPE_EMA30,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN SLOPE_EMA50 END) DAY_SLOPE_EMA50,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN SLOPE_EMA200 END) DAY_SLOPE_EMA200,

                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_REJECT END) DAY_EMA12_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_REJECT END) DAY_EMA30_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_REJECT END) DAY_EMA50_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_REJECT END) DAY_EMA200_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_GAP_ATR END) DAY_EMA12_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_GAP_ATR END) DAY_EMA30_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_GAP_ATR END) DAY_EMA50_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_GAP_ATR END) DAY_EMA200_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_GAP_ATR END) DAY_EMA_12_30_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_GAP_ATR END) DAY_EMA_30_50_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_GAP_ATR END) DAY_EMA_50_200_GAP_ATR,

                                MAX(CASE WHEN INTERVAL = ''1D'' THEN PROJ_INTER_CLOSE12_CLOSE30 END) DAY_PROJ_INTER_CLOSE12_CLOSE30,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN PROJ_INTER_CLOSE30_CLOSE50 END) DAY_PROJ_INTER_CLOSE30_CLOSE50,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN PROJ_INTER_CLOSE50_CLOSE200 END) DAY_PROJ_INTER_CLOSE50_CLOSE200,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_T1_STATE END) DAY_CLOSE12_CLOSE30_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_T1_STATE_TICKS END) DAY_CLOSE12_CLOSE30_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR END) DAY_CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_STATE_CLOSE_HIGH_GAP_ATR END) DAY_CLOSE12_CLOSE30_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE12_CLOSE30_STATE_CLOSE_LOW_GAP_ATR END) DAY_CLOSE12_CLOSE30_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_T1_STATE END) DAY_CLOSE30_CLOSE50_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_T1_STATE_TICKS END) DAY_CLOSE30_CLOSE50_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR END) DAY_CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_STATE_CLOSE_HIGH_GAP_ATR END) DAY_CLOSE30_CLOSE50_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE30_CLOSE50_STATE_CLOSE_LOW_GAP_ATR END) DAY_CLOSE30_CLOSE50_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_T1_STATE END) DAY_CLOSE50_CLOSE200_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_T1_STATE_TICKS END) DAY_CLOSE50_CLOSE200_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR END) DAY_CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_STATE_CLOSE_HIGH_GAP_ATR END) DAY_CLOSE50_CLOSE200_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN CLOSE50_CLOSE200_STATE_CLOSE_LOW_GAP_ATR END) DAY_CLOSE50_CLOSE200_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_T1_STATE END) DAY_EMA12_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_T1_STATE_TICKS END) DAY_EMA12_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_STATE_PEAK_GAP_ATR END) DAY_EMA12_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_STATE_CLOSE_HIGH_GAP_ATR END) DAY_EMA12_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA12_STATE_CLOSE_LOW_GAP_ATR END) DAY_EMA12_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_T1_STATE END) DAY_EMA30_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_T1_STATE_TICKS END) DAY_EMA30_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_STATE_PEAK_GAP_ATR END) DAY_EMA30_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_STATE_CLOSE_HIGH_GAP_ATR END) DAY_EMA30_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA30_STATE_CLOSE_LOW_GAP_ATR END) DAY_EMA30_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_T1_STATE END) DAY_EMA50_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_T1_STATE_TICKS END) DAY_EMA50_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_STATE_PEAK_GAP_ATR END) DAY_EMA50_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_STATE_CLOSE_HIGH_GAP_ATR END) DAY_EMA50_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA50_STATE_CLOSE_LOW_GAP_ATR END) DAY_EMA50_STATE_LOW_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_T1_STATE END) DAY_EMA200_T1_STATE,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_T1_STATE_TICKS END) DAY_EMA200_T1_STATE_TICKS,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_STATE_PEAK_GAP_ATR END) DAY_EMA200_STATE_PEAK_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_STATE_CLOSE_HIGH_GAP_ATR END) DAY_EMA200_STATE_HIGH_GAP_ATR,
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN EMA200_STATE_CLOSE_LOW_GAP_ATR END) DAY_EMA200_STATE_LOW_GAP_ATR,


                                MAX(CASE WHEN INTERVAL = ''1W'' THEN EMA12_REJECT END) WEEK_EMA12_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN EMA30_REJECT END) WEEK_EMA30_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN EMA50_REJECT END) WEEK_EMA50_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN EMA200_REJECT END) WEEK_EMA200_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN EMA_TREND_POSITION END) WEEK_EMA_TREND_POSITION,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN SLOPE_EMA12 END) WEEK_SLOPE_EMA12,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN SLOPE_EMA30 END) WEEK_SLOPE_EMA30,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN SLOPE_EMA50 END) WEEK_SLOPE_EMA50,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN SLOPE_EMA200 END) WEEK_SLOPE_EMA200,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PROJ_INTER_CLOSE12_CLOSE30 END) WEEK_PROJ_INTER_CLOSE12_CLOSE30,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PROJ_INTER_CLOSE30_CLOSE50 END) WEEK_PROJ_INTER_CLOSE30_CLOSE50,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN PROJ_INTER_CLOSE50_CLOSE200 END) WEEK_PROJ_INTER_CLOSE50_CLOSE200,

                                MAX(CASE WHEN INTERVAL = ''1M'' THEN EMA12_REJECT END) MONTH_EMA12_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN EMA30_REJECT END) MONTH_EMA30_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN EMA50_REJECT END) MONTH_EMA50_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN EMA200_REJECT END) MONTH_EMA200_REJECT,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN EMA_TREND_POSITION END) MONTH_EMA_TREND_POSITION,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN SLOPE_EMA12 END) MONTH_SLOPE_EMA12,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN SLOPE_EMA30 END) MONTH_SLOPE_EMA30,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN SLOPE_EMA50 END) MONTH_SLOPE_EMA50,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN SLOPE_EMA200 END) MONTH_SLOPE_EMA200,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PROJ_INTER_CLOSE12_CLOSE30 END) MONTH_PROJ_INTER_CLOSE12_CLOSE30,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PROJ_INTER_CLOSE30_CLOSE50 END) MONTH_PROJ_INTER_CLOSE30_CLOSE50,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN PROJ_INTER_CLOSE50_CLOSE200 END) MONTH_PROJ_INTER_CLOSE50_CLOSE200              
                            FROM D_MKT_TICK_EMA
                            WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )';
    EXECUTE IMMEDIATE 'CREATE TABLE STATS
                        AS
                        (
                            SELECT SYMBOL, TICK_TIMESTAMP, 
                                MAX(CASE WHEN INTERVAL = ''1D'' THEN RSI END) DAY_RSI,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN RSI END) WEEK_RSI,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN RSI END) MONTH_RSI,

                                MAX(CASE WHEN INTERVAL = ''1D'' THEN MFI END) DAY_MFI,
                                MAX(CASE WHEN INTERVAL = ''1W'' THEN MFI END) WEEK_MFI,
                                MAX(CASE WHEN INTERVAL = ''1M'' THEN MFI END) MONTH_MFI,
                                MAX(CASE WHEN INTERVAL = ''1D'' AND SAR >= CLOSE THEN -1 
                                         WHEN INTERVAL = ''1D'' AND SAR < CLOSE THEN 1
                                         ELSE 0
                                    END) DAY_SAR,
                                MAX(CASE WHEN INTERVAL = ''1W'' AND SAR >= CLOSE THEN -1 
                                         WHEN INTERVAL = ''1W'' AND SAR < CLOSE THEN 1
                                         ELSE 0
                                    END) WEEK_SAR,
                                MAX(CASE WHEN INTERVAL = ''1M'' AND SAR >= CLOSE THEN -1 
                                         WHEN INTERVAL = ''1M'' AND SAR < CLOSE THEN 1
                                         ELSE 0
                                    END) MONTH_SAR
                            FROM O_MKT_DATA
                            WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                            GROUP BY SYMBOL, TICK_TIMESTAMP
                        )';
    EXECUTE IMMEDIATE 'CREATE TABLE MAIN_DATA
                        AS
                        (
                            SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.ATR,
                                CASE 
                                    WHEN TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') = ''MON'' THEN 1
                                    WHEN TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') = ''TUE'' THEN 2
                                    WHEN TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') = ''WED'' THEN 3
                                    WHEN TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') = ''THU'' THEN 4
                                    WHEN TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS''), ''DY'') = ''FRI'' THEN 5        
                                END DAY_WEEK_ID,
                                SUBSTR(A.TICK_TIMESTAMP, 9, 2) DAY_MONTH_ID,
                                Z.CALENDAR_WEEK_ID WEEK_ID,
                                Z.CALENDAR_MONTH_ID MONTH_ID
                            FROM O_MKT_DATA A
                            JOIN D_TRADING_CALENDAR Z
                            ON A.TICK_TIMESTAMP = Z.CALENDAR_DAY
                            WHERE A.INTERVAL = ''1D''
                            AND A.TICK_TIMESTAMP >= '''||P_RUN_DATE||'''
                        )';

    EXECUTE IMMEDIATE 'CREATE TABLE T0
                        AS
                        SELECT A.SYMBOL,
                                A.TICK_TIMESTAMP,
                                A.ATR,
                                A.DAY_WEEK_ID,
                                A.DAY_MONTH_ID,
                                A.WEEK_ID,
                                A.MONTH_ID,
                                B.DAY_PREV_GAP_ATR,
                                B.WEEK_PREV_GAP_ATR,
                                B.MONTH_PREV_GAP_ATR,
                                B.WEEK_INTERVAL_TR_RATIO,
                                B.WEEK_INTERVAL_TICK_TR_RATIO,
                                B.MONTH_INTERVAL_TR_RATIO,
                                B.MONTH_INTERVAL_TICK_TR_RATIO,
                                C.DAY_SIDE_START_TREND_GAP_ATR,
                            C.DAY_SIDE_END_TREND_GAP_ATR,
                            C.DAY_TREND_TYPE,
                            C.DAY_TREND_START_TREND_GAP_ATR,
                            C.DAY_TREND_END_TREND_GAP_ATR,
                            C.WEEK_SIDE_START_TREND_GAP_ATR,
                            C.WEEK_SIDE_END_TREND_GAP_ATR,
                            C.WEEK_TREND_TYPE,
                            C.WEEK_TREND_START_TREND_GAP_ATR,
                            C.WEEK_TREND_END_TREND_GAP_ATR,
                            C.MONTH_SIDE_START_TREND_GAP_ATR,
                            C.MONTH_SIDE_END_TREND_GAP_ATR,
                            C.MONTH_TREND_TYPE,
                            C.MONTH_TREND_START_TREND_GAP_ATR,
                            C.MONTH_TREND_END_TREND_GAP_ATR,
                            D.DAY_LOW_SR_VALUE,
                            D.DAY_LOW_SR_GAP,
                            D.DAY_LOW_SR_REJECT,
                            D.DAY_WEEK_LOW_SR_VALUE,
                            D.DAY_WEEK_LOW_SR_GAP,
                            D.DAY_WEEK_LOW_SR_REJECT,
                            D.DAY_MONTH_LOW_SR_VALUE,
                            D.DAY_MONTH_LOW_SR_GAP,
                            D.DAY_MONTH_LOW_SR_REJECT,
                            D.WEEK_LOW_SR_VALUE,
                            D.WEEK_LOW_SR_GAP,
                            D.WEEK_LOW_SR_REJECT,
                            D.WEEK_MONTH_LOW_SR_VALUE,
                            D.WEEK_MONTH_LOW_SR_GAP,
                            D.WEEK_MONTH_LOW_SR_REJECT,
                            D.MONTH_LOW_SR_VALUE,
                            D.MONTH_LOW_SR_GAP,
                            D.MONTH_LOW_SR_REJECT,
                            D.DAY_HIGH_SR_VALUE,
                            D.DAY_HIGH_SR_GAP,
                            D.DAY_HIGH_SR_REJECT,
                            D.DAY_WEEK_HIGH_SR_VALUE,
                            D.DAY_WEEK_HIGH_SR_GAP,
                            D.DAY_WEEK_HIGH_SR_REJECT,
                            D.DAY_MONTH_HIGH_SR_VALUE,
                            D.DAY_MONTH_HIGH_SR_GAP,
                            D.DAY_MONTH_HIGH_SR_REJECT,
                            D.WEEK_HIGH_SR_VALUE,
                            D.WEEK_HIGH_SR_GAP,
                            D.WEEK_HIGH_SR_REJECT,
                            D.WEEK_MONTH_HIGH_SR_VALUE,
                            D.WEEK_MONTH_HIGH_SR_GAP,
                            D.WEEK_MONTH_HIGH_SR_REJECT,
                            D.MONTH_HIGH_SR_VALUE,
                            D.MONTH_HIGH_SR_GAP,
                            D.MONTH_HIGH_SR_REJECT,
                            E.DAY_EMA_TREND_POSITION,
                            E.DAY_SLOPE_EMA12,
                            E.DAY_SLOPE_EMA30,
                            E.DAY_SLOPE_EMA50,
                            E.DAY_SLOPE_EMA200,
                            E.DAY_EMA12_REJECT,
                            E.DAY_EMA30_REJECT,
                            E.DAY_EMA50_REJECT,
                            E.DAY_EMA200_REJECT,
                            E.DAY_EMA12_GAP_ATR,
                            E.DAY_EMA30_GAP_ATR,
                            E.DAY_EMA50_GAP_ATR,
                            E.DAY_EMA200_GAP_ATR,
                            E.DAY_EMA_12_30_GAP_ATR,
                            E.DAY_EMA_30_50_GAP_ATR,
                            E.DAY_EMA_50_200_GAP_ATR,
                            E.DAY_PROJ_INTER_CLOSE12_CLOSE30,
                            E.DAY_PROJ_INTER_CLOSE30_CLOSE50,
                            E.DAY_PROJ_INTER_CLOSE50_CLOSE200,
                            E.DAY_CLOSE12_CLOSE30_T1_STATE,
                            E.DAY_CLOSE12_CLOSE30_T1_STATE_TICKS,
                            E.DAY_CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR,
                            E.DAY_CLOSE12_CLOSE30_STATE_HIGH_GAP_ATR,
                            E.DAY_CLOSE12_CLOSE30_STATE_LOW_GAP_ATR,
                            E.DAY_CLOSE30_CLOSE50_T1_STATE,
                            E.DAY_CLOSE30_CLOSE50_T1_STATE_TICKS,
                            E.DAY_CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR,
                            E.DAY_CLOSE30_CLOSE50_STATE_HIGH_GAP_ATR,
                            E.DAY_CLOSE30_CLOSE50_STATE_LOW_GAP_ATR,
                            E.DAY_CLOSE50_CLOSE200_T1_STATE,
                            E.DAY_CLOSE50_CLOSE200_T1_STATE_TICKS,
                            E.DAY_CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR,
                            E.DAY_CLOSE50_CLOSE200_STATE_HIGH_GAP_ATR,
                            E.DAY_CLOSE50_CLOSE200_STATE_LOW_GAP_ATR,
                            E.DAY_EMA12_T1_STATE,
                            E.DAY_EMA12_T1_STATE_TICKS,
                            E.DAY_EMA12_STATE_PEAK_GAP_ATR,
                            E.DAY_EMA12_STATE_HIGH_GAP_ATR,
                            E.DAY_EMA12_STATE_LOW_GAP_ATR,
                            E.DAY_EMA30_T1_STATE,
                            E.DAY_EMA30_T1_STATE_TICKS,
                            E.DAY_EMA30_STATE_PEAK_GAP_ATR,
                            E.DAY_EMA30_STATE_HIGH_GAP_ATR,
                            E.DAY_EMA30_STATE_LOW_GAP_ATR,
                            E.DAY_EMA50_T1_STATE,
                            E.DAY_EMA50_T1_STATE_TICKS,
                            E.DAY_EMA50_STATE_PEAK_GAP_ATR,
                            E.DAY_EMA50_STATE_HIGH_GAP_ATR,
                            E.DAY_EMA50_STATE_LOW_GAP_ATR,
                            E.DAY_EMA200_T1_STATE,
                            E.DAY_EMA200_T1_STATE_TICKS,
                            E.DAY_EMA200_STATE_PEAK_GAP_ATR,
                            E.DAY_EMA200_STATE_HIGH_GAP_ATR,
                            E.DAY_EMA200_STATE_LOW_GAP_ATR,
                            E.WEEK_EMA12_REJECT,
                            E.WEEK_EMA30_REJECT,
                            E.WEEK_EMA50_REJECT,
                            E.WEEK_EMA200_REJECT,
                            E.WEEK_EMA_TREND_POSITION,
                            E.WEEK_SLOPE_EMA12,
                            E.WEEK_SLOPE_EMA30,
                            E.WEEK_SLOPE_EMA50,
                            E.WEEK_SLOPE_EMA200,
                            E.WEEK_PROJ_INTER_CLOSE12_CLOSE30,
                            E.WEEK_PROJ_INTER_CLOSE30_CLOSE50,
                            E.WEEK_PROJ_INTER_CLOSE50_CLOSE200,
                            E.MONTH_EMA12_REJECT,
                            E.MONTH_EMA30_REJECT,
                            E.MONTH_EMA50_REJECT,
                            E.MONTH_EMA200_REJECT,
                            E.MONTH_EMA_TREND_POSITION,
                            E.MONTH_SLOPE_EMA12,
                            E.MONTH_SLOPE_EMA30,
                            E.MONTH_SLOPE_EMA50,
                            E.MONTH_SLOPE_EMA200,
                            E.MONTH_PROJ_INTER_CLOSE12_CLOSE30,
                            E.MONTH_PROJ_INTER_CLOSE30_CLOSE50,
                            E.MONTH_PROJ_INTER_CLOSE50_CLOSE200,
                            F.DAY_RSI,
                            F.WEEK_RSI,
                            F.MONTH_RSI,
                            F.DAY_MFI,
                            F.WEEK_MFI,
                            F.MONTH_MFI,
                            F.DAY_SAR,
                            F.WEEK_SAR,
                            F.MONTH_SAR,
                            G.BUY_TP_1_SL_1,
                            G.BUY_TP_2_SL_1,
                            G.BUY_TP_3_SL_1,
                            G.BUY_TP_4_SL_1,
                            G.BUY_TP_5_SL_1,
                            G.BUY_TP_6_SL_1,
                            G.BUY_TP_7_SL_1,
                            G.BUY_TP_8_SL_1,
                            G.BUY_TP_9_SL_1,
                            G.BUY_TP_10_SL_1,
                            G.BUY_TP_11_SL_1,
                            G.BUY_TP_12_SL_1,
                            G.BUY_TP_1_SL_2,
                            G.BUY_TP_2_SL_2,
                            G.BUY_TP_3_SL_2,
                            G.BUY_TP_4_SL_2,
                            G.BUY_TP_5_SL_2,
                            G.BUY_TP_6_SL_2,
                            G.BUY_TP_7_SL_2,
                            G.BUY_TP_8_SL_2,
                            G.BUY_TP_9_SL_2,
                            G.BUY_TP_10_SL_2,
                            G.BUY_TP_11_SL_2,
                            G.BUY_TP_12_SL_2,
                            G.BUY_TP_1_SL_3,
                            G.BUY_TP_2_SL_3,
                            G.BUY_TP_3_SL_3,
                            G.BUY_TP_4_SL_3,
                            G.BUY_TP_5_SL_3,
                            G.BUY_TP_6_SL_3,
                            G.BUY_TP_7_SL_3,
                            G.BUY_TP_8_SL_3,
                            G.BUY_TP_9_SL_3,
                            G.BUY_TP_10_SL_3,
                            G.BUY_TP_11_SL_3,
                            G.BUY_TP_12_SL_3,
                            G.BUY_TP_1_SL_4,
                            G.BUY_TP_2_SL_4,
                            G.BUY_TP_3_SL_4,
                            G.BUY_TP_4_SL_4,
                            G.BUY_TP_5_SL_4,
                            G.BUY_TP_6_SL_4,
                            G.BUY_TP_7_SL_4,
                            G.BUY_TP_8_SL_4,
                            G.BUY_TP_9_SL_4,
                            G.BUY_TP_10_SL_4,
                            G.BUY_TP_11_SL_4,
                            G.BUY_TP_12_SL_4,
                            G.BUY_TP_1_SL_5,
                            G.BUY_TP_2_SL_5,
                            G.BUY_TP_3_SL_5,
                            G.BUY_TP_4_SL_5,
                            G.BUY_TP_5_SL_5,
                            G.BUY_TP_6_SL_5,
                            G.BUY_TP_7_SL_5,
                            G.BUY_TP_8_SL_5,
                            G.BUY_TP_9_SL_5,
                            G.BUY_TP_10_SL_5,
                            G.BUY_TP_11_SL_5,
                            G.BUY_TP_12_SL_5,
                            G.BUY_TP_1_SL_6,
                            G.BUY_TP_2_SL_6,
                            G.BUY_TP_3_SL_6,
                            G.BUY_TP_4_SL_6,
                            G.BUY_TP_5_SL_6,
                            G.BUY_TP_6_SL_6,
                            G.BUY_TP_7_SL_6,
                            G.BUY_TP_8_SL_6,
                            G.BUY_TP_9_SL_6,
                            G.BUY_TP_10_SL_6,
                            G.BUY_TP_11_SL_6,
                            G.BUY_TP_12_SL_6,
                            G.BUY_TP_1_SL_7,
                            G.BUY_TP_2_SL_7,
                            G.BUY_TP_3_SL_7,
                            G.BUY_TP_4_SL_7,
                            G.BUY_TP_5_SL_7,
                            G.BUY_TP_6_SL_7,
                            G.BUY_TP_7_SL_7,
                            G.BUY_TP_8_SL_7,
                            G.BUY_TP_9_SL_7,
                            G.BUY_TP_10_SL_7,
                            G.BUY_TP_11_SL_7,
                            G.BUY_TP_12_SL_7,
                            G.BUY_TP_1_SL_8,
                            G.BUY_TP_2_SL_8,
                            G.BUY_TP_3_SL_8,
                            G.BUY_TP_4_SL_8,
                            G.BUY_TP_5_SL_8,
                            G.BUY_TP_6_SL_8,
                            G.BUY_TP_7_SL_8,
                            G.BUY_TP_8_SL_8,
                            G.BUY_TP_9_SL_8,
                            G.BUY_TP_10_SL_8,
                            G.BUY_TP_11_SL_8,
                            G.BUY_TP_12_SL_8,
                            G.BUY_TP_1_SL_9,
                            G.BUY_TP_2_SL_9,
                            G.BUY_TP_3_SL_9,
                            G.BUY_TP_4_SL_9,
                            G.BUY_TP_5_SL_9,
                            G.BUY_TP_6_SL_9,
                            G.BUY_TP_7_SL_9,
                            G.BUY_TP_8_SL_9,
                            G.BUY_TP_9_SL_9,
                            G.BUY_TP_10_SL_9,
                            G.BUY_TP_11_SL_9,
                            G.BUY_TP_12_SL_9,
                            G.BUY_TP_1_SL_10,
                            G.BUY_TP_2_SL_10,
                            G.BUY_TP_3_SL_10,
                            G.BUY_TP_4_SL_10,
                            G.BUY_TP_5_SL_10,
                            G.BUY_TP_6_SL_10,
                            G.BUY_TP_7_SL_10,
                            G.BUY_TP_8_SL_10,
                            G.BUY_TP_9_SL_10,
                            G.BUY_TP_10_SL_10,
                            G.BUY_TP_11_SL_10,
                            G.BUY_TP_12_SL_10,
                            G.BUY_TP_1_SL_11,
                            G.BUY_TP_2_SL_11,
                            G.BUY_TP_3_SL_11,
                            G.BUY_TP_4_SL_11,
                            G.BUY_TP_5_SL_11,
                            G.BUY_TP_6_SL_11,
                            G.BUY_TP_7_SL_11,
                            G.BUY_TP_8_SL_11,
                            G.BUY_TP_9_SL_11,
                            G.BUY_TP_10_SL_11,
                            G.BUY_TP_11_SL_11,
                            G.BUY_TP_12_SL_11,
                            G.BUY_TP_1_SL_12,
                            G.BUY_TP_2_SL_12,
                            G.BUY_TP_3_SL_12,
                            G.BUY_TP_4_SL_12,
                            G.BUY_TP_5_SL_12,
                            G.BUY_TP_6_SL_12,
                            G.BUY_TP_7_SL_12,
                            G.BUY_TP_8_SL_12,
                            G.BUY_TP_9_SL_12,
                            G.BUY_TP_10_SL_12,
                            G.BUY_TP_11_SL_12,
                            G.BUY_TP_12_SL_12,
                            G.SELL_TP_1_SL_1,
                            G.SELL_TP_2_SL_1,
                            G.SELL_TP_3_SL_1,
                            G.SELL_TP_4_SL_1,
                            G.SELL_TP_5_SL_1,
                            G.SELL_TP_6_SL_1,
                            G.SELL_TP_7_SL_1,
                            G.SELL_TP_8_SL_1,
                            G.SELL_TP_9_SL_1,
                            G.SELL_TP_10_SL_1,
                            G.SELL_TP_11_SL_1,
                            G.SELL_TP_12_SL_1,
                            G.SELL_TP_1_SL_2,
                            G.SELL_TP_2_SL_2,
                            G.SELL_TP_3_SL_2,
                            G.SELL_TP_4_SL_2,
                            G.SELL_TP_5_SL_2,
                            G.SELL_TP_6_SL_2,
                            G.SELL_TP_7_SL_2,
                            G.SELL_TP_8_SL_2,
                            G.SELL_TP_9_SL_2,
                            G.SELL_TP_10_SL_2,
                            G.SELL_TP_11_SL_2,
                            G.SELL_TP_12_SL_2,
                            G.SELL_TP_1_SL_3,
                            G.SELL_TP_2_SL_3,
                            G.SELL_TP_3_SL_3,
                            G.SELL_TP_4_SL_3,
                            G.SELL_TP_5_SL_3,
                            G.SELL_TP_6_SL_3,
                            G.SELL_TP_7_SL_3,
                            G.SELL_TP_8_SL_3,
                            G.SELL_TP_9_SL_3,
                            G.SELL_TP_10_SL_3,
                            G.SELL_TP_11_SL_3,
                            G.SELL_TP_12_SL_3,
                            G.SELL_TP_1_SL_4,
                            G.SELL_TP_2_SL_4,
                            G.SELL_TP_3_SL_4,
                            G.SELL_TP_4_SL_4,
                            G.SELL_TP_5_SL_4,
                            G.SELL_TP_6_SL_4,
                            G.SELL_TP_7_SL_4,
                            G.SELL_TP_8_SL_4,
                            G.SELL_TP_9_SL_4,
                            G.SELL_TP_10_SL_4,
                            G.SELL_TP_11_SL_4,
                            G.SELL_TP_12_SL_4,
                            G.SELL_TP_1_SL_5,
                            G.SELL_TP_2_SL_5,
                            G.SELL_TP_3_SL_5,
                            G.SELL_TP_4_SL_5,
                            G.SELL_TP_5_SL_5,
                            G.SELL_TP_6_SL_5,
                            G.SELL_TP_7_SL_5,
                            G.SELL_TP_8_SL_5,
                            G.SELL_TP_9_SL_5,
                            G.SELL_TP_10_SL_5,
                            G.SELL_TP_11_SL_5,
                            G.SELL_TP_12_SL_5,
                            G.SELL_TP_1_SL_6,
                            G.SELL_TP_2_SL_6,
                            G.SELL_TP_3_SL_6,
                            G.SELL_TP_4_SL_6,
                            G.SELL_TP_5_SL_6,
                            G.SELL_TP_6_SL_6,
                            G.SELL_TP_7_SL_6,
                            G.SELL_TP_8_SL_6,
                            G.SELL_TP_9_SL_6,
                            G.SELL_TP_10_SL_6,
                            G.SELL_TP_11_SL_6,
                            G.SELL_TP_12_SL_6,
                            G.SELL_TP_1_SL_7,
                            G.SELL_TP_2_SL_7,
                            G.SELL_TP_3_SL_7,
                            G.SELL_TP_4_SL_7,
                            G.SELL_TP_5_SL_7,
                            G.SELL_TP_6_SL_7,
                            G.SELL_TP_7_SL_7,
                            G.SELL_TP_8_SL_7,
                            G.SELL_TP_9_SL_7,
                            G.SELL_TP_10_SL_7,
                            G.SELL_TP_11_SL_7,
                            G.SELL_TP_12_SL_7,
                            G.SELL_TP_1_SL_8,
                            G.SELL_TP_2_SL_8,
                            G.SELL_TP_3_SL_8,
                            G.SELL_TP_4_SL_8,
                            G.SELL_TP_5_SL_8,
                            G.SELL_TP_6_SL_8,
                            G.SELL_TP_7_SL_8,
                            G.SELL_TP_8_SL_8,
                            G.SELL_TP_9_SL_8,
                            G.SELL_TP_10_SL_8,
                            G.SELL_TP_11_SL_8,
                            G.SELL_TP_12_SL_8,
                            G.SELL_TP_1_SL_9,
                            G.SELL_TP_2_SL_9,
                            G.SELL_TP_3_SL_9,
                            G.SELL_TP_4_SL_9,
                            G.SELL_TP_5_SL_9,
                            G.SELL_TP_6_SL_9,
                            G.SELL_TP_7_SL_9,
                            G.SELL_TP_8_SL_9,
                            G.SELL_TP_9_SL_9,
                            G.SELL_TP_10_SL_9,
                            G.SELL_TP_11_SL_9,
                            G.SELL_TP_12_SL_9,
                            G.SELL_TP_1_SL_10,
                            G.SELL_TP_2_SL_10,
                            G.SELL_TP_3_SL_10,
                            G.SELL_TP_4_SL_10,
                            G.SELL_TP_5_SL_10,
                            G.SELL_TP_6_SL_10,
                            G.SELL_TP_7_SL_10,
                            G.SELL_TP_8_SL_10,
                            G.SELL_TP_9_SL_10,
                            G.SELL_TP_10_SL_10,
                            G.SELL_TP_11_SL_10,
                            G.SELL_TP_12_SL_10,
                            G.SELL_TP_1_SL_11,
                            G.SELL_TP_2_SL_11,
                            G.SELL_TP_3_SL_11,
                            G.SELL_TP_4_SL_11,
                            G.SELL_TP_5_SL_11,
                            G.SELL_TP_6_SL_11,
                            G.SELL_TP_7_SL_11,
                            G.SELL_TP_8_SL_11,
                            G.SELL_TP_9_SL_11,
                            G.SELL_TP_10_SL_11,
                            G.SELL_TP_11_SL_11,
                            G.SELL_TP_12_SL_11,
                            G.SELL_TP_1_SL_12,
                            G.SELL_TP_2_SL_12,
                            G.SELL_TP_3_SL_12,
                            G.SELL_TP_4_SL_12,
                            G.SELL_TP_5_SL_12,
                            G.SELL_TP_6_SL_12,
                            G.SELL_TP_7_SL_12,
                            G.SELL_TP_8_SL_12,
                            G.SELL_TP_9_SL_12,
                            G.SELL_TP_10_SL_12,
                            G.SELL_TP_11_SL_12,
                            G.SELL_TP_12_SL_12
                        FROM MAIN_DATA A
                        JOIN DATA_STATS B
                        ON A.SYMBOL = B.SYMBOL
                        AND A.TICK_TIMESTAMP = B.TICK_TIMESTAMP
                        JOIN TRENDS C
                        ON A.SYMBOL = C.SYMBOL
                        AND A.TICK_TIMESTAMP = C.TICK_TIMESTAMP
                        JOIN SR D
                        ON A.SYMBOL = D.SYMBOL
                        AND A.TICK_TIMESTAMP = D.TICK_TIMESTAMP
                        JOIN EMA E
                        ON A.SYMBOL = E.SYMBOL
                        AND A.TICK_TIMESTAMP = E.TICK_TIMESTAMP
                        JOIN STATS F
                        ON A.SYMBOL = F.SYMBOL
                        AND A.TICK_TIMESTAMP = F.TICK_TIMESTAMP
                        LEFT JOIN O_MODEL_SL_TP G
                        ON A.SYMBOL = G.SYMBOL
                        AND A.TICK_TIMESTAMP = G.TICK_TIMESTAMP
                        ';

    EXECUTE IMMEDIATE 'DELETE O_MODEL_DATA WHERE TICK_TIMESTAMP >= '''||P_RUN_DATE||'''';


    EXECUTE IMMEDIATE 'INSERT INTO O_MODEL_DATA
                        select
                                SYMBOL,
                                TICK_TIMESTAMP,
                                DAY_WEEK_ID,
                                DAY_MONTH_ID,
                                WEEK_ID,
                                MONTH_ID,
                                DAY_PREV_GAP_ATR,
                                WEEK_PREV_GAP_ATR,
                                MONTH_PREV_GAP_ATR,
                                WEEK_INTERVAL_TR_RATIO,
                                WEEK_INTERVAL_TICK_TR_RATIO,
                                MONTH_INTERVAL_TR_RATIO,
                                MONTH_INTERVAL_TICK_TR_RATIO,
                                DAY_SIDE_START_TREND_GAP_ATR,
                                DAY_SIDE_END_TREND_GAP_ATR,
                                DAY_TREND_TYPE,
                                DAY_TREND_START_TREND_GAP_ATR,
                                DAY_TREND_END_TREND_GAP_ATR,
                                WEEK_SIDE_START_TREND_GAP_ATR,
                                WEEK_SIDE_END_TREND_GAP_ATR,
                                WEEK_TREND_TYPE,
                                WEEK_TREND_START_TREND_GAP_ATR,
                                WEEK_TREND_END_TREND_GAP_ATR,

                                DAY_LOW_SR_VALUE,
                                NVL(DAY_LOW_SR_GAP, 1000) DAY_LOW_SR_GAP,
                                NVL(DAY_LOW_SR_REJECT, 0) DAY_LOW_SR_REJECT,
                                DAY_WEEK_LOW_SR_VALUE,
                                NVL(DAY_WEEK_LOW_SR_GAP, 1000) DAY_WEEK_LOW_SR_GAP,
                                NVL(DAY_WEEK_LOW_SR_REJECT, 0) DAY_WEEK_LOW_SR_REJECT,
                                DAY_MONTH_LOW_SR_VALUE,
                                NVL(DAY_MONTH_LOW_SR_GAP, 1000) DAY_MONTH_LOW_SR_GAP,
                                NVL(DAY_MONTH_LOW_SR_REJECT, 0) DAY_MONTH_LOW_SR_REJECT,
                                WEEK_LOW_SR_VALUE,
                                NVL(WEEK_LOW_SR_GAP, 1000) WEEK_LOW_SR_GAP,
                                NVL(WEEK_LOW_SR_REJECT, 0) WEEK_LOW_SR_REJECT,
                                WEEK_MONTH_LOW_SR_VALUE,
                                NVL(WEEK_MONTH_LOW_SR_GAP, 1000) WEEK_MONTH_LOW_SR_GAP,
                                NVL(WEEK_MONTH_LOW_SR_REJECT, 0) WEEK_MONTH_LOW_SR_REJECT,
                                MONTH_LOW_SR_VALUE,
                                NVL(MONTH_LOW_SR_GAP, 1000) MONTH_LOW_SR_GAP,
                                NVL(MONTH_LOW_SR_REJECT, 0) MONTH_LOW_SR_REJECT,

                                DAY_HIGH_SR_VALUE,
                                NVL(DAY_HIGH_SR_GAP, 1000) DAY_HIGH_SR_GAP,
                                NVL(DAY_HIGH_SR_REJECT, 0) DAY_HIGH_SR_REJECT,
                                DAY_WEEK_HIGH_SR_VALUE,
                                NVL(DAY_WEEK_HIGH_SR_GAP, 1000) DAY_WEEK_HIGH_SR_GAP,
                                NVL(DAY_WEEK_HIGH_SR_REJECT, 0) DAY_WEEK_HIGH_SR_REJECT,
                                DAY_MONTH_HIGH_SR_VALUE,
                                NVL(DAY_MONTH_HIGH_SR_GAP, 1000) DAY_MONTH_HIGH_SR_GAP,
                                NVL(DAY_MONTH_HIGH_SR_REJECT, 0) DAY_MONTH_HIGH_SR_REJECT,
                                WEEK_HIGH_SR_VALUE,
                                NVL(WEEK_HIGH_SR_GAP, 1000) WEEK_HIGH_SR_GAP,
                                NVL(WEEK_HIGH_SR_REJECT, 0) WEEK_HIGH_SR_REJECT,
                                WEEK_MONTH_HIGH_SR_VALUE,
                                NVL(WEEK_MONTH_HIGH_SR_GAP, 1000) WEEK_MONTH_HIGH_SR_GAP,
                                NVL(WEEK_MONTH_HIGH_SR_REJECT, 0) WEEK_MONTH_HIGH_SR_REJECT,
                                MONTH_HIGH_SR_VALUE,
                                NVL(MONTH_HIGH_SR_GAP, 1000) MONTH_HIGH_SR_GAP,
                                NVL(MONTH_HIGH_SR_REJECT, 0) MONTH_HIGH_SR_REJECT,

                                CASE
                                    WHEN MONTH_HIGH_SR_GAP IS NULL THEN 1
                                    WHEN MONTH_LOW_SR_GAP IS NULL THEN -1
                                    ELSE 0
                                END NO_SR_LEVELS,

                                NVL(DAY_EMA_TREND_POSITION, 0) DAY_EMA_TREND_POSITION,
                                DAY_SLOPE_EMA12,
                                DAY_SLOPE_EMA30,
                                DAY_SLOPE_EMA50,
                                DAY_SLOPE_EMA200,
                                DAY_PROJ_INTER_CLOSE12_CLOSE30,
                                DAY_PROJ_INTER_CLOSE30_CLOSE50,
                                DAY_PROJ_INTER_CLOSE50_CLOSE200,

                                DAY_CLOSE12_CLOSE30_T1_STATE,
                                DAY_CLOSE12_CLOSE30_T1_STATE_TICKS,
                                DAY_CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR,
                                DAY_CLOSE12_CLOSE30_STATE_HIGH_GAP_ATR,
                                DAY_CLOSE12_CLOSE30_STATE_LOW_GAP_ATR,
                                DAY_CLOSE30_CLOSE50_T1_STATE,
                                DAY_CLOSE30_CLOSE50_T1_STATE_TICKS,
                                DAY_CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR,
                                DAY_CLOSE30_CLOSE50_STATE_HIGH_GAP_ATR,
                                DAY_CLOSE30_CLOSE50_STATE_LOW_GAP_ATR,
                                DAY_CLOSE50_CLOSE200_T1_STATE,
                                DAY_CLOSE50_CLOSE200_T1_STATE_TICKS,
                                DAY_CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR,
                                DAY_CLOSE50_CLOSE200_STATE_HIGH_GAP_ATR,
                                DAY_CLOSE50_CLOSE200_STATE_LOW_GAP_ATR,
                                DAY_EMA12_T1_STATE,
                                DAY_EMA12_T1_STATE_TICKS,
                                DAY_EMA12_STATE_PEAK_GAP_ATR,
                                DAY_EMA12_STATE_HIGH_GAP_ATR,
                                DAY_EMA12_STATE_LOW_GAP_ATR,
                                DAY_EMA30_T1_STATE,
                                DAY_EMA30_T1_STATE_TICKS,
                                DAY_EMA30_STATE_PEAK_GAP_ATR,
                                DAY_EMA30_STATE_HIGH_GAP_ATR,
                                DAY_EMA30_STATE_LOW_GAP_ATR,
                                DAY_EMA50_T1_STATE,
                                DAY_EMA50_T1_STATE_TICKS,
                                DAY_EMA50_STATE_PEAK_GAP_ATR,
                                DAY_EMA50_STATE_HIGH_GAP_ATR,
                                DAY_EMA50_STATE_LOW_GAP_ATR,
                                DAY_EMA200_T1_STATE,
                                DAY_EMA200_T1_STATE_TICKS,
                                DAY_EMA200_STATE_PEAK_GAP_ATR,
                                DAY_EMA200_STATE_HIGH_GAP_ATR,
                                DAY_EMA200_STATE_LOW_GAP_ATR,
                                DAY_EMA12_GAP_ATR,
                                DAY_EMA30_GAP_ATR,
                                DAY_EMA50_GAP_ATR,
                                DAY_EMA200_GAP_ATR,
                                DAY_EMA_12_30_GAP_ATR,
                                DAY_EMA_30_50_GAP_ATR,
                                DAY_EMA_50_200_GAP_ATR,
                                NVL(DAY_EMA12_REJECT, 0) DAY_EMA12_REJECT,
                                NVL(DAY_EMA30_REJECT, 0) DAY_EMA30_REJECT,
                                NVL(DAY_EMA50_REJECT, 0) DAY_EMA50_REJECT,
                                NVL(DAY_EMA200_REJECT, 0) DAY_EMA200_REJECT,
                                NVL(WEEK_EMA12_REJECT, 0) WEEK_EMA12_REJECT,
                                NVL(WEEK_EMA30_REJECT, 0) WEEK_EMA30_REJECT,
                                NVL(WEEK_EMA50_REJECT, 0) WEEK_EMA50_REJECT,
                                NVL(WEEK_EMA200_REJECT, 0) WEEK_EMA200_REJECT,
                                NVL(MONTH_EMA12_REJECT, 0) MONTH_EMA12_REJECT,
                                NVL(MONTH_EMA30_REJECT, 0) MONTH_EMA30_REJECT,
                                NVL(MONTH_EMA50_REJECT, 0) MONTH_EMA50_REJECT,
                                NVL(MONTH_EMA200_REJECT, 0) MONTH_EMA200_REJECT,
                                DAY_RSI,
                                DAY_MFI,
                                DAY_SAR,
                                LAG(DAY_SAR) OVER (PARTITION BY SYMBOL ORDER BY TICK_TIMESTAMP) PREV_DAY_SAR,
                                LAG(DAY_SAR, 2) OVER (PARTITION BY SYMBOL ORDER BY TICK_TIMESTAMP) PREV_2_DAY_SAR,
                                BUY_TP_1_SL_1,
                                BUY_TP_2_SL_1,
                                BUY_TP_3_SL_1,
                                BUY_TP_4_SL_1,
                                BUY_TP_5_SL_1,
                                BUY_TP_6_SL_1,
                                BUY_TP_7_SL_1,
                                BUY_TP_8_SL_1,
                                BUY_TP_9_SL_1,
                                BUY_TP_10_SL_1,
                                BUY_TP_11_SL_1,
                                BUY_TP_12_SL_1,
                                BUY_TP_1_SL_2,
                                BUY_TP_2_SL_2,
                                BUY_TP_3_SL_2,
                                BUY_TP_4_SL_2,
                                BUY_TP_5_SL_2,
                                BUY_TP_6_SL_2,
                                BUY_TP_7_SL_2,
                                BUY_TP_8_SL_2,
                                BUY_TP_9_SL_2,
                                BUY_TP_10_SL_2,
                                BUY_TP_11_SL_2,
                                BUY_TP_12_SL_2,
                                BUY_TP_1_SL_3,
                                BUY_TP_2_SL_3,
                                BUY_TP_3_SL_3,
                                BUY_TP_4_SL_3,
                                BUY_TP_5_SL_3,
                                BUY_TP_6_SL_3,
                                BUY_TP_7_SL_3,
                                BUY_TP_8_SL_3,
                                BUY_TP_9_SL_3,
                                BUY_TP_10_SL_3,
                                BUY_TP_11_SL_3,
                                BUY_TP_12_SL_3,
                                BUY_TP_1_SL_4,
                                BUY_TP_2_SL_4,
                                BUY_TP_3_SL_4,
                                BUY_TP_4_SL_4,
                                BUY_TP_5_SL_4,
                                BUY_TP_6_SL_4,
                                BUY_TP_7_SL_4,
                                BUY_TP_8_SL_4,
                                BUY_TP_9_SL_4,
                                BUY_TP_10_SL_4,
                                BUY_TP_11_SL_4,
                                BUY_TP_12_SL_4,
                                BUY_TP_1_SL_5,
                                BUY_TP_2_SL_5,
                                BUY_TP_3_SL_5,
                                BUY_TP_4_SL_5,
                                BUY_TP_5_SL_5,
                                BUY_TP_6_SL_5,
                                BUY_TP_7_SL_5,
                                BUY_TP_8_SL_5,
                                BUY_TP_9_SL_5,
                                BUY_TP_10_SL_5,
                                BUY_TP_11_SL_5,
                                BUY_TP_12_SL_5,
                                BUY_TP_1_SL_6,
                                BUY_TP_2_SL_6,
                                BUY_TP_3_SL_6,
                                BUY_TP_4_SL_6,
                                BUY_TP_5_SL_6,
                                BUY_TP_6_SL_6,
                                BUY_TP_7_SL_6,
                                BUY_TP_8_SL_6,
                                BUY_TP_9_SL_6,
                                BUY_TP_10_SL_6,
                                BUY_TP_11_SL_6,
                                BUY_TP_12_SL_6,
                                BUY_TP_1_SL_7,
                                BUY_TP_2_SL_7,
                                BUY_TP_3_SL_7,
                                BUY_TP_4_SL_7,
                                BUY_TP_5_SL_7,
                                BUY_TP_6_SL_7,
                                BUY_TP_7_SL_7,
                                BUY_TP_8_SL_7,
                                BUY_TP_9_SL_7,
                                BUY_TP_10_SL_7,
                                BUY_TP_11_SL_7,
                                BUY_TP_12_SL_7,
                                BUY_TP_1_SL_8,
                                BUY_TP_2_SL_8,
                                BUY_TP_3_SL_8,
                                BUY_TP_4_SL_8,
                                BUY_TP_5_SL_8,
                                BUY_TP_6_SL_8,
                                BUY_TP_7_SL_8,
                                BUY_TP_8_SL_8,
                                BUY_TP_9_SL_8,
                                BUY_TP_10_SL_8,
                                BUY_TP_11_SL_8,
                                BUY_TP_12_SL_8,
                                BUY_TP_1_SL_9,
                                BUY_TP_2_SL_9,
                                BUY_TP_3_SL_9,
                                BUY_TP_4_SL_9,
                                BUY_TP_5_SL_9,
                                BUY_TP_6_SL_9,
                                BUY_TP_7_SL_9,
                                BUY_TP_8_SL_9,
                                BUY_TP_9_SL_9,
                                BUY_TP_10_SL_9,
                                BUY_TP_11_SL_9,
                                BUY_TP_12_SL_9,
                                BUY_TP_1_SL_10,
                                BUY_TP_2_SL_10,
                                BUY_TP_3_SL_10,
                                BUY_TP_4_SL_10,
                                BUY_TP_5_SL_10,
                                BUY_TP_6_SL_10,
                                BUY_TP_7_SL_10,
                                BUY_TP_8_SL_10,
                                BUY_TP_9_SL_10,
                                BUY_TP_10_SL_10,
                                BUY_TP_11_SL_10,
                                BUY_TP_12_SL_10,
                                BUY_TP_1_SL_11,
                                BUY_TP_2_SL_11,
                                BUY_TP_3_SL_11,
                                BUY_TP_4_SL_11,
                                BUY_TP_5_SL_11,
                                BUY_TP_6_SL_11,
                                BUY_TP_7_SL_11,
                                BUY_TP_8_SL_11,
                                BUY_TP_9_SL_11,
                                BUY_TP_10_SL_11,
                                BUY_TP_11_SL_11,
                                BUY_TP_12_SL_11,
                                BUY_TP_1_SL_12,
                                BUY_TP_2_SL_12,
                                BUY_TP_3_SL_12,
                                BUY_TP_4_SL_12,
                                BUY_TP_5_SL_12,
                                BUY_TP_6_SL_12,
                                BUY_TP_7_SL_12,
                                BUY_TP_8_SL_12,
                                BUY_TP_9_SL_12,
                                BUY_TP_10_SL_12,
                                BUY_TP_11_SL_12,
                                BUY_TP_12_SL_12,
                                SELL_TP_1_SL_1,
                                SELL_TP_2_SL_1,
                                SELL_TP_3_SL_1,
                                SELL_TP_4_SL_1,
                                SELL_TP_5_SL_1,
                                SELL_TP_6_SL_1,
                                SELL_TP_7_SL_1,
                                SELL_TP_8_SL_1,
                                SELL_TP_9_SL_1,
                                SELL_TP_10_SL_1,
                                SELL_TP_11_SL_1,
                                SELL_TP_12_SL_1,
                                SELL_TP_1_SL_2,
                                SELL_TP_2_SL_2,
                                SELL_TP_3_SL_2,
                                SELL_TP_4_SL_2,
                                SELL_TP_5_SL_2,
                                SELL_TP_6_SL_2,
                                SELL_TP_7_SL_2,
                                SELL_TP_8_SL_2,
                                SELL_TP_9_SL_2,
                                SELL_TP_10_SL_2,
                                SELL_TP_11_SL_2,
                                SELL_TP_12_SL_2,
                                SELL_TP_1_SL_3,
                                SELL_TP_2_SL_3,
                                SELL_TP_3_SL_3,
                                SELL_TP_4_SL_3,
                                SELL_TP_5_SL_3,
                                SELL_TP_6_SL_3,
                                SELL_TP_7_SL_3,
                                SELL_TP_8_SL_3,
                                SELL_TP_9_SL_3,
                                SELL_TP_10_SL_3,
                                SELL_TP_11_SL_3,
                                SELL_TP_12_SL_3,
                                SELL_TP_1_SL_4,
                                SELL_TP_2_SL_4,
                                SELL_TP_3_SL_4,
                                SELL_TP_4_SL_4,
                                SELL_TP_5_SL_4,
                                SELL_TP_6_SL_4,
                                SELL_TP_7_SL_4,
                                SELL_TP_8_SL_4,
                                SELL_TP_9_SL_4,
                                SELL_TP_10_SL_4,
                                SELL_TP_11_SL_4,
                                SELL_TP_12_SL_4,
                                SELL_TP_1_SL_5,
                                SELL_TP_2_SL_5,
                                SELL_TP_3_SL_5,
                                SELL_TP_4_SL_5,
                                SELL_TP_5_SL_5,
                                SELL_TP_6_SL_5,
                                SELL_TP_7_SL_5,
                                SELL_TP_8_SL_5,
                                SELL_TP_9_SL_5,
                                SELL_TP_10_SL_5,
                                SELL_TP_11_SL_5,
                                SELL_TP_12_SL_5,
                                SELL_TP_1_SL_6,
                                SELL_TP_2_SL_6,
                                SELL_TP_3_SL_6,
                                SELL_TP_4_SL_6,
                                SELL_TP_5_SL_6,
                                SELL_TP_6_SL_6,
                                SELL_TP_7_SL_6,
                                SELL_TP_8_SL_6,
                                SELL_TP_9_SL_6,
                                SELL_TP_10_SL_6,
                                SELL_TP_11_SL_6,
                                SELL_TP_12_SL_6,
                                SELL_TP_1_SL_7,
                                SELL_TP_2_SL_7,
                                SELL_TP_3_SL_7,
                                SELL_TP_4_SL_7,
                                SELL_TP_5_SL_7,
                                SELL_TP_6_SL_7,
                                SELL_TP_7_SL_7,
                                SELL_TP_8_SL_7,
                                SELL_TP_9_SL_7,
                                SELL_TP_10_SL_7,
                                SELL_TP_11_SL_7,
                                SELL_TP_12_SL_7,
                                SELL_TP_1_SL_8,
                                SELL_TP_2_SL_8,
                                SELL_TP_3_SL_8,
                                SELL_TP_4_SL_8,
                                SELL_TP_5_SL_8,
                                SELL_TP_6_SL_8,
                                SELL_TP_7_SL_8,
                                SELL_TP_8_SL_8,
                                SELL_TP_9_SL_8,
                                SELL_TP_10_SL_8,
                                SELL_TP_11_SL_8,
                                SELL_TP_12_SL_8,
                                SELL_TP_1_SL_9,
                                SELL_TP_2_SL_9,
                                SELL_TP_3_SL_9,
                                SELL_TP_4_SL_9,
                                SELL_TP_5_SL_9,
                                SELL_TP_6_SL_9,
                                SELL_TP_7_SL_9,
                                SELL_TP_8_SL_9,
                                SELL_TP_9_SL_9,
                                SELL_TP_10_SL_9,
                                SELL_TP_11_SL_9,
                                SELL_TP_12_SL_9,
                                SELL_TP_1_SL_10,
                                SELL_TP_2_SL_10,
                                SELL_TP_3_SL_10,
                                SELL_TP_4_SL_10,
                                SELL_TP_5_SL_10,
                                SELL_TP_6_SL_10,
                                SELL_TP_7_SL_10,
                                SELL_TP_8_SL_10,
                                SELL_TP_9_SL_10,
                                SELL_TP_10_SL_10,
                                SELL_TP_11_SL_10,
                                SELL_TP_12_SL_10,
                                SELL_TP_1_SL_11,
                                SELL_TP_2_SL_11,
                                SELL_TP_3_SL_11,
                                SELL_TP_4_SL_11,
                                SELL_TP_5_SL_11,
                                SELL_TP_6_SL_11,
                                SELL_TP_7_SL_11,
                                SELL_TP_8_SL_11,
                                SELL_TP_9_SL_11,
                                SELL_TP_10_SL_11,
                                SELL_TP_11_SL_11,
                                SELL_TP_12_SL_11,
                                SELL_TP_1_SL_12,
                                SELL_TP_2_SL_12,
                                SELL_TP_3_SL_12,
                                SELL_TP_4_SL_12,
                                SELL_TP_5_SL_12,
                                SELL_TP_6_SL_12,
                                SELL_TP_7_SL_12,
                                SELL_TP_8_SL_12,
                                SELL_TP_9_SL_12,
                                SELL_TP_10_SL_12,
                                SELL_TP_11_SL_12,
                                SELL_TP_12_SL_12
                        from T0
                        where DAY_PREV_GAP_ATR IS NOT NULL
                                AND         WEEK_PREV_GAP_ATR IS NOT NULL
                                AND         MONTH_PREV_GAP_ATR IS NOT NULL
                                AND         WEEK_INTERVAL_TR_RATIO IS NOT NULL
                                AND         WEEK_INTERVAL_TICK_TR_RATIO IS NOT NULL
                                AND         MONTH_INTERVAL_TR_RATIO IS NOT NULL
                                AND         MONTH_INTERVAL_TICK_TR_RATIO IS NOT NULL
                                AND         DAY_SIDE_START_TREND_GAP_ATR IS NOT NULL
                                AND         DAY_SIDE_END_TREND_GAP_ATR IS NOT NULL
                                AND         DAY_TREND_TYPE IS NOT NULL
                                AND         DAY_TREND_START_TREND_GAP_ATR IS NOT NULL
                                AND         DAY_TREND_END_TREND_GAP_ATR IS NOT NULL
                                AND         WEEK_SIDE_START_TREND_GAP_ATR IS NOT NULL
                                AND         WEEK_SIDE_END_TREND_GAP_ATR IS NOT NULL
                                AND         WEEK_TREND_TYPE IS NOT NULL
                                AND         WEEK_TREND_START_TREND_GAP_ATR IS NOT NULL
                                AND         WEEK_TREND_END_TREND_GAP_ATR IS NOT NULL
                                AND         DAY_SLOPE_EMA12 IS NOT NULL
                                AND         DAY_SLOPE_EMA30 IS NOT NULL
                                AND         DAY_SLOPE_EMA50 IS NOT NULL
                                AND         DAY_SLOPE_EMA200 IS NOT NULL
                                AND         DAY_PROJ_INTER_CLOSE12_CLOSE30 IS NOT NULL
                                AND         DAY_PROJ_INTER_CLOSE30_CLOSE50 IS NOT NULL
                                AND         DAY_PROJ_INTER_CLOSE50_CLOSE200 IS NOT NULL
                                AND         DAY_CLOSE12_CLOSE30_T1_STATE IS NOT NULL
                                AND         DAY_CLOSE12_CLOSE30_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_CLOSE12_CLOSE30_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE12_CLOSE30_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE12_CLOSE30_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE30_CLOSE50_T1_STATE IS NOT NULL
                                AND         DAY_CLOSE30_CLOSE50_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_CLOSE30_CLOSE50_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE30_CLOSE50_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE30_CLOSE50_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE50_CLOSE200_T1_STATE IS NOT NULL
                                AND         DAY_CLOSE50_CLOSE200_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_CLOSE50_CLOSE200_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE50_CLOSE200_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_CLOSE50_CLOSE200_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_EMA12_T1_STATE IS NOT NULL
                                AND         DAY_EMA12_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_EMA12_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_EMA12_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_EMA12_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_EMA30_T1_STATE IS NOT NULL
                                AND         DAY_EMA30_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_EMA30_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_EMA30_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_EMA30_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_EMA50_T1_STATE IS NOT NULL
                                AND         DAY_EMA50_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_EMA50_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_EMA50_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_EMA50_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_EMA200_T1_STATE IS NOT NULL
                                AND         DAY_EMA200_T1_STATE_TICKS IS NOT NULL
                                AND         DAY_EMA200_STATE_PEAK_GAP_ATR IS NOT NULL
                                AND         DAY_EMA200_STATE_HIGH_GAP_ATR IS NOT NULL
                                AND         DAY_EMA200_STATE_LOW_GAP_ATR IS NOT NULL
                                AND         DAY_RSI IS NOT NULL
                                AND         DAY_MFI IS NOT NULL
                                AND         DAY_SAR IS NOT NULL
                                ';

    EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE DATA_STATS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE TRENDS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE EMA PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE SR PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE STATS PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE MAIN_DATA PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;    

/
--------------------------------------------------------
--  DDL for Function POP_O_MODEL_SL_TP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_O_MODEL_SL_TP" 
return varchar2
is
    V_OUTPUT VARCHAR2(100);
    pragma autonomous_transaction;

begin

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T2 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T3 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T4 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE T5 PURGE';
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;


    EXECUTE IMMEDIATE 'CREATE TABLE T0
                        AS
                        WITH D0
                        AS
                        (
                            SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 1 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_1_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 2 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_2_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 3 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_3_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 4 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_4_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 5 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_5_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 6 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_6_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 7 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_7_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 8 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_8_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 9 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_9_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 10 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_10_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 11 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_11_ATR,
                                MIN(CASE WHEN B.LOW <= A.CLOSE - 12 * A.ATR THEN B.TICK_TIMESTAMP END) LOWER_TS_12_ATR,

                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 1 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_1_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 2 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_2_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 3 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_3_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 4 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_4_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 5 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_5_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 6 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_6_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 7 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_7_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 8 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_8_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 9 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_9_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 10 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_10_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 11 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_11_ATR,
                                MIN(CASE WHEN B.HIGH >= A.CLOSE + 12 * A.ATR THEN B.TICK_TIMESTAMP END) HIGHER_TS_12_ATR
                            FROM O_MKT_DATA A
                            LEFT JOIN O_MKT_DATA B
                            ON A.SYMBOL = B.SYMBOL
                            AND A.INTERVAL = B.INTERVAL
                            AND B.TICK_TIMESTAMP > A.TICK_TIMESTAMP
                            AND B.TICK_TIMESTAMP <= TO_CHAR(TO_DATE(A.TICK_TIMESTAMP, ''YYYY-MM-DD HH24:MI:SS'') + 120, ''YYYY-MM-DD HH24:MI:SS'')
                            WHERE A.INTERVAL = ''1D''
                            GROUP BY A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR
                        )
                        SELECT * FROM D0';

    EXECUTE IMMEDIATE 'CREATE TABLE T1
                    AS
                    WITH
                    D1
                    AS
                    (
                        SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_1,
                            CASE 
                                WHEN LOWER_TS_1_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_1_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_1_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_1,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_2,
                            CASE 
                                WHEN LOWER_TS_2_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_2_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_2_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_2,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_3,
                            CASE 
                                WHEN LOWER_TS_3_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_3_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_3_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_3,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_4,   '||'
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_4,
                            CASE 
                                WHEN LOWER_TS_4_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_4_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_4_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_4,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_5,
                            CASE 
                                WHEN LOWER_TS_5_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_5_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_5_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_5,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_6,  '||'
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_6,
                            CASE 
                                WHEN LOWER_TS_6_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_6_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_6_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_6
                            FROM   t0 a
                            )
                            SELECT *
                            FROM D1';

    EXECUTE IMMEDIATE 'CREATE TABLE T2
                    AS
                    WITH
                    D1
                    AS
                    (
                        SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_7,
                            CASE 
                                WHEN LOWER_TS_7_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_7_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_7_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_7,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_8,
                            CASE 
                                WHEN LOWER_TS_8_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_8_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_8_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_8,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_9,
                            CASE 
                                WHEN LOWER_TS_9_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_9_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_9_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_9, '||'
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_10,
                            CASE 
                                WHEN LOWER_TS_10_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_10_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_10_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_10,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_11,
                            CASE 
                                WHEN LOWER_TS_11_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_11_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_11_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_11,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_1_ATR THEN -1 
                                WHEN HIGHER_TS_1_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_1_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_1_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_1_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_2_ATR THEN -1 
                                WHEN HIGHER_TS_2_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_2_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_2_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_2_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_3_ATR THEN -1 
                                WHEN HIGHER_TS_3_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_3_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_3_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_3_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_4_ATR THEN -1 
                                WHEN HIGHER_TS_4_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_4_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_4_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_4_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_5_ATR THEN -1 
                                WHEN HIGHER_TS_5_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_5_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_5_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_5_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_6_ATR THEN -1 
                                WHEN HIGHER_TS_6_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_6_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_6_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_6_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_7_ATR THEN -1 
                                WHEN HIGHER_TS_7_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_7_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_7_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_7_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_8_ATR THEN -1 
                                WHEN HIGHER_TS_8_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_8_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_8_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_8_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_9_ATR THEN -1 
                                WHEN HIGHER_TS_9_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_9_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_9_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_9_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_10_ATR THEN -1 
                                WHEN HIGHER_TS_10_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_10_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_10_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_10_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_11_ATR THEN -1 
                                WHEN HIGHER_TS_11_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_11_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_11_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_11_SL_12,
                            CASE 
                                WHEN LOWER_TS_12_ATR < HIGHER_TS_12_ATR THEN -1 
                                WHEN HIGHER_TS_12_ATR < LOWER_TS_12_ATR THEN 1
                                WHEN HIGHER_TS_12_ATR IS NULL AND LOWER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN HIGHER_TS_12_ATR IS NOT NULL AND LOWER_TS_12_ATR IS NULL THEN 1 
                            END BUY_TP_12_SL_12
                            FROM   t0 a
                        )
                        SELECT * 
                        FROM D1';

    EXECUTE IMMEDIATE 'CREATE TABLE T3
                    AS
                    WITH
                    D1
                    AS
                    (
                        SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR,
                           CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_1_ATR THEN -1
                                WHEN HIGHER_TS_1_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_1_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_1_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_1,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_2,           '||'                  
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_2_ATR THEN -1
                                WHEN HIGHER_TS_2_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_2_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_2_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_2,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_3_ATR THEN -1
                                WHEN HIGHER_TS_3_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_3_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_3_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_3,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_4_ATR THEN -1
                                WHEN HIGHER_TS_4_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_4_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_4_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_4,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_5_ATR THEN -1
                                WHEN HIGHER_TS_5_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_5_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_5_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_5,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_6,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_6_ATR THEN -1
                                WHEN HIGHER_TS_6_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_6_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_6_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_6                       
                            FROM   t0 a
                        )
                        SELECT * 
                        FROM D1';


    EXECUTE IMMEDIATE 'CREATE TABLE T4
                    AS
                    WITH
                    D1
                    AS
                    (
                        SELECT A.SYMBOL, A.TICK_TIMESTAMP, A.CLOSE, A.ATR,                        
                           CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_7,                  '||'       
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_7_ATR THEN -1
                                WHEN HIGHER_TS_7_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_7_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_7_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_7,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_8_ATR THEN -1
                                WHEN HIGHER_TS_8_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_8_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_8_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_8,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_9_ATR THEN -1
                                WHEN HIGHER_TS_9_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_9_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_9_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_9,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_10_ATR THEN -1
                                WHEN HIGHER_TS_10_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_10_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_10_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_10,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_11_ATR THEN -1
                                WHEN HIGHER_TS_11_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_11_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_11_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_11,                            
                            CASE 
                                WHEN LOWER_TS_1_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_1_ATR THEN 1 
                                WHEN LOWER_TS_1_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_1_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_1_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_2_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_2_ATR THEN 1 
                                WHEN LOWER_TS_2_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_2_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_2_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_3_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_3_ATR THEN 1 
                                WHEN LOWER_TS_3_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_3_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_3_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_4_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_4_ATR THEN 1 
                                WHEN LOWER_TS_4_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_4_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_4_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_5_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_5_ATR THEN 1 
                                WHEN LOWER_TS_5_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_5_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_5_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_6_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_6_ATR THEN 1 
                                WHEN LOWER_TS_6_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_6_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_6_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_7_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_7_ATR THEN 1 
                                WHEN LOWER_TS_7_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_7_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_7_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_8_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_8_ATR THEN 1 
                                WHEN LOWER_TS_8_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_8_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_8_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_9_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_9_ATR THEN 1 
                                WHEN LOWER_TS_9_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_9_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_9_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_10_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_10_ATR THEN 1 
                                WHEN LOWER_TS_10_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_10_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_10_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_11_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_11_ATR THEN 1 
                                WHEN LOWER_TS_11_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_11_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_11_SL_12,                            
                            CASE 
                                WHEN LOWER_TS_12_ATR > HIGHER_TS_12_ATR THEN -1
                                WHEN HIGHER_TS_12_ATR > LOWER_TS_12_ATR THEN 1 
                                WHEN LOWER_TS_12_ATR IS NULL AND HIGHER_TS_12_ATR IS NOT NULL THEN -1
                                WHEN LOWER_TS_12_ATR IS NOT NULL AND HIGHER_TS_12_ATR IS NULL THEN 1 
                            END SELL_TP_12_SL_12
                    FROM   t0 a
                         )
                  SELECT *
                  FROM   d1 ';                    

    EXECUTE IMMEDIATE 'DROP TABLE O_MODEL_SL_TP PURGE';
    EXECUTE IMMEDIATE 'CREATE TABLE O_MODEL_SL_TP
                        AS
                        SELECT *
                        FROM T1 A
                        NATURAL JOIN T2 B
                        NATURAL JOIN T3 C
                        NATURAL JOIN T4 D
                        ';


    EXECUTE IMMEDIATE 'DROP TABLE T0 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T1 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T2 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T3 PURGE';
    EXECUTE IMMEDIATE 'DROP TABLE T4 PURGE';

    COMMIT;
    RETURN 'SUCCESS';
END;    


/
--------------------------------------------------------
--  DDL for Function POP_O_MODEL_TRADE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."POP_O_MODEL_TRADE" (P_RUN_DATE VARCHAR2)
return varchar2
is
    PRAGMA AUTONOMOUS_TRANSACTION;

    V_OPEN_TRADES NUMBER := 0;
    V_ENTRY_PRICE NUMBER;
    V_KELLY NUMBER;
BEGIN

    -- OPENING TRADES
    FOR TRADE_REC IN 
        (
            SELECT * 
            FROM O_MODEL_SIGNALS
            WHERE TICK_TIMESTAMP = P_RUN_DATE
            ORDER BY TP
        )
    LOOP
        SELECT COUNT(*) 
        INTO V_OPEN_TRADES
        FROM O_MODEL_TRADE 
        WHERE SYMBOL = TRADE_REC.SYMBOL
        AND EXIT_MODEL_TIMESTAMP IS NULL 
        AND CREATE_MODEL_TIMESTAMP <= P_RUN_DATE ;

        IF V_OPEN_TRADES = 0
        THEN

            with d0
            as
            (
                select count(*) hist_trades,
                    count(case when A.exit_model_price > A.enter_model_price then 1 end) hist_win_trades,
                    round(avg((A.initial_tp - A.enter_model_price)/(A.enter_model_price - A.initial_sl)), 2) hist_profit_factor
                from o_model_trade A
                where a.SYMBOL = TRADE_REC.SYMBOL
                and a.create_model_timestamp < P_RUN_DATE 
                and a.trade_type = 'BUY'
            ),
            d1
            as
            (
                select hist_trades, hist_win_trades, round(hist_win_trades/nullif(hist_trades, 0),3) hist_win_ratio, hist_profit_factor
                from d0
            )
            select nvl(round(((hist_profit_factor * hist_win_ratio) - (1-hist_win_ratio))/nullif(hist_profit_factor, 0),3), 1) kelly
            into v_kelly
            from d1 a;


            INSERT INTO O_MODEL_TRADE (SYMBOL, TRADE_TYPE, CREATE_MODEL_TIMESTAMP, ENTER_MODEL_TIMESTAMP, 
                    ENTER_MODEL_PRICE_THRESHOLD, ENTER_MODEL_PRICE, INITIAL_SL, TRAILING_SL, INITIAL_TP, TRAILING_TP, MODEL_NAME, kelly)
            VALUES (TRADE_REC.SYMBOL, 'BUY', TRADE_REC.TICK_TIMESTAMP, TRADE_REC.TICK_TIMESTAMP, 
                    TRADE_REC.ENTRY_PRICE, TRADE_REC.ENTRY_PRICE, TRADE_REC.SL_PRICE, TRADE_REC.SL_PRICE, TRADE_REC.TP_PRICE, TRADE_REC.TP_PRICE, 'MODEL-1', v_kelly);
        END IF; 
    END LOOP;
    COMMIT;


    -- EXITING TRADES
    FOR OPEN_REC IN
    (
        SELECT A.SYMBOL, A.ENTER_MODEL_TIMESTAMP, A.TRAILING_TP, A.TRAILING_SL, B.CLOSE, B.OPEN, B.HIGH, B.LOW,
            MAX(C.EXIT_TRADE_TIMESTAMP) EXIT_TRADE_TIMESTAMP,
            MAX(C.CANCEL_TRADE_TIMESTAMP) CANCEL_TRADE_TIMESTAMP,
            MAX(C.EXIT_TRADE_PRICE) EXIT_TRADE_PRICE
        FROM O_MODEL_TRADE A
        JOIN O_MKT_DATA B
        ON A.SYMBOL = B.SYMBOL
        AND B.TICK_TIMESTAMP = P_RUN_DATE
        AND B.TICK_TIMESTAMP > A.CREATE_MODEL_TIMESTAMP
        AND B.INTERVAL = '1D'
        AND a.EXIT_MODEL_TIMESTAMP IS NULL
        AND ENTER_MODEL_TIMESTAMP IS NOT NULL
        LEFT JOIN D_ACCOUNT_TRADE C
        ON A.SYMBOL = C.SYMBOL
        AND A.ENTER_MODEL_TIMESTAMP = C.ENTER_MODEL_TIMESTAMP
        GROUP BY A.SYMBOL, A.ENTER_MODEL_TIMESTAMP, A.TRAILING_TP, A.TRAILING_SL, B.CLOSE, B.OPEN, B.HIGH, B.LOW
    )
    LOOP
        IF OPEN_REC.OPEN <= OPEN_REC.TRAILING_SL 
        THEN
            UPDATE O_MODEL_TRADE
            SET EXIT_MODEL_TIMESTAMP = P_RUN_DATE,
                EXIT_MODEL_PRICE = OPEN_REC.OPEN,
                EXIT_TYPE = 'SL OPEN'
            WHERE SYMBOL = OPEN_REC.SYMBOL
            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
        ELSIF OPEN_REC.LOW <= OPEN_REC.TRAILING_SL 
        THEN
            UPDATE O_MODEL_TRADE
            SET EXIT_MODEL_TIMESTAMP = P_RUN_DATE,
                EXIT_MODEL_PRICE = TRAILING_SL,
                EXIT_TYPE = 'SL'
            WHERE SYMBOL = OPEN_REC.SYMBOL
            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
        ELSIF OPEN_REC.OPEN >= OPEN_REC.TRAILING_TP
        THEN
            UPDATE O_MODEL_TRADE
            SET EXIT_MODEL_TIMESTAMP = P_RUN_DATE,
                EXIT_MODEL_PRICE = OPEN_REC.OPEN,
                EXIT_TYPE = 'TP OPEN'
            WHERE SYMBOL = OPEN_REC.SYMBOL
            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
        ELSIF OPEN_REC.HIGH >= OPEN_REC.TRAILING_TP
        THEN
            UPDATE O_MODEL_TRADE
            SET EXIT_MODEL_TIMESTAMP = P_RUN_DATE,
                EXIT_MODEL_PRICE = TRAILING_TP,
                EXIT_TYPE = 'TP'
            WHERE SYMBOL = OPEN_REC.SYMBOL
            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
        -- This case is when the trade was terminated in live market for some reason.
        ------------------------------------------------------------------------------
--        ELSIF OPEN_REC.EXIT_TRADE_TIMESTAMP IS NOT NULL
--        THEN
--            UPDATE O_MODEL_TRADE
--            SET EXIT_MODEL_TIMESTAMP = OPEN_REC.EXIT_TRADE_TIMESTAMP,
--                EXIT_MODEL_PRICE = OPEN_REC.EXIT_TRADE_PRICE,
--                EXIT_TYPE = 'SYS'
--            WHERE SYMBOL = OPEN_REC.SYMBOL
--            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
--        ELSIF OPEN_REC.CANCEL_TRADE_TIMESTAMP IS NOT NULL
--        THEN
--            UPDATE O_MODEL_TRADE
--            SET EXIT_MODEL_TIMESTAMP = OPEN_REC.CANCEL_TRADE_TIMESTAMP,
--                EXIT_TYPE = 'CANCEL'
--            WHERE SYMBOL = OPEN_REC.SYMBOL
--            AND ENTER_MODEL_TIMESTAMP = OPEN_REC.ENTER_MODEL_TIMESTAMP;
        END IF;
    END LOOP;
    COMMIT;

    -- UPDATEING TRAILING TP SL

    FOR TRADE_REC IN 
        (

            SELECT * FROM O_MODEL_SIGNALS
            WHERE TICK_TIMESTAMP = P_RUN_DATE
            AND MODEL_NAME = 'MODEL-1'
        )
    LOOP
        SELECT COUNT(*)
        INTO V_OPEN_TRADES
        FROM O_MODEL_TRADE 
        WHERE SYMBOL = TRADE_REC.SYMBOL
        AND EXIT_MODEL_TIMESTAMP IS NULL;

        IF V_OPEN_TRADES >= 0
        THEN

            INSERT INTO O_MODEL_TRADE_CHANGE 
            SELECT 'MODEL-1', P_RUN_DATE, SYMBOL, 'BUY', CREATE_MODEL_TIMESTAMP, 'SL', TRAILING_SL,GREATEST (TRAILING_SL, TRADE_REC.SL_PRICE), 'MODEL-1' 
            FROM O_MODEL_TRADE
            WHERE SYMBOL = TRADE_REC.SYMBOL
            AND EXIT_MODEL_TIMESTAMP IS NULL
            AND TRAILING_SL <> GREATEST (TRAILING_SL, TRADE_REC.SL_PRICE);

            INSERT INTO O_MODEL_TRADE_CHANGE 
            SELECT 'MODEL-1', P_RUN_DATE, SYMBOL, 'BUY', CREATE_MODEL_TIMESTAMP, 'TP', TRAILING_TP,GREATEST (TRAILING_TP, TRADE_REC.TP_PRICE), 'MODEL-1' 
            FROM O_MODEL_TRADE
            WHERE SYMBOL = TRADE_REC.SYMBOL
            AND EXIT_MODEL_TIMESTAMP IS NULL
            AND TRAILING_TP <> GREATEST (TRAILING_TP, TRADE_REC.TP_PRICE);


            UPDATE O_MODEL_TRADE
            SET TRAILING_SL = GREATEST (TRAILING_SL, TRADE_REC.SL_PRICE),
                TRAILING_TP = GREATEST (TRAILING_TP, TRADE_REC.TP_PRICE)
            WHERE SYMBOL = TRADE_REC.SYMBOL
            AND EXIT_MODEL_TIMESTAMP IS NULL;

        END IF;
    END LOOP;


    COMMIT;
    RETURN 'SUCCESS';
END;

/
--------------------------------------------------------
--  DDL for Function SIMULATE_D_ACCOUNT_TRADE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "ADMIN"."SIMULATE_D_ACCOUNT_TRADE" (P_RUN_GROUP_NAME VARCHAR2 DEFAULT 'RunGroup1', 
                                                                  P_START_RUN_DATE VARCHAR2 DEFAULT '2019-08-16 00:00:00', 
                                                                  P_END_RUN_DATE VARCHAR2 DEFAULT '2024-08-23 00:00:00') 
RETURN VARCHAR2
IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    V_SYMBOL VARCHAR2(100);
    V_ENTER_MODEL_TIMESTAMP VARCHAR2(100);
    V_EXIST NUMBER;
    V_OUTPUT VARCHAR2(100);
BEGIN

    DELETE D_ACCOUNT_TRADE WHERE RUN_GROUP_NAME = P_RUN_GROUP_NAME AND ENTER_MODEL_TIMESTAMP BETWEEN P_START_RUN_DATE AND P_END_RUN_DATE;
    DELETE D_ACCOUNT_PNL WHERE RUN_GROUP_NAME = P_RUN_GROUP_NAME AND REPORT_DATE BETWEEN P_START_RUN_DATE AND P_END_RUN_DATE AND CATEGORY_NAME <> 'Deposit';
    DELETE D_TRADE_PERFORMANCE  WHERE RUN_GROUP_NAME = P_RUN_GROUP_NAME;
    COMMIT;

    FOR DAY_REC IN
        (
            SELECT CALENDAR_DAY 
            FROM D_TRADING_CALENDAR 
            WHERE CALENDAR_DAY >= P_START_RUN_DATE 
            AND CALENDAR_DAY <= P_END_RUN_DATE 
            ORDER BY 1
        )
    LOOP


        -- EXITING TRADES
        SELECT POP_D_ACCOUNT_TRADE_EXIT(DAY_REC.CALENDAR_DAY, P_RUN_GROUP_NAME) 
        INTO V_OUTPUT
        FROM DUAL;


        -- OPENING TRADES
        SELECT POP_D_ACCOUNT_TRADE_ENTER(DAY_REC.CALENDAR_DAY, P_RUN_GROUP_NAME) 
        INTO V_OUTPUT
        FROM DUAL;


        -- THIS SECTION SHOULD BE CALLED AFTER THE IB ENTER AND EXIT EXECUTION (reconciliation)
        -- AFTER ENTER:
        UPDATE D_ACCOUNT_TRADE A
        SET ENTER_TRADE_TIMESTAMP = ENTER_MODEL_TIMESTAMP, 
            ENTER_TRADE_PRICE = ENTER_MODEL_PRICE, 
            POSITION_SIZE = ROUND(QTY*ENTER_MODEL_PRICE),
            COMMISSION_ENTER = -1,  
            ENTER_PERMID = '---'
        WHERE ENTER_MODEL_TIMESTAMP = DAY_REC.CALENDAR_DAY
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

        INSERT INTO D_ACCOUNT_PNL
        SELECT ACCOUNT_ID, RUN_GROUP_NAME, ENTER_TRADE_TIMESTAMP, 'COMM_IN', SYMBOL||':'||ENTER_MODEL_TIMESTAMP, -1, SYSDATE
        FROM D_ACCOUNT_TRADE
        WHERE ENTER_TRADE_TIMESTAMP = DAY_REC.CALENDAR_DAY
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;


        -- AFTER EXIT:
        UPDATE D_ACCOUNT_TRADE A
        SET EXIT_TRADE_TIMESTAMP = EXIT_MODEL_TIMESTAMP,
            EXIT_TRADE_PRICE =  EXIT_MODEL_PRICE,
            COMMISSION_EXIT =  -1,
            EXIT_PERMID = '---',
            PROFIT = ROUND (CASE 
                                WHEN TRADE_TYPE = 'BUY' THEN ROUND(EXIT_MODEL_PRICE - ENTER_TRADE_PRICE, 3) 
                                WHEN TRADE_TYPE = 'SELL' THEN ROUND(ENTER_TRADE_PRICE - EXIT_MODEL_PRICE, 3)
                            END * QTY, 2) 
        WHERE EXIT_MODEL_TIMESTAMP = DAY_REC.CALENDAR_DAY
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

        INSERT INTO D_ACCOUNT_PNL
        SELECT ACCOUNT_ID, RUN_GROUP_NAME, EXIT_TRADE_TIMESTAMP, 'COMM_OUT', SYMBOL||':'||ENTER_MODEL_TIMESTAMP, -1, SYSDATE
        FROM D_ACCOUNT_TRADE
        WHERE EXIT_TRADE_TIMESTAMP = DAY_REC.CALENDAR_DAY
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

        INSERT INTO D_ACCOUNT_PNL
        SELECT ACCOUNT_ID, RUN_GROUP_NAME, EXIT_TRADE_TIMESTAMP, 'PROFIT', SYMBOL||':'||ENTER_MODEL_TIMESTAMP, PROFIT, SYSDATE
        FROM D_ACCOUNT_TRADE
        WHERE EXIT_TRADE_TIMESTAMP = DAY_REC.CALENDAR_DAY
        AND RUN_GROUP_NAME = P_RUN_GROUP_NAME;

        -- UPDATEING TRAILING TP SL
        UPDATE D_ACCOUNT_TRADE A
        SET (TRAILING_STOP_LOSS, TRAILING_TAKE_PROFIT) = (SELECT TRAILING_SL, TRAILING_TP 
                                            FROM O_MODEL_TRADE B
                                            WHERE A.SYMBOL = B.SYMBOL
                                            AND A.ENTER_MODEL_TIMESTAMP = B.ENTER_MODEL_TIMESTAMP
                                        )
        WHERE RUN_GROUP_NAME = P_RUN_GROUP_NAME
        AND NVL(EXIT_TRADE_TIMESTAMP, CANCEL_TRADE_TIMESTAMP) IS NULL;

        COMMIT;
    END LOOP;


    COMMIT;
    RETURN 'SUCCESS';
END;


/
--------------------------------------------------------
--  Constraints for Table D_SYMBOL_EXCLUDE
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_SYMBOL_EXCLUDE" ADD PRIMARY KEY ("SYMBOL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_ACCOUNT_PNL
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_ACCOUNT_PNL" ADD PRIMARY KEY ("ACCOUNT_ID", "RUN_GROUP_NAME", "REPORT_DATE", "CATEGORY_NAME", "ITEM_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_IB_CLOSED_ORDER
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_IB_CLOSED_ORDER" ADD PRIMARY KEY ("PERMID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_TRADING_CALENDAR
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_TRADING_CALENDAR" ADD PRIMARY KEY ("CALENDAR_DAY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_ACCOUNT_TRADE
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_ACCOUNT_TRADE" ADD PRIMARY KEY ("ACCOUNT_ID", "RUN_GROUP_NAME", "SYMBOL", "ENTER_MODEL_TIMESTAMP")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_MKT_PIVOTS
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_MKT_PIVOTS" ADD PRIMARY KEY ("SYMBOL", "INTERVAL", "PIVOT_TIMESTAMP")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table O_MODEL_PREDICT
--------------------------------------------------------

  ALTER TABLE "ADMIN"."O_MODEL_PREDICT" ADD PRIMARY KEY ("SYMBOL", "TICK_TIMESTAMP", "MODELING_LEVEL", "TRADE_SIGNAL", "TP", "SL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_IB_CLOSED_ORDER_DETAILS
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_IB_CLOSED_ORDER_DETAILS" ADD PRIMARY KEY ("PERMID", "EXECID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table O_MKT_DATA
--------------------------------------------------------

  ALTER TABLE "ADMIN"."O_MKT_DATA" ADD PRIMARY KEY ("SYMBOL", "INTERVAL", "TICK_TIMESTAMP")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_SYMBOL_NOTIFICATION
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_SYMBOL_NOTIFICATION" ADD PRIMARY KEY ("SYMBOL", "TICK_TIMESTAMP", "NOTIFICATION_TYPE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table O_MODEL_TRADE
--------------------------------------------------------

  ALTER TABLE "ADMIN"."O_MODEL_TRADE" ADD PRIMARY KEY ("SYMBOL", "CREATE_MODEL_TIMESTAMP")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table D_IB_OPEN_ORDER
--------------------------------------------------------

  ALTER TABLE "ADMIN"."D_IB_OPEN_ORDER" ADD PRIMARY KEY ("PERMID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
